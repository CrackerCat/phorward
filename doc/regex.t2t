== Overview ==

libphorward provides a powerful set of functions relating to general string pattern matching and lexical analysis using regular expressions.

- The //pregex// object encapsulates several regular expression patterns into one data structure that is compiled into a reusable DFA (deterministic finite automata) for quick pattern processing. Strings can be matched, split or replaced on patterns.
- Based on the //pregex// object, the functions pregex_qmatch(), pregex_qsplit() and pregex_qreplace() are provided, for one-line string processing.
- The //plex// object ecapsulates a regular expression-based scanner for lexical analysis into one object. It is used by libphorward's [build-in parser generator #pparse] for lexical analysis also.
- All functions are designed to work on wide-character alphabets to fully support Unicode. Therefore, the flags PREGEX_COMP_WCHAR and PREGEX_RUN_WCHAR are provided, to allow processing on patterns and input strings provided as wide-character strings. If not explicitly deactivated by build-flags (-DUTF8), UTF-8 input is generally supported on all functions.
- Supports anchoring and back-references
- Patterns are internally encapsulated in structures of //pregex_ptn// objects, which are then used to generate the NFA (nondeterministic finite automata) from which a DFA is constructed (subset construction algorithm).
- Matches are described in a structure called //prange//.
- DFAs can be deployed in form of a two dimensional array containing all information that is required to run the regex without the slower, object-oriented data structure layers.
-

In general, regular expressions are made-up of the following elements:

|| Construct | Usage |
| ``[...]`` or ``[^...]`` | Specifies a character, character-class or negated character-class (^). |
| ``.`` | Specifies a character-class standing for "any character". Using this construct causes the terminal to be configured as "non-greedy".
| ``(`` and ``)`` | Parantheses to build sub-expressions. |
| ``|`` | The alternative operator to define multiple expressions at one expression level. |
| ``*`` | Kleene closure (none or several of previous expression) modifier. |
| ``+`` | Positive closure (one or several of previous expression) modifier. |
| ``?`` | Optional closure (none or one of previous expression) modifier. |
| ``^`` | Anchor at begin of pattern, marking begin-of-line. |
| ``$`` | Anchor at end of pattern, marking end-of-line. |
| ``<`` | Anchor at begin of pattern, marking begin-of-word. |
| ``>`` | Anchor at end of pattern, marking end-of-word. |


Any other character coming up is consumed as one expression. Escape sequences (C-style) and Unicode are supported.

Some examples:

- ``Hello World`` matches "Hello World",
- ``Hello? World`` matches "Hello World" and "Hell World",
- ``Hello+ World`` matches "Hello World" or "Hellooooooooo World",
- ``Hello* World`` matches "Hello World", "Hellooooooooo World" or even "Hell World",
- ``(Hello)? World`` matches "Hello World" and " World",
- ``(Hello)+ World`` matches "Hello World" and "HelloHelloHello World",
- ``(Hello)* World`` matches "Hello World", "HelloHelloHello World" or even " World",
- ``[any]+ World`` matches "any World", "n World, "an World" or "ayayayaaa World",
- ``[^none]* World`` matches "yuluthisisfun World", "xxx World" and " World",
- ``'([^']|\\')*'`` matches "''", "'Hello World'" or even "'What\'s Up?'",
- ``Hello|World`` matches "Hello" or "World",
- ``Hello (World|Universe)`` matches both "Hello World" or "Hello Universe".
-

== pregex: Operating on regular expressions ==

The //pregex// object is the object-oriented interface for actions working on regular expressions.

Patterns are compiled into a DFA and associated with the //pregex// object as a reusable state machine that can be executed several times.

Generally, the actions

- matching
- finding
- splitting
- replacing
-

by the compiled pattern are supported.

=== Construction and destruction ===

//pregex// objects are constructed by pregex_create(). First parameter is the regular expression pattern string that is compiled into a DFA. The second parameter allows to specify several flags for influencing the compile- and execution process. All flags can be combined using the bitwise or-operator (|).

|| Flag | Usage |
| PREGEX_COMP_WCHAR	| The regular expression provided to pregex_create() shall be casted to wchar_t. |
| PREGEX_COMP_NOANCHORS	| Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile regex to be forced nongreedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expression as case insensitive. |
| PREGEX_COMP_STATIC | The regular expression passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped. |
| PREGEX_RUN_WCHAR | Run regular expression with wchar_t as input. |
| PREGEX_RUN_NOANCHORS | Ignore anchors while processing the regex. |
| PREGEX_RUN_NOREF | Don't create references. |
| PREGEX_RUN_NONGREEDY | Force run regular expression nongreedy. |
| PREGEX_RUN_DEBUG | Debug mode; output some debug to stderr. |


pregex_free() destructs and releases a //pregex// object after its use.

```
pregex* r;

r = pregex_create( "[_A-Za-z]+", 0 );
pregex_free( r );
```

=== Matching ===

To immediatelly test if a //pregex//-object matches on a string, the function pregex_match() shall be invoked.

```
pregex* r;
char* s = "a1337b";
char* e;

r = pregex_create( "[0-9]+", 0 );
pregex_match( r, s, &e ); /* returns FALSE */
pregex_match( r, s + 1, &e ); /* returns TRUE, e receives s+5. */
```

pregex_match() only tests for a string that immediatelly matches the pattern. To find a matching pattern within a string, the function pregex_find() shall be invoked, which is called with the same parameters, but returns the position of the match instead of a bool state.

``` pregex_find( r, s, &e ); /* returns s + 1, e receives s+5. */

To find all matching patterns, pregex_find() must be called in a loop.

```
while( ( s = pregex_find( r, s, &e ) ) )
{
	printf( ">%.*s<\n", e - s, s );
	s = e;
}
```

The function pregex_findall() can do this with one call, and fills an //parray// object with //prange// structures.

```
parray* a;
prange* rg;

pregex_findall( r, s, &a );

while( ( rg = (prange*)parray_shift( a ) ) )
	printf( ">%.*s<\n", rg->end - rg->begin, rg->begin );

parray_free( a );
```

=== Splitting ===

Splitting a string by a regular expression can be done with pregex_split(). This function takes several parameters, and is designed to be called in a loop.

```
pregex* r;
char* s = "5 and 6 are the cross sums of 23 and 42.";
char* e;
char* n;

r = pregex_create( "[0-9]+", 0 );

while( s )
{
		if( ( s = pregex_split( r, s, &e, &n ) ) )
				printf( ">%.*s<\n", e - s, s );

		s = n;
}
```

There is also an one call shortcut pregex_splitall(), filling an array:

```
parray* a;
prange* rg;

pregex_splitall( r, s, &a );

while( ( rg = (prange*)parray_shift( a ) ) )
	printf( ">%.*s<\n", rg->end - rg->begin, rg->begin );

parray_free( a );
```

=== Replacing ===

The function pregex_replace() allows for replacing parts of strings by regular expressions.

```
char* ns;

ns = pregex_replace( r, s, "int" );
```

The result of this function is always an dynamically allocated string that contains the replaces version of the input string, even if there hadn't been any matches. The above example will return "int and int are the cross sums of int and int." when executed on the string of previous chapter. The returned string must always be released with pfree() after its use.

The replacement may also allow backreference-placeholders defined as ``$<backreference>``, to take parts of the matched regular expression into the replaces string. A back-reference is created for every opening that exists in the regular expression, and begins counting at 1.

This modified version

```
r = pregex_create( "([0-9]+)", 0 );
ns = pregex_replace( r, s, "int[$1]" );
```

will return "int[5] and int[6] are the cross sums of int[23] and int[42]." when executed on the example string.

To disable the backreference replacement features, the regular expression flag PREGEX_RUN_NOREF must be switched.

=== Quick-access functions ===

Based on the //pregex//-object, libphorward provides the shortcut functons

- pregex_qmatch() - match strings by pattern,
- pregex_qsplit() - split strings by pattern,
- pregex_qreplace() - replace strings by pattern
-

for immediate use, without creating and destroying a //pregex//-object. Because this is done within the function calls, multiple calls of these functions result in huger runtime latencies and produce more overhead.


== plex: Lexical analysis using regular expressions ==

The second part of libphorwards regular expression tools is the //plex//-object, which encapsulates all required features for creating lexical analyzers (in terms of compiler-writers also called "scanners" or "lexers") into one handy object.

A //plex//-object can be seen as a container, which merges multiple regular expressions together into one state machine to recognize tokens. A token is then identified by an unique number that is associated with the matching regular expression.

To tokenize a strings written in a simple programming language into operators, words, numbers and whitespace, one can define

```
#define WHITE 	1
#define NUMBER	2
#define WORD	3

char* s = "Hello 234 World 5 67		exploration";
plex* l;

l = plex_create( 0 );

plex_define( l, "[ \t\r\n]+", WHITE, 0 );
plex_define( l, "[0-9]+", NUMBER, 0 );
plex_define( l, "[A-Za-z_][A-Za-z_0-9]*", WORD, 0 );

```
