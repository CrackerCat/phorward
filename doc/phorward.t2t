Phorward Toolkit Reference Manual
libphorward 0.18
July 2015

%!preproc(xhtml): '@([a-zA-Z0-9_]+)((\(\))?)' '[\1\2 #fn_\1]'
%!preproc(xhtml): '%NEED:(\d+)' "''' <!-- NEED \1 -->"
%!preproc(xhtml): '%FUNCTION:BEGIN' "''' <div class='function'>"
%!preproc(xhtml): '%FUNCTION:END' "''' </div>"
%!preproc(xhtml): '%DEFINITION:BEGIN' "''' <div class='definition'>"
%!preproc(xhtml): '%DEFINITION:END' "''' </div>"
%!postproc(xhtml): '\(C\)' '&copy;'

%-------------------------------------------------------------------------------

= Table of Contents =

%%toc

= General =

== What is libphorward? ==

The Phorward Toolkit provides a powerful set of useful functions for C programmers, which heavily focus on the topic of compiler-frontend development, meaning parsing and lexical analysis. The project can be seen as a dynamic generator and executor for lexers and parsers which can be defined and executed immediatelly within the program's sourcecode, making an extra step of generating parse tables or a recursive-descent parser unnecessary.

The following example defines a simple grammar, runs a parser and prints the generated abstract syntax tree:

%!include: ``example.c``

(to compile it, run: ``gcc -o example example.c -lphorward``)

Additionally, the toolkit also provides useful general-purpose extensions for dynamic data structures (linked lists, hash-tables, stacks and arrays), extended string management functions and some platform-independent, system-specific helper functions.

== Feature overview ==

The Phorward Toolkit provides

- Parser development tools
  - BNF-based grammar definition
  - generators and executors for LR, LALR and LL grammars
  - a uniform AST (abstract syntax tree) representation
  - tools for AST traversal (coming soon!)
  - tools for parser deployment (coming soon!)
- Lexer development tools
  - regular expressions and pattern definition interface
  - //plex// for lexical analyzers
  - //pregex// for regular expressions
  - tools for regex and lexer deployment
  - string functions for regular expression matching, splitting and replacement
- Dynamic data structures
  - //plist// for linked-lists with build-in hash table support,
  - //parray// for arrays and stacks.
- Extended string management functions
  - concat, extend, tokenize, shorthand allocation of strings and wide-character strings
  - consistent byte- and wide-character (unicode) function support
  - unicode support for UTF-8 in byte-character functions
- Debug und trace facilities
- A build-in DOM-based XML-parser
- Universal system-specific functions for platform-independent C software development
  - Unix-style command-line parser
  - Mapping files to strings
- Object-oriented fashion for all function interfaces (e.g. plist, parray, pregex, pgram, ...)
- Growing code-base of more and more powerful functions
-

Please check out http://phorward.phorward-software.com/ from time to time to get the latest news, documentation, updates and support on the Phorward Toolkit.

== Building from sources ==

Building the Phorward Toolkit is simple as every GNU-style open source program. Extract the release tarball or clone the Mercurial repository into a directory of your choice.

Then, run

``` ./configure

to configure the build-system and generate the Makefiles for your current platform. After successful configuration, run

``` make

and

``` make install

(properly as root), to install the toolkit into your system.

On Windows systems, the usage of [Cygwin #http://cygwin.org/] or another Unix shell environment is required. The Phorward Toolkit also perfectly cross-compiles on Linux using the MinGW and MinGW_x86-64 compilers.

To compile into 32-Bit Windows executables, configure with

``` ./configure --host=i486-mingw32 --prefix=/usr/i486-mingw32

To compile into 64-Bit Windows executables, configure with

``` ./configure --host=x86_64-w64-mingw32 --prefix=/usr/x86_64-w64-mingw32

== Alternative local development system ==

Alternatively to the autotools build system used for installation, there is also a simpler method on setting up a local build system for development and testing purposes.

Once, type

``` make -f Makefile.gnu make_install

then, a simple run of

``` make

can be used to simply build the entire library or parts of it.

Note, that changes to the build system then must be done in the local Makefile, the local Makefile.gnu as well as the Makefile.am for the autotools-based build system.

== Who develops libphorward? ==

The Phorward Toolkit is developed and maintained by Jan Max Meyer, Phorward Software Technologies.

It is the result of a several years experience in parser development systems, and has been preceded by the parser generators [UniCC http://unicc.phorward-software.com/] and [JS/CC http://jscc.phorward-software.com]. The libphorward shall be the final step for the most universal, compiler-frontend toolchain, still established on the good, old C programming language.

Help of any kind to extend and improve this product is always appreciated.

== Copyright ==

Copyright (C) 2006-2015 by Phorward Software Technologies, Jan Max Meyer.

You may use, modify and distribute this software under the terms and conditions of the 3-clause BSD license. The full license terms can be obtained from the file LICENSE.

THIS SOFTWARE IS PROVIDED BY JAN MAX MEYER (PHORWARD SOFTWARE TECHNOLOGIES) ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JAN MAX MEYER (PHORWARD SOFTWARE TECHNOLOGIES) BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

%-------------------------------------------------------------------------------

= Guidelines =

The Phorward Toolkit, shortly called libphorward, is a well-established C programming library which has its origins in several existing projects, where many features had been modularized and unified for a general purpose usage.

The roots of this library go back into the year 2006, where Phorward Software began with the development of a universal programming library shared by several C projects that existed at this time. Since then, the library heavily grew and also had many redesign stages behind.

Althought time went on, libphorward still is a state-of-the-art software toolchain for many everyday C programmer's tasks.

libphorward has its own function style paradigm and coding standard. Therefore, the following rules and conditions are characteristic when working with libphorward's tools.

- any functions, data-types and tools provided by libphorward begin with the prefixing character "p", defines and constants begin with an uppercase "P". The only exceptions for this are the boolean constants TRUE and FALSE, and the debug macros.
- defines are always written in uppercase-order.
- all functions are written in an underscore-style, so like with camel-case, the function ``pListGet()`` is written ``plist_get()`` in libphorward.
-

As general C coding style, we don't use ugly K&R style or any other coding standard style.
The libphorward style (which is only our style within the library) is:

%!include: ``codestyle.c``

If you don't like our coding style, you still can code on your own style, but please not within libphorward's own sources which are for the general public - these shall be kept clear - Thank you! :)

%-------------------------------------------------------------------------------

= General tools =

The Phorward Toolkit provides some extensional general-purpose functions, making C programming a little way easier and simpler. It is not necessary or required to use these functions when creating software that makes use of features from the Phorward Toolchain, but maybe they fit some developer's needs and could be useful.

== Booleans ==

libphorward makes a heavy usage of the self-hosted data-type **pboolean**, which is also referenced by a define //BOOLEAN//, and the constants //TRUE// and //FALSE//.

It is known, that several header files and projects define these constants on their own, so that **pboolean**, the data-type, exists on its own using the p-prefix, but any of the defines are conditionally flagged with

```
#ifndef TRUE
#define TRUE					1
#endif
```

within phorward.h.

== Replacement for memory functions ==

The standard memory allocation functions can be replaced by these pendants:

- @pmalloc() - allocate and zero-intialize memory, stop on error.
- @prealloc() - reallocate memory, stop on error.
- @pfree() - free memory and return (void*)NULL pointer.
- @pmemdup() - shorthand for a malloc() with memcpy().
-

These functions are entirely used trough libphorward's internal object mapping functions.

== Debug and trace facilities ==

Althought this option is not widely used in modern C/C++ projects, libphorward offers an own debug and trace facility that can be turned on for modules for detecting bugs or view the program trace.

For this, the library provides the following macros:

- @PROC() - starting macro marking a functions entry point,
- @PARMS() - log function parameters,
- @VARS() - log variables,
- @MSG() - debug message
- @RETURN() - return a value
- @VOIDRET - return from a void function.
-

So when a function is written like this in libphorward's way:

```
int faculty( int x )
{
	int ret;

	PROC( "faculty" );
	PARMS( "x", "%d", x );

	if( x < 0 )
	{
		WRONGPARAM;
		RETURN( -1 );
	}
	else if( x == 0 )
	{
		MSG( "x is 0, so faculty is 1" );
		RETURN( 1 );
	}
	else
	{
		MSG( "Calling faculty recursively with:" );
		VARS( "x - 1", "%d", x - 1 );
		ret = x * faculty( x - 1 );
	}

	VARS( "ret", "%d", ret );
	RETURN( ret );
}
```

Trace is written to stderr, and only will be compiled into the executable code if the DEBUG preprocessor-flag is defined with a value > 0.

Calling this function with

``` faculty( 3 );

yields in a debug log

```
20772 (demo.c:  380) {
20772 (demo.c:  380) .ENTRY : faculty
20772 (demo.c:  381) .PARMS : x = >3<
20772 (demo.c:  395) .MSG   : Calling faculty recursively with:
20772 (demo.c:  396) .VARS  : x - 1 = >2<
20772 (demo.c:  380) .{
20772 (demo.c:  380) ..ENTRY : faculty
20772 (demo.c:  381) ..PARMS : x = >2<
20772 (demo.c:  395) ..MSG   : Calling faculty recursively with:
20772 (demo.c:  396) ..VARS  : x - 1 = >1<
20772 (demo.c:  380) ..{
20772 (demo.c:  380) ...ENTRY : faculty
20772 (demo.c:  381) ...PARMS : x = >1<
20772 (demo.c:  395) ...MSG   : Calling faculty recursively with:
20772 (demo.c:  396) ...VARS  : x - 1 = >0<
20772 (demo.c:  380) ...{
20772 (demo.c:  380) ....ENTRY : faculty
20772 (demo.c:  381) ....PARMS : x = >0<
20772 (demo.c:  390) ....MSG   : x is 0, so faculty is 1
20772 (demo.c:  391) ....RETURN: faculty
20772 (demo.c:  391) ...}
20772 (demo.c:  400) ...VARS  : ret = >1<
20772 (demo.c:  401) ...RETURN: faculty
20772 (demo.c:  401) ..}
20772 (demo.c:  400) ..VARS  : ret = >2<
20772 (demo.c:  401) ..RETURN: faculty
20772 (demo.c:  401) .}
20772 (demo.c:  400) .VARS  : ret = >6<
20772 (demo.c:  401) .RETURN: faculty
20772 (demo.c:  401) }
```

== Command-line tools ==

libphorward also provides some general-purpose command-line tools which are installed and made available. These tools are heavily used by libphorward's own build process.

- pproto - is a function prototype generator,
- pinclude - is some kind of simple pre-processor to generate one big file from various smaller ones,
- premcomments - remove any comments from C sources
- pdostounix - Convert DOS-formatted text into Unix format.
-

The general command-line tools are written as shell scripts in combination with standard Unix command-line utilities like awk, grep and sed.

%TODO: doc generator

%-------------------------------------------------------------------------------

= String tools =

The libphorward provides a set of functions for extended, dynamic string memory handling.

These function are

- @pstrcasecmp() - case-insensitive string comparison,
- @pstrcatchar() - append character to string with dynamic allocation,
- @pstrcatstr() - append string to string with dynamic allocation,
- @pstrdup() - duplicate string, also accepts NULL-pointers,
- @pstrget() - securely get string from a pointer,
- @pstrlen() - return length ot string, also accepts NULL-pointers,
- @pstrltrim() - remove prefixing whitespace,
- @pstrlwr() - convert string to lower-case-order,
- @pstrncasecmp() - case-insensitive string comparison over maximum length,
- @pstrncatstr() - append string to string with dynamic allocation and maximum length,
- @pstrndup() - duplicate a string with maximum length,
- @pstrput() - securely set an allocated string into a pointer,
- @pstrrender() - dynamically render a string with placeholder substitution,
- @pstrreplace() - dynamically replace substrings within string,
- @pstrrtrim() - remove trailing whitespace,
- @pstrsplit() - dynamic tokenizer,
- @pstrtrim() - remove prefixing and trailing whitespace,
- @pstrupr() - convert string to lower-case-order.
-

Additionally, the following pendants for wide-character strings (wchar_t) exist and are available, when libphorward is compiled with the UNICODE flag enabled.

- @pwcscatchar() - append character to wide-character string with dynamic allocation,
- @pwcscatstr() - append wide-character string to wide-character string with dynamic allocation,
- @pwcsdup() - duplicate wide-character string, also accepts NULL-pointers,
- @pwcsget() - securely get wide-character string from a pointer,
- @pwcslen() - return length ot wide-character string, also accepts NULL-pointers,
- @pwcsncatstr() - append wide-character string to wide-character string with dynamic allocation and maximum length,
- @pwcsndup() - duplicate a wide-character string with maximum length,
- @pwcsput() - securely set an allocated wide-character string into a pointer.
-

Althought the wide-character pendants to the standard extended string functions are not consistent right now, they may be extended in the future, when the existence of such functions is needed, or another, brave programmer is having the fun to implement them.

%-------------------------------------------------------------------------------

= Dynamic data management tools =

== parray: Arrays and stacks ==

%!include: array.t2t

== plist: Linked lists, hash-tables and queues ==

%!include: list.t2t

== pccl: Character-classes ==

%!include: ccl.t2t

%-------------------------------------------------------------------------------

= pregex, plex: Regular expression tools =

%!include: regex.t2t

%-------------------------------------------------------------------------------

= pparse: Parser development tools =

%!include: parse.t2t

%-------------------------------------------------------------------------------

= Utility functions =

Coming soon.

%-------------------------------------------------------------------------------

= Function reference =

%!include: ref.t2t

