The Phorward Foundation Toolkit
Reference Manual

= Function Reference =

== parray ==

The **parray** object is a general-purpose data structure which can be used for several operations. **parray** forms a data management container for handling homogenious elements of the same size in a dynamic way. These elements can be atomic data types, pointers or structures. Elements are automatically allocated with a specified chunk-size, and can be appended or prepended to the given **parray** object.

**parray** objects are created using parray_create() or initialized with parray_init(). The specific functions require the objects byte size that is required for every single element, and a chunk-size. Latter one can be omitted by specifing a chunk-size of 0, so that 128 elements per chunk will be the default. Objects can be cleared with parray_erase(), respectively cleared and freed with parray_free().

```
parray* a;

a = parray_create( sizeof( usertype ), 0 );

/* Do something... */

parray_free( a );
```

Elements can be inserted with

- parray_insert() - Insert element at any desired offset,
- parray_push() - Push element to end of array,
- parray_shift() - Shift element on begin of array,
- parray_malloc() - Zero-initialize new element at end of array, and
- parray_rmalloc() - Zero-initialize new element at begin of array.
-

```
parray* a;
usertype t;
usertype* tp;

fill_usertype( &t );
parray_insert( a, 2, &t );

fill_usertype( &t );
parray_push( a, &t );
parray_shift( a, &t );

tp = (usertype*)parray_malloc( a );
fill_usertype( tp );
tp = (usertype*)parray_rmalloc( a );
fill_usertype( tp );
```

Direct access to specific elements is done using

- parray_get() - Get element by offset from begin, and
- parray_rget() - Get element by offset from end.
-

Iterating over the elements:

```
parray* a;
usertype* tp;
int i;

/* Iterate from first to last. */
for( i = 0; ( tp = (usertype*)parray_get( a, i ) ); i++ )
	;

/* Iterate from last to first. */
for( i = 0; ( tp = (usertype*)parray_rget( a, i ) ); i++ )
	;
```

Elements can be replaced with

- parray_put() - Put element by offset from begin, respective
- parray_rput() - Put element by offset from end.
-

Quick access to the first or last elements is gained by parray_last() and parray_first().

Elements can be removed with

- parray_remove() - Remove element at any desired offset,
- parray_pop() - Remove last element like from a stack, and
- parray_unshift() - Remove first element.
-

```
parray* a;
usertype t;
usertype* tp;

parray_remove( a, 2, &t );
tp = (usertype*)parray_pop( a );
tp = (usertype*)parray_unshift( a );
```

Other, useful functions are

- parray_count() - Get number of elements within object,
- parray_offset() - Get offset of element by pointer,
- parray_partof() - Check if element is part of object,
- parray_swap() - Swap two elements within an object.
- parray_reserve() - Assume memory pre-allocation.
-

== plist ==

Next to the **parray** object, the **plist** object is a powerful C implementation of a double-linked list with some extra features. It is also used for handling homogenious elements of the same size in a dynamic way, and can be used for many tasks, including symbol tables, functions relating to set theories or for associative arrays. **plist** can be seen as a superset of the **parray** object, because it features nearly the same operations but with other underlying data management methods.

The **plist** object implements:

- a double linked-list
- hashable entries (hash table, including same element key stacking)
- dynamic stack functionalities
- data object collections
- set functions
-

**plist** objects are created using plist_create() or initialized with plist_init(). The specific functions require the objects byte size that is required for every single element, and a flag configuration, that configures the **plist** object to a specified behavior.

Possible flags are:

- **PLIST_MOD_NONE** no flags, this can also be just 0.
- **PLIST_MOD_PTR** to use the plist-object in pointer-mode: Each element cointains only a pointer to an object in the memory and returns this, instead of copying from or into pointers.
- **PLIST_MOD_RECYCLE** to configure that elements that are removed during list usage will be reused later, which reduces dynamic memory consumption.
- **PLIST_MOD_EXTKEYS** to configure that string pointers to hash-table key values are stored elsewhere, so the plist-module only uses the original pointers instead of copying them.
- **PLIST_MOD_UNIQUE** to disallow hash-table-key collisions, so elements with a key that already exist in the object will be rejected.
- **PLIST_MOD_WCHAR** to let all key values handle as wide-character strings.
- **PLIST_MOD_PTRKEYS** disables string keys and uses the pointer/value provided as key directly.
-

The mode **PLIST_MOD_PTR** is automatically set if the elements size is specified as 0.

```
plist* l;

l = plist_create( sizeof( usertype ), PLIST_MOD_RECYCLE );

/* Do something... */

plist_free( l );
```

Elements can be inserted with

- plist_insert() - Insert element, optionally with key, at any desired position,
- plist_push() - Push element to end of list,
- plist_shift() - Shift element on begin of list,
- plist_malloc() - Zero-initialize new element at end of list, and
- plist_rmalloc() - Zero-initialize new element at begin of list.
-

```
plist* l;
usertype t;
usertype* tp;

fill_usertype( &t );
plist_insert( l, plist_get( l, 2 ), &t );

fill_usertype( &t );
plist_push( a, &t );
plist_shift( a, &t );

tp = (usertype*)plist_malloc( a );
fill_usertype( tp );
tp = (usertype*)plist_rmalloc( a );
fill_usertype( tp );
```

Elements within a **plist** object are references by **plistel** items. To access the data element behind a **plistel** item, the function plist_access() is used.


