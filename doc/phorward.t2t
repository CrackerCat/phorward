The Phorward Foundation Toolkit
Reference Manual

= General =

== Description ==

The Phorward Foundation Toolkit provides a powerful toolchain within an extended functions library (libphorward) to implement more powerful, more useful programs using the C programming language.

With the use of the Phorward Foundation Toolkit, programmers are enabled to enhance their C and C++ programs with the capabilities of dynamic linked lists, hash tables, stacks, string management functions, full-fledged regular expressions and multi-platform system-functions. The entire library is designed to work with both UTF-8-enabled and wide-character-based Unicode character sets.

The main intention behind the Phorward Foundation Toolkit is the development of software products that are having their origin at Phorward Software Technologies. Phorward Software Technologies is a software company from Dortmund, Germany, that focuses strongly on the development of high-performance software solutions around the area of compilers, compiler-construction tools, scripting languages and general software development tools. Because almost all of Phorward Softwares newer solutions are open-source-based products, the Phorward Foundation Toolkit forms the general base of all C-based projects.

== Features ==

The Phorward Foundation Toolkit provides

- Extensions for dynamical standard data structures: Linked lists, hash tables, stacks, bitsets
- Extending string functions for dynamic string management
- Powerful implementation of regular expressions, including tools for their construction, transformation and analysis
- Universal system-specific functions for platform-independent C software development
- An XML-parser (DOM) and management tools
- A universal, extendable variant-styled data type structure to work with arbitrary values within one object
- Consistent support of Unicode by supporting UTF-8-byte character strings and wide-character strings
- Object-oriented fashion of some function interfaces (e.g. regular expressions)
- Growing code-base of more and more powerful functions
-

== Building ==

Building the Phorward Foundation Toolkit is simple as every GNU-style open source program. Extract the released tarball or clone the Mercurial repository into a directory of your choice.

Then, run

``` ./configure

to configure the build-system and generate the Makefiles for your current platform. After successful configuration, run

``` make

and

``` make install

(properly as root), to install the toolkit into your system.

On Windows systems, the usage of [Cygwin #http://cygwin.org/] or another Unix shell environment is required. The Phorward Foundation Toolkit also perfectly cross-compiles on Linux using the MinGW and MinGW_x86-64 compilers.

To compile into 32-Bit Windows executables, configure with

``` ./configure --host=i486-mingw32 --prefix=/usr/i486-mingw32

To compile into 64-Bit Windows executables, configure with

``` ./configure --host=x86_64-w64-mingw32 --prefix=/usr/x86_64-w64-mingw32

= Usage =

This chapter describes how the Phorward Foundation Toolkit is used in general, and how its elements can be perfectly integrated into existing systems.

== How to import? ==

To import functions from the Phorward Foundation Toolkit, simply

``` #include <phorward.h>

into your programs. 

The linker must be told to link //libphorward.a// for the static version, //libphorward.so// for the dynamic version.

A simple example program extracting numbers from a string

``` 
#include <phorward.h>

int main()
{
        uchar*          str     =   "This 1st release of a 1337 "
                                    "software is really awe50me!";
        pregex_range*   r;
        int             cnt, i;

        cnt = pregex_qmatch( "[0-9]+", str, PREGEX_MOD_GLOBAL, &r );

        for( i = 0; i < cnt; i++ )
                printf( "%d: %.*s\n", i, r[i].len, r[i].begin );

        pfree( r );
        return 0;
}
```

compiles perfectly with

``` cc -o hello hello.c -lphorward

and runs simply by typing

```
$ ./hello
0: 1
1: 1337
2: 50
```

== System-independent data-types ==

The Phorward Foundation Toolkit provides the following standard data types in general.

|| Type | Alias | C-type | used for |
| uchar | - | unsigned char | UTF-8-enabled character string, this is **unsigned char**. |
| pchar | wchar | wchar_t or unsigned int | If unicode-support enabled, pchar is of type **wchar_t**, else of type **unsigned int**. |
| pboolean | BOOLEAN, boolean | char | A type to store TRUE or FALSE. |
| pint | | int | Integer value type. |
| plong | | long | Long value type. |
| pfloat | | float | Floating point value type. |
| pdouble | | double | Double floating point value type. |
| pulong | | size_t | Unsigned long value type. |
| psize | | size_t | Unsigned size-type. |

== Errorcodes ==

May functions of the Phorward Foundation Toolkit return one of the following error codes on failure. They are always negative. A value of 0 or ERR_OK identifies a successfull action, a positive return code identifies another, more specific error, or a kind of successfull function run.

|| Errorcode (Define) | Meaning |
| ERR_OK | Function executed successfully. |
| ERR_FAILURE | Function generally failed. |
| ERR_PARMS | Function parameters where wrong. |
| ERR_MEM* | A memory allocation error occured. |
| ERR_SYSTEM | A system-error occured. |
| ERR_UNIMPL | A part of the function is not implemented in the given parameter constellation. |
| ERR_OTHER | Another error occured. |


* Normally, functions of the Phorward Foundation Toolkit that run into insufficent memory errors immediatelly exit the program with a message to stderr and errorcode 1.
This behavior can be changed by redefining the OUTOFMEM-macro.

== Macros ==

The following macros can be used.

|| Macro | Usage |
| OUTOFMEM | Immediatelly stops the program with the message "Ran out of memory" to stderr. |
| WRONGPARAM | Prints a warning message to stderr that a function was called with wrong parameters. |

== Dynamic general-purpose data structures ==

The Phorward Foundation Toolkit provides general-purpose data structures for various situations.

=== Linked lists ===[linked_list]

The LIST-structure and related functions can be used for dynamic creation and manipulation of single linked-lists.
Each LIST-element is a simple constructure that provides a pointer to the data-part that is associated with the list, and a pointer to the follower, which is (LIST*)NULL in case of the last element.

```
LIST*    mylist;        /* This is our main list */
LIST*    l;             /* l, for list iteration */
uchar*   values[] = { "Hello", "World", "out there!" };

/* Create the list. */
mylist = list_push( (LIST*)NULL, (void*)values[0] );
mylist = list_push( mylist, (void*)values[1] );
mylist = list_push( mylist, (void*)values[2] );

/* Let's iterate trough it. */
printf( "mylist contains %d items\n", list_count( mylist ) );
for( l = mylist; l; l = list_next( l ) )
    printf( "%s ", (uchar*)list_access( l ) );

/* Now, we remove one element (identified by its pointer) and iterate
    the list again */
mylist = list_remove( mylist, (void*)values[1] );
printf( "\nmylist contains now %d items\n", list_count( mylist ) );

/* LISTFOR expands in a for-loop as above, but is shorter! */
LISTFOR( mylist, l )
    printf( "%s ", (uchar*)list_access( l ) );

printf( "\n" );

/* Free the entire list */
mylist = list_free( mylist );
```

- [list_access() #fn_list_access] - Access the list elements data pointer.
- [list_count() #fn_list_count] - Count elements in list.
- [list_diff() #fn_list_diff] - Compare lists for same elements.
- [list_dup() #fn_list_dup] - Duplicate a list.
- [list_find() #fn_list_find] - Get data element index number.
- [list_free() #fn_list_free] - Free entire list.
- [list_getptr() #fn_list_getptr] - Get list element by index.
- [list_next() #fn_list_next] - Access list elements follower.
- [list_pop() #fn_list_pop] - Remove and return last element from list.
- [list_push() #fn_list_push] - Create/extend a list.
- [list_remove() #fn_list_remove] - Remove element from list.
- [list_sort() #fn_list_sort] - Sort list.
- [list_subset() #fn_list_subset] - Check for subset of two lists.
- [list_union() #fn_list_union] - Union elements of two lists, remove duplicates.
-

=== Hash Tables ===[hash_table]

The HASHTAB-structure and related functions implement an easy-to-handle and flexible hash-table implementation. Hash-tables can perfectly be used to implement symbol tables using string identifiers, including element overloading.

A hash-table consists of the elements HASHTAB, describing the hash-table, HASHBUCKET, describing an hash-table bucket, and HASHELEM, describing the final hash-table element that is stored.
Hash-tables in the Phorward Foundation Toolkit can be configured to allow for collisions or not. If collisions are enabled, the hash-table permits to add multiple elements with the same key, so it is possible to overwrite and hide general elements with more specific ones. It is also possible to discard elements for later use or to entirely destroy them. Discarding elements is more memory friendly, because the elements memory will be reused after anoter insert-operation. Calling an delete-operation also frees the used memory.

```
HASHTAB		ht;
HASHELEM*	e;
LIST*		l;

/* We configure a hash-table with 6 buckets, wide-character enabled and
	list-feature enabled */
hashtab_init( &ht, 6, HASHTAB_MOD_WCHAR | HASHTAB_MOD_LIST );

/* Let's insert some data */
hashtab_insert( &ht, (uchar*)L"Hello", "This is my first string" );
hashtab_insert( &ht, (uchar*)L"World", "And this is my second one" );
hashtab_insert( &ht, (uchar*)L"Test", "Last but no least, the third :)" );

/* Get one entry */
e = hashtab_get( &ht, (uchar*)L"World" );
printf( ">%s<\n", (uchar*)hashelem_access( e ) );
printf( "%d items in table\n", hashtab_count( &ht ) );

/* Loop trough the entries, without any order */
for( e = hashtab_fetch( &ht, (HASHELEM*)NULL );
		e; e = hashtab_fetch( &ht, e ) )
	printf( ">%ls<: >%s<\n",
		(pchar*)hashelem_key( e ),
			(uchar*)hashelem_access( e ) );

/* Loop trough the entries using the list */
LISTFOR( hashtab_list( &ht ), l )
{
	e = (HASHELEM*)list_access( l );
	printf( ">%ls<: >%s<\n",
		(pchar*)hashelem_key( e ),
			(uchar*)hashelem_access( e ) );
}

/* Dump the table to stderr */
hashtab_print( &ht, stderr );

/* Discard the element with the key "World" */
hashtab_discard( &ht, (uchar*)L"World", HASHTAB_NO_CALLBACK );

/* Print again! */
hashtab_print( &ht, stderr );

/* Free entire table, reset all */
hashtab_free( &ht, HASHTAB_NO_CALLBACK );
```

- [hashtab_init() #fn_hashtab_init] - Initialize hash table.
- [hashtab_free() #fn_hashtab_free] - Free hash table, drop all elements.
- [hashtab_insert() #fn_hashtab_insert] - Insert element into hash table.
- [hashtab_get() #fn_hashtab_get] - Get element by key.
- [hashtab_update() #fn_hashtab_update] - Update element by key.
- [hashtab_discard() #fn_hashtab_discard] - Discard element by key.
- [hashtab_delete() #fn_hashtab_delete] - Delete (free) element by key.
- [hashtab_print() #fn_hashtab_print] - Dump hash table content to file stream.
- [hashtab_count() #fn_hashtab_count] - Count number of active elements in hash table.
- [hashtab_fetch() #fn_hashtab_fetch] - Fetch hash table elements.
- [hashelem_access() #fn_hashelem_access] - Access hash table elements data payload.
- [hashelem_key() #fn_hashelem_key] - Access hash table elements key string
- [hashelem_next() #fn_hashelem_next] - Access next hash table element.
- [hashelem_prev() #fn_hashelem_prev] - Acess previous hash table element.
-

Hash-tables allow for the following flags at initialization:

- **HASHTAB_MOD_EXTKEYS** - Hold keys externally; The memory will not be copied. This option should be used if the key value is part of the data-container pointer that is stored within the hash-table, and the pointer to this value is used as key pointer. It saves some memory.
- **HASHTAB_MOD_WCHAR** - Keys are of wide-character type.
- **HASHTAB_MOD_LIST** - All table elements are additionally hold in a [linked list #linked_list], to keep the insertation order of the hash table elements. This requires a little more memory.
- **HASHTAB_MOD_NO_COLL** - Disallow collisions of hash table elements; When inserted, (HASHELEM*) NULL will be returned if a collision occurs!
-
