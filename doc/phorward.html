<?xml version="1.0"
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The Phorward Libraries</title>
<meta name="generator" content="http://txt2tags.org" />
<link rel="stylesheet" type="text/css" href="phorward.css" />
<link rel="stylesheet" type="text/css" href="prism.css" />
<script src="prism.js"></script>
</head>
<body>

<div class="header" id="header">
<h1>The Phorward Libraries</h1>
<h2>libphorward 0.22.0</h2>
<h3>April 2018</h3>
</div>

<div class="body" id="body">

<h1 id="toc1">Table of Contents</h1>

<div class="toc">

  <ul>
  <li><a href="#toc1">Table of Contents</a>
  </li>
  <li><a href="#toc2">Introduction</a>
  </li>
  <li><a href="#toc3">Features</a>
  </li>
  <li><a href="#toc4">Installation</a>
    <ul>
    <li><a href="#toc5">Building from sources</a>
    </li>
    <li><a href="#toc6">Building on Windows</a>
    </li>
    <li><a href="#toc7">Local development build</a>
    </li>
    </ul>
  </li>
  <li><a href="#toc8">Intention behind this library</a>
  </li>
  <li><a href="#toc9">Dynamic general-purpose objects</a>
    <ul>
    <li><a href="#toc10">parray: Arrays and stacks</a>
      <ul>
      <li><a href="#toc11">Overview</a>
      </li>
      <li><a href="#toc12">Construction and destruction</a>
      </li>
      <li><a href="#toc13">Inserting elements</a>
      </li>
      <li><a href="#toc14">Accessing and iterating elements</a>
      </li>
      <li><a href="#toc15">Removing elements</a>
      </li>
      <li><a href="#toc16">Additional functions</a>
      </li>
      </ul>
    </li>
    <li><a href="#toc17">plist: Linked lists, hash-tables, queues and stacks</a>
      <ul>
      <li><a href="#toc18">Overview</a>
      </li>
      <li><a href="#toc19">Construction and destruction</a>
      </li>
      <li><a href="#toc20">Inserting elements</a>
      </li>
      <li><a href="#toc21">Accessing and iterating elements</a>
      </li>
      <li><a href="#toc22">Removing elements</a>
      </li>
      <li><a href="#toc23">Sorting elements</a>
      </li>
      <li><a href="#toc24">Interchanging functions</a>
      </li>
      <li><a href="#toc25">Additional functions</a>
      </li>
      </ul>
    </li>
    <li><a href="#toc26">pccl: Character-classes</a>
    </li>
    </ul>
  </li>
  <li><a href="#toc27">pregex, plex: Regular expression handling and lexical analyzers</a>
    <ul>
    <li><a href="#toc28">Overview</a>
      <ul>
      <li><a href="#toc29">Meta constructs</a>
      </li>
      <li><a href="#toc30">Characters and escape sequences</a>
      </li>
      <li><a href="#toc31">Shorthand character classes</a>
      </li>
      <li><a href="#toc32">Anchoring</a>
      </li>
      <li><a href="#toc33">Examples</a>
      </li>
      </ul>
    </li>
    <li><a href="#toc34">pregex: Operating on regular expressions</a>
      <ul>
      <li><a href="#toc35">Construction and destruction</a>
      </li>
      <li><a href="#toc36">Matching</a>
      </li>
      <li><a href="#toc37">Splitting</a>
      </li>
      <li><a href="#toc38">Replacing</a>
      </li>
      <li><a href="#toc39">Quick-access functions</a>
      </li>
      </ul>
    </li>
    <li><a href="#toc40">plex: Lexical analysis using regular expressions</a>
    </li>
    </ul>
  </li>
  <li><a href="#toc41">ppgram, ppar, ppast: Grammars, parsers and abstact-syntax trees</a>
    <ul>
    <li><a href="#toc42">Overview</a>
    </li>
    <li><a href="#toc43">Grammars</a>
      <ul>
      <li><a href="#toc44">Hand-crafting a grammar</a>
      </li>
      <li><a href="#toc45">Expressing grammars in Backus-Naur-Form</a>
      </li>
      <li><a href="#toc46">More grammar-related functions</a>
      </li>
      </ul>
    </li>
    <li><a href="#toc47">Parsers</a>
    </li>
    <li><a href="#toc48">Abstract Syntax Tree</a>
    </li>
    </ul>
  </li>
  <li><a href="#toc49">Miscelleanous</a>
    <ul>
    <li><a href="#toc50">Advanced memory management functions</a>
    </li>
    <li><a href="#toc51">Extended string processing functions</a>
    </li>
    <li><a href="#toc52">System-related functions</a>
    </li>
    <li><a href="#toc53">Boolean data type</a>
    </li>
    <li><a href="#toc54">Debug and trace facilities</a>
    </li>
    <li><a href="#toc55">Command-line tools</a>
      <ul>
      <li><a href="#toc56">pregex</a>
      </li>
      <li><a href="#toc57">plex</a>
      </li>
      <li><a href="#toc58">pparse</a>
      </li>
      </ul>
    </li>
    <li><a href="#toc59">Other tools</a>
    </li>
    </ul>
  </li>
  <li><a href="#toc60">Reference</a>
    <ul>
    <li><a href="#toc61">Macros</a>
      <ul>
      <li><a href="#fn_LOG">LOG</a>
      </li>
      <li><a href="#fn_MSG">MSG</a>
      </li>
      <li><a href="#fn_PARMS">PARMS</a>
      </li>
      <li><a href="#fn_PPSYM_IS_TERMINAL">PPSYM_IS_TERMINAL</a>
      </li>
      <li><a href="#fn_PP_AST_DUMP">PP_AST_DUMP</a>
      </li>
      <li><a href="#fn_PP_GRAM_DUMP">PP_GRAM_DUMP</a>
      </li>
      <li><a href="#fn_PROC">PROC</a>
      </li>
      <li><a href="#fn_RETURN">RETURN</a>
      </li>
      <li><a href="#fn_VARS">VARS</a>
      </li>
      <li><a href="#fn_VOIDRET">VOIDRET</a>
      </li>
      <li><a href="#fn_parray_for">parray_for</a>
      </li>
      <li><a href="#fn_plist_for">plist_for</a>
      </li>
      </ul>
    </li>
    <li><a href="#toc74">Functions</a>
      <ul>
      <li><a href="#fn_p_ccl_add">p_ccl_add</a>
      </li>
      <li><a href="#fn_p_ccl_addrange">p_ccl_addrange</a>
      </li>
      <li><a href="#fn_p_ccl_compare">p_ccl_compare</a>
      </li>
      <li><a href="#fn_p_ccl_compat">p_ccl_compat</a>
      </li>
      <li><a href="#fn_p_ccl_count">p_ccl_count</a>
      </li>
      <li><a href="#fn_p_ccl_create">p_ccl_create</a>
      </li>
      <li><a href="#fn_p_ccl_del">p_ccl_del</a>
      </li>
      <li><a href="#fn_p_ccl_delrange">p_ccl_delrange</a>
      </li>
      <li><a href="#fn_p_ccl_diff">p_ccl_diff</a>
      </li>
      <li><a href="#fn_p_ccl_dup">p_ccl_dup</a>
      </li>
      <li><a href="#fn_p_ccl_erase">p_ccl_erase</a>
      </li>
      <li><a href="#fn_p_ccl_free">p_ccl_free</a>
      </li>
      <li><a href="#fn_p_ccl_get">p_ccl_get</a>
      </li>
      <li><a href="#fn_p_ccl_instest">p_ccl_instest</a>
      </li>
      <li><a href="#fn_p_ccl_intersect">p_ccl_intersect</a>
      </li>
      <li><a href="#fn_p_ccl_negate">p_ccl_negate</a>
      </li>
      <li><a href="#fn_p_ccl_parse">p_ccl_parse</a>
      </li>
      <li><a href="#fn_p_ccl_parsechar">p_ccl_parsechar</a>
      </li>
      <li><a href="#fn_p_ccl_parseshorthand">p_ccl_parseshorthand</a>
      </li>
      <li><a href="#fn_p_ccl_print">p_ccl_print</a>
      </li>
      <li><a href="#fn_p_ccl_size">p_ccl_size</a>
      </li>
      <li><a href="#fn_p_ccl_test">p_ccl_test</a>
      </li>
      <li><a href="#fn_p_ccl_testrange">p_ccl_testrange</a>
      </li>
      <li><a href="#fn_p_ccl_to_str">p_ccl_to_str</a>
      </li>
      <li><a href="#fn_p_ccl_union">p_ccl_union</a>
      </li>
      <li><a href="#fn_pany_convert">pany_convert</a>
      </li>
      <li><a href="#fn_pany_copy">pany_copy</a>
      </li>
      <li><a href="#fn_pany_create">pany_create</a>
      </li>
      <li><a href="#fn_pany_dup">pany_dup</a>
      </li>
      <li><a href="#fn_pany_fprint">pany_fprint</a>
      </li>
      <li><a href="#fn_pany_free">pany_free</a>
      </li>
      <li><a href="#fn_pany_get_bool">pany_get_bool</a>
      </li>
      <li><a href="#fn_pany_get_char">pany_get_char</a>
      </li>
      <li><a href="#fn_pany_get_cstr">pany_get_cstr</a>
      </li>
      <li><a href="#fn_pany_get_cwcs">pany_get_cwcs</a>
      </li>
      <li><a href="#fn_pany_get_double">pany_get_double</a>
      </li>
      <li><a href="#fn_pany_get_float">pany_get_float</a>
      </li>
      <li><a href="#fn_pany_get_int">pany_get_int</a>
      </li>
      <li><a href="#fn_pany_get_long">pany_get_long</a>
      </li>
      <li><a href="#fn_pany_get_ptr">pany_get_ptr</a>
      </li>
      <li><a href="#fn_pany_get_str">pany_get_str</a>
      </li>
      <li><a href="#fn_pany_get_ulong">pany_get_ulong</a>
      </li>
      <li><a href="#fn_pany_get_wcs">pany_get_wcs</a>
      </li>
      <li><a href="#fn_pany_init">pany_init</a>
      </li>
      <li><a href="#fn_pany_parse">pany_parse</a>
      </li>
      <li><a href="#fn_pany_reset">pany_reset</a>
      </li>
      <li><a href="#fn_pany_set_bool">pany_set_bool</a>
      </li>
      <li><a href="#fn_pany_set_char">pany_set_char</a>
      </li>
      <li><a href="#fn_pany_set_cstr">pany_set_cstr</a>
      </li>
      <li><a href="#fn_pany_set_cwcs">pany_set_cwcs</a>
      </li>
      <li><a href="#fn_pany_set_double">pany_set_double</a>
      </li>
      <li><a href="#fn_pany_set_float">pany_set_float</a>
      </li>
      <li><a href="#fn_pany_set_int">pany_set_int</a>
      </li>
      <li><a href="#fn_pany_set_long">pany_set_long</a>
      </li>
      <li><a href="#fn_pany_set_ptr">pany_set_ptr</a>
      </li>
      <li><a href="#fn_pany_set_str">pany_set_str</a>
      </li>
      <li><a href="#fn_pany_set_ulong">pany_set_ulong</a>
      </li>
      <li><a href="#fn_pany_set_wcs">pany_set_wcs</a>
      </li>
      <li><a href="#fn_pany_to_bool">pany_to_bool</a>
      </li>
      <li><a href="#fn_pany_to_char">pany_to_char</a>
      </li>
      <li><a href="#fn_pany_to_double">pany_to_double</a>
      </li>
      <li><a href="#fn_pany_to_float">pany_to_float</a>
      </li>
      <li><a href="#fn_pany_to_int">pany_to_int</a>
      </li>
      <li><a href="#fn_pany_to_long">pany_to_long</a>
      </li>
      <li><a href="#fn_pany_to_ptr">pany_to_ptr</a>
      </li>
      <li><a href="#fn_pany_to_str">pany_to_str</a>
      </li>
      <li><a href="#fn_pany_to_ulong">pany_to_ulong</a>
      </li>
      <li><a href="#fn_pany_to_wcs">pany_to_wcs</a>
      </li>
      <li><a href="#fn_parray_count">parray_count</a>
      </li>
      <li><a href="#fn_parray_create">parray_create</a>
      </li>
      <li><a href="#fn_parray_erase">parray_erase</a>
      </li>
      <li><a href="#fn_parray_first">parray_first</a>
      </li>
      <li><a href="#fn_parray_free">parray_free</a>
      </li>
      <li><a href="#fn_parray_get">parray_get</a>
      </li>
      <li><a href="#fn_parray_init">parray_init</a>
      </li>
      <li><a href="#fn_parray_insert">parray_insert</a>
      </li>
      <li><a href="#fn_parray_iter">parray_iter</a>
      </li>
      <li><a href="#fn_parray_last">parray_last</a>
      </li>
      <li><a href="#fn_parray_malloc">parray_malloc</a>
      </li>
      <li><a href="#fn_parray_next">parray_next</a>
      </li>
      <li><a href="#fn_parray_offset">parray_offset</a>
      </li>
      <li><a href="#fn_parray_partof">parray_partof</a>
      </li>
      <li><a href="#fn_parray_pop">parray_pop</a>
      </li>
      <li><a href="#fn_parray_prev">parray_prev</a>
      </li>
      <li><a href="#fn_parray_push">parray_push</a>
      </li>
      <li><a href="#fn_parray_put">parray_put</a>
      </li>
      <li><a href="#fn_parray_remove">parray_remove</a>
      </li>
      <li><a href="#fn_parray_reserve">parray_reserve</a>
      </li>
      <li><a href="#fn_parray_rget">parray_rget</a>
      </li>
      <li><a href="#fn_parray_riter">parray_riter</a>
      </li>
      <li><a href="#fn_parray_rmalloc">parray_rmalloc</a>
      </li>
      <li><a href="#fn_parray_rput">parray_rput</a>
      </li>
      <li><a href="#fn_parray_shift">parray_shift</a>
      </li>
      <li><a href="#fn_parray_swap">parray_swap</a>
      </li>
      <li><a href="#fn_parray_unshift">parray_unshift</a>
      </li>
      <li><a href="#fn_pasprintf">pasprintf</a>
      </li>
      <li><a href="#fn_pbasename">pbasename</a>
      </li>
      <li><a href="#fn_pdbl_to_str">pdbl_to_str</a>
      </li>
      <li><a href="#fn_pdbl_to_wcs">pdbl_to_wcs</a>
      </li>
      <li><a href="#fn_pfileexists">pfileexists</a>
      </li>
      <li><a href="#fn_pfiletostr">pfiletostr</a>
      </li>
      <li><a href="#fn_pfree">pfree</a>
      </li>
      <li><a href="#fn_pgetopt">pgetopt</a>
      </li>
      <li><a href="#fn_plex_create">plex_create</a>
      </li>
      <li><a href="#fn_plex_define">plex_define</a>
      </li>
      <li><a href="#fn_plex_free">plex_free</a>
      </li>
      <li><a href="#fn_plex_lex">plex_lex</a>
      </li>
      <li><a href="#fn_plex_next">plex_next</a>
      </li>
      <li><a href="#fn_plex_prepare">plex_prepare</a>
      </li>
      <li><a href="#fn_plex_reset">plex_reset</a>
      </li>
      <li><a href="#fn_plex_tokenize">plex_tokenize</a>
      </li>
      <li><a href="#fn_plist_access">plist_access</a>
      </li>
      <li><a href="#fn_plist_clear">plist_clear</a>
      </li>
      <li><a href="#fn_plist_concat">plist_concat</a>
      </li>
      <li><a href="#fn_plist_count">plist_count</a>
      </li>
      <li><a href="#fn_plist_create">plist_create</a>
      </li>
      <li><a href="#fn_plist_diff">plist_diff</a>
      </li>
      <li><a href="#fn_plist_dup">plist_dup</a>
      </li>
      <li><a href="#fn_plist_erase">plist_erase</a>
      </li>
      <li><a href="#fn_plist_first">plist_first</a>
      </li>
      <li><a href="#fn_plist_free">plist_free</a>
      </li>
      <li><a href="#fn_plist_get">plist_get</a>
      </li>
      <li><a href="#fn_plist_get_by_key">plist_get_by_key</a>
      </li>
      <li><a href="#fn_plist_get_by_ptr">plist_get_by_ptr</a>
      </li>
      <li><a href="#fn_plist_hashnext">plist_hashnext</a>
      </li>
      <li><a href="#fn_plist_hashprev">plist_hashprev</a>
      </li>
      <li><a href="#fn_plist_init">plist_init</a>
      </li>
      <li><a href="#fn_plist_insert">plist_insert</a>
      </li>
      <li><a href="#fn_plist_iter">plist_iter</a>
      </li>
      <li><a href="#fn_plist_iter_access">plist_iter_access</a>
      </li>
      <li><a href="#fn_plist_key">plist_key</a>
      </li>
      <li><a href="#fn_plist_last">plist_last</a>
      </li>
      <li><a href="#fn_plist_malloc">plist_malloc</a>
      </li>
      <li><a href="#fn_plist_next">plist_next</a>
      </li>
      <li><a href="#fn_plist_offset">plist_offset</a>
      </li>
      <li><a href="#fn_plist_pop">plist_pop</a>
      </li>
      <li><a href="#fn_plist_prev">plist_prev</a>
      </li>
      <li><a href="#fn_plist_push">plist_push</a>
      </li>
      <li><a href="#fn_plist_remove">plist_remove</a>
      </li>
      <li><a href="#fn_plist_rget">plist_rget</a>
      </li>
      <li><a href="#fn_plist_riter">plist_riter</a>
      </li>
      <li><a href="#fn_plist_riter_access">plist_riter_access</a>
      </li>
      <li><a href="#fn_plist_rmalloc">plist_rmalloc</a>
      </li>
      <li><a href="#fn_plist_set_comparefn">plist_set_comparefn</a>
      </li>
      <li><a href="#fn_plist_set_printfn">plist_set_printfn</a>
      </li>
      <li><a href="#fn_plist_set_sortfn">plist_set_sortfn</a>
      </li>
      <li><a href="#fn_plist_shift">plist_shift</a>
      </li>
      <li><a href="#fn_plist_size">plist_size</a>
      </li>
      <li><a href="#fn_plist_sort">plist_sort</a>
      </li>
      <li><a href="#fn_plist_subsort">plist_subsort</a>
      </li>
      <li><a href="#fn_plist_swap">plist_swap</a>
      </li>
      <li><a href="#fn_plist_union">plist_union</a>
      </li>
      <li><a href="#fn_plist_unshift">plist_unshift</a>
      </li>
      <li><a href="#fn_pmalloc">pmalloc</a>
      </li>
      <li><a href="#fn_pmemdup">pmemdup</a>
      </li>
      <li><a href="#fn_pp_ast_dump">pp_ast_dump</a>
      </li>
      <li><a href="#fn_pp_ast_dump_json">pp_ast_dump_json</a>
      </li>
      <li><a href="#fn_pp_ast_dump_pvm">pp_ast_dump_pvm</a>
      </li>
      <li><a href="#fn_pp_ast_dump_short">pp_ast_dump_short</a>
      </li>
      <li><a href="#fn_pp_ast_dump_tree2svg">pp_ast_dump_tree2svg</a>
      </li>
      <li><a href="#fn_pp_ast_eval">pp_ast_eval</a>
      </li>
      <li><a href="#fn_pp_ast_free">pp_ast_free</a>
      </li>
      <li><a href="#fn_pp_ast_get">pp_ast_get</a>
      </li>
      <li><a href="#fn_pp_ast_len">pp_ast_len</a>
      </li>
      <li><a href="#fn_pp_ast_select">pp_ast_select</a>
      </li>
      <li><a href="#fn_pp_gram_create">pp_gram_create</a>
      </li>
      <li><a href="#fn_pp_gram_free">pp_gram_free</a>
      </li>
      <li><a href="#fn_pp_gram_from_bnf">pp_gram_from_bnf</a>
      </li>
      <li><a href="#fn_pp_gram_from_ebnf">pp_gram_from_ebnf</a>
      </li>
      <li><a href="#fn_pp_gram_from_pbnf">pp_gram_from_pbnf</a>
      </li>
      <li><a href="#fn_pp_gram_prepare">pp_gram_prepare</a>
      </li>
      <li><a href="#fn_pp_gram_to_str">pp_gram_to_str</a>
      </li>
      <li><a href="#fn_pp_lr_build">pp_lr_build</a>
      </li>
      <li><a href="#fn_pp_par_autolex">pp_par_autolex</a>
      </li>
      <li><a href="#fn_pp_par_create">pp_par_create</a>
      </li>
      <li><a href="#fn_pp_par_free">pp_par_free</a>
      </li>
      <li><a href="#fn_pp_par_lex">pp_par_lex</a>
      </li>
      <li><a href="#fn_pp_par_parse">pp_par_parse</a>
      </li>
      <li><a href="#fn_pp_prod_append">pp_prod_append</a>
      </li>
      <li><a href="#fn_pp_prod_create">pp_prod_create</a>
      </li>
      <li><a href="#fn_pp_prod_free">pp_prod_free</a>
      </li>
      <li><a href="#fn_pp_prod_get">pp_prod_get</a>
      </li>
      <li><a href="#fn_pp_prod_getfromrhs">pp_prod_getfromrhs</a>
      </li>
      <li><a href="#fn_pp_prod_remove">pp_prod_remove</a>
      </li>
      <li><a href="#fn_pp_prod_to_str">pp_prod_to_str</a>
      </li>
      <li><a href="#fn_pp_sym_create">pp_sym_create</a>
      </li>
      <li><a href="#fn_pp_sym_drop">pp_sym_drop</a>
      </li>
      <li><a href="#fn_pp_sym_free">pp_sym_free</a>
      </li>
      <li><a href="#fn_pp_sym_get">pp_sym_get</a>
      </li>
      <li><a href="#fn_pp_sym_get_by_name">pp_sym_get_by_name</a>
      </li>
      <li><a href="#fn_pp_sym_get_nameless_term_by_def">pp_sym_get_nameless_term_by_def</a>
      </li>
      <li><a href="#fn_pp_sym_getprod">pp_sym_getprod</a>
      </li>
      <li><a href="#fn_pp_sym_mod_kleene">pp_sym_mod_kleene</a>
      </li>
      <li><a href="#fn_pp_sym_mod_optional">pp_sym_mod_optional</a>
      </li>
      <li><a href="#fn_pp_sym_mod_positive">pp_sym_mod_positive</a>
      </li>
      <li><a href="#fn_pp_sym_to_str">pp_sym_to_str</a>
      </li>
      <li><a href="#fn_prealloc">prealloc</a>
      </li>
      <li><a href="#fn_pregex_create">pregex_create</a>
      </li>
      <li><a href="#fn_pregex_find">pregex_find</a>
      </li>
      <li><a href="#fn_pregex_findall">pregex_findall</a>
      </li>
      <li><a href="#fn_pregex_free">pregex_free</a>
      </li>
      <li><a href="#fn_pregex_match">pregex_match</a>
      </li>
      <li><a href="#fn_pregex_qmatch">pregex_qmatch</a>
      </li>
      <li><a href="#fn_pregex_qreplace">pregex_qreplace</a>
      </li>
      <li><a href="#fn_pregex_qsplit">pregex_qsplit</a>
      </li>
      <li><a href="#fn_pregex_replace">pregex_replace</a>
      </li>
      <li><a href="#fn_pregex_split">pregex_split</a>
      </li>
      <li><a href="#fn_pregex_splitall">pregex_splitall</a>
      </li>
      <li><a href="#fn_pstr_to_wcs">pstr_to_wcs</a>
      </li>
      <li><a href="#fn_pstrcasecmp">pstrcasecmp</a>
      </li>
      <li><a href="#fn_pstrcatchar">pstrcatchar</a>
      </li>
      <li><a href="#fn_pstrcatstr">pstrcatstr</a>
      </li>
      <li><a href="#fn_pstrdup">pstrdup</a>
      </li>
      <li><a href="#fn_pstrget">pstrget</a>
      </li>
      <li><a href="#fn_pstrlen">pstrlen</a>
      </li>
      <li><a href="#fn_pstrltrim">pstrltrim</a>
      </li>
      <li><a href="#fn_pstrlwr">pstrlwr</a>
      </li>
      <li><a href="#fn_pstrncasecmp">pstrncasecmp</a>
      </li>
      <li><a href="#fn_pstrncatstr">pstrncatstr</a>
      </li>
      <li><a href="#fn_pstrndup">pstrndup</a>
      </li>
      <li><a href="#fn_pstrput">pstrput</a>
      </li>
      <li><a href="#fn_pstrrender">pstrrender</a>
      </li>
      <li><a href="#fn_pstrreplace">pstrreplace</a>
      </li>
      <li><a href="#fn_pstrrtrim">pstrrtrim</a>
      </li>
      <li><a href="#fn_pstrsplit">pstrsplit</a>
      </li>
      <li><a href="#fn_pstrtrim">pstrtrim</a>
      </li>
      <li><a href="#fn_pstrunescape">pstrunescape</a>
      </li>
      <li><a href="#fn_pstrupr">pstrupr</a>
      </li>
      <li><a href="#fn_pvasprintf">pvasprintf</a>
      </li>
      <li><a href="#fn_pvm_create">pvm_create</a>
      </li>
      <li><a href="#fn_pvm_define">pvm_define</a>
      </li>
      <li><a href="#fn_pvm_free">pvm_free</a>
      </li>
      <li><a href="#fn_pvm_init">pvm_init</a>
      </li>
      <li><a href="#fn_pvm_prog_run">pvm_prog_run</a>
      </li>
      <li><a href="#fn_pvm_reset">pvm_reset</a>
      </li>
      <li><a href="#fn_pwcs_to_str">pwcs_to_str</a>
      </li>
      <li><a href="#fn_pwcscatchar">pwcscatchar</a>
      </li>
      <li><a href="#fn_pwcscatstr">pwcscatstr</a>
      </li>
      <li><a href="#fn_pwcsdup">pwcsdup</a>
      </li>
      <li><a href="#fn_pwcsget">pwcsget</a>
      </li>
      <li><a href="#fn_pwcslen">pwcslen</a>
      </li>
      <li><a href="#fn_pwcsncatstr">pwcsncatstr</a>
      </li>
      <li><a href="#fn_pwcsndup">pwcsndup</a>
      </li>
      <li><a href="#fn_pwcsput">pwcsput</a>
      </li>
      <li><a href="#fn_pwhich">pwhich</a>
      </li>
      <li><a href="#fn_u8_char">u8_char</a>
      </li>
      <li><a href="#fn_u8_isutf">u8_isutf</a>
      </li>
      <li><a href="#fn_u8_move">u8_move</a>
      </li>
      <li><a href="#fn_u8_parse_char">u8_parse_char</a>
      </li>
      <li><a href="#fn_u8_seqlen">u8_seqlen</a>
      </li>
      </ul>
    </li>
    </ul>
  </li>
  </ul>

</div>
<h1 id="toc2">Introduction</h1>

<p>
<b>phorward</b> is a versatile C-library. It is split into several modules, and mostly focuses on the definition and implementation of parsers, recognizers, virtual machines and regular expressions.
</p>

<ul>
<li><b>any</b> provides a dynamical, extendible data structure and interface to store, convert and handle variables of different value types ("variant" data type),
</li>
<li><b>base</b> provides tools for dynamic data structures and utility functions used throughout the library, including linked lists, hash-tables, stacks and arrays,
</li>
<li><b>parse</b> defines tools to express grammars and provides a built-in LALR(1) parser generator and objects to handle abstract syntax trees, integrating perfectly with the tools from *regex* for lexical analysis,
</li>
<li><b>regex</b> provides tools for lexical analysis and regular expression processing,
</li>
<li><b>string</b> is an extended string processing library,
</li>
<li><b>vm</b> can be used to implement and run stack-based virtual machines and instruction sets aimed to work with the *any* data type.
</li>
</ul>

<h1 id="toc3">Features</h1>

<p>
<i>phorward</i> provides the following features:
</p>

<ul>
<li>Parser development tools
  <ul>
  <li>Self-hosted Backus-Naur-Form (BNF) grammar definition language
  </li>
  <li><i>pparse</i> provides a modular LR(1) and LALR(1) parser generator
  </li>
  <li><i>ppast</i> is a representation of a browsable abstract syntax tree (AST)
  </li>
  </ul>
</li>
<li>Lexer development tools
  <ul>
  <li>regular expressions and pattern definition interface
  </li>
  <li><i>plex</i> provides a lexical analyzer
  </li>
  <li><i>pregex</i> for definition and execution of regular expression
  </li>
  <li><i>pccl</i> for unicode-enabled character classes
  </li>
  <li>tools for regex and lexer deployment
  </li>
  <li>string functions for regular expression match, split and replace
  </li>
  </ul>
</li>
<li>Runtime evaluation tools
  <ul>
  <li>construction of dynamic intermediate languages and interpreters
  </li>
  <li><i>pany</i> is a data object for handling different data-types in one object
  </li>
  <li><i>pvm</i> for defining stack-based virtual machine instruction sets
  </li>
  </ul>
</li>
<li>Dynamic data structures
  <ul>
  <li><i>plist</i> for linked-lists with build-in hash table support,
  </li>
  <li><i>parray</i> for arrays and stacks.
  </li>
  </ul>
</li>
<li>Extended string management functions
  <ul>
  <li>concat, extend, tokenize and short-hand allocation of strings and wide-character strings
  </li>
  <li>consistent byte- and wide-character (unicode) function support
  </li>
  <li>unicode support for UTF-8 in byte-character functions
  </li>
  </ul>
</li>
<li>Universal system-specific functions for platform-independent C software development
  <ul>
  <li>Unix-style command-line parser
  </li>
  <li>Mapping files to strings
  </li>
  </ul>
</li>
<li>Debug und trace facilities
</li>
<li>Consequent object-oriented build-up of all function interfaces (e.g. plist, parray, pregex, pparse, ...)
</li>
<li>Growing code-base of more and more powerful functions
</li>
</ul>

<p>
Please check out <a href="https://phorward.info/">https://phorward.info/</a> continuously to get the latest news, documentation, updates and support on the Phorward Toolkit.
</p>

<h1 id="toc4">Installation</h1>

<h2 id="toc5">Building from sources</h2>

<p>
Building the Phorward library is simple as every GNU-style open source program. Extract the release tarball or clone the Git repository into a directory of your choice.
</p>
<p>
Then, run
</p>

<pre><code class="language-c">
$ ./configure
</code></pre>

<p>
to configure the build-system and generate the Makefiles for your current platform. After successful configuration, run
</p>

<pre><code class="language-c">
$ make
</code></pre>

<p>
and
</p>

<pre><code class="language-c">
$ make install
</code></pre>

<p>
(properly as root), to install the toolkit into your system.
</p>

<h2 id="toc6">Building on Windows</h2>

<p>
On Windows systems, the usage of <a href="#vvvLINK1vvv">Cygwin</a> or another Unix shell environment is required. The Phorward Toolkit also perfectly cross-compiles on Linux using the MinGW and MinGW_x86-64 compilers.
</p>
<p>
To compile into 32-Bit Windows executables, configure with
</p>

<pre><code class="language-c">
$ ./configure --host=i486-mingw32 --prefix=/usr/i486-mingw32
</code></pre>

<p>
To compile into 64-Bit Windows executables, configure with
</p>

<pre><code class="language-c">
$ ./configure --host=x86_64-w64-mingw32 --prefix=/usr/x86_64-w64-mingw32
</code></pre>

<h2 id="toc7">Local development build</h2>

<p>
Alternatively to the autotools build system used for installation, there is also a simpler method on setting up a local build system for development and testing purposes.
</p>
<p>
Once, type
</p>

<pre><code class="language-c">
$ make -f Makefile.gnu make_install
</code></pre>

<p>
then, a simple run of
</p>

<pre><code class="language-c">
$ make
</code></pre>

<p>
can be used to simply build the entire library or parts of it.
</p>
<p>
Note, that changes to the build system then must be done in the local Makefile, the local Makefile.gnu as well as the Makefile.am for the autotools-based build system.
</p>

<h1 id="toc8">Intention behind this library</h1>

<p>
The cornerstone for this library was laid in 2006 during some experimenting with several algorithms and their implementation. It rapidly turned out to become a general purpose library serving as the base toolchain for several, mostly unfinished software projects which had their origin at <i>J.M.K S.F. Software Technologies</i>, which was later renamed to <i>Phorward Software Technologies</i>.
</p>
<p>
The library was then released to the public in 2011, together with the open source parser generator <a href="https://unicc.phorward-software.com/">UniCC</a>. Since then, it was gradually extended to newer and more enhanced features, mostly on tools relating to parser and compiler construction, but also features already known from other projects and remastered in a more generic and powerful way.
</p>
<p>
The final destination of the Phorward library is not entirely clear yet. For now, it mostly serves as a kind of playground for different projections, but it is also used by the UniCC parser generator and the meanwhile discontinued RapidBATCH scripting language as its foundation library.
</p>

<h1 id="toc9">Dynamic general-purpose objects</h1>

<h2 id="toc10">parray: Arrays and stacks</h2>

<h3 id="toc11">Overview</h3>

<p>
The <b>parray</b> object is a general-purpose data structure which can be used for several operations.
</p>
<p>
<b>parray</b> forms a data management container for handling homogenious elements of the same size in a dynamic way. These elements can be atomic data types, pointers or structures. Elements are automatically allocated with a specified chunk-size, and can be appended or prepended to the given <b>parray</b> object.
</p>
<p>
The <b>parray</b> object brings the following advantages and disadvantages:
</p>

<ul>
<li><u>Advantages</u>
  <ul>
  <li>Chunk allocation requires lesser <a href="#fn_pmalloc">pmalloc()</a>/<a href="#fn_prealloc">prealloc()</a> operations than with <b>plist</b>
  </li>
  <li>Dynamic and quick implementation for huger data structures
  </li>
  <li>Elements are hold in a real array on the heap
  </li>
  <li>Low memory consumption
  </li>
  <li>Fast iteration over elements
  </li>
  </ul>
</li>
<li><u>Disadvantages</u>
  <ul>
  <li>Not so flexible like <b>plist</b>
  </li>
  <li>No hashable entries
  </li>
  <li>Removing elements or rechaining requires more computing power
  </li>
  </ul>
</li>
</ul>

<h3 id="toc12">Construction and destruction</h3>

<p>
<b>parray</b> objects are created using <a href="#fn_parray_create">parray_create()</a> or initialized with <a href="#fn_parray_init">parray_init()</a>. The specific functions require the objects byte size that is required for every single element, and a chunk-size. Latter one can be omitted by specifing a chunk-size of 0, so that 128 elements per chunk will be the default. Objects can be cleared with <a href="#fn_parray_erase">parray_erase()</a>, respectively cleared and freed with <a href="#fn_parray_free">parray_free()</a>.
</p>

<pre><code class="language-c">
parray* a;

a = parray_create( sizeof( usertype ), 0 );

/* Do something... */

parray_free( a );
</code></pre>

<h3 id="toc13">Inserting elements</h3>

<p>
Elements can be inserted with
</p>

<ul>
<li><a href="#fn_parray_insert">parray_insert()</a> - insert element at any desired offset,
</li>
<li><a href="#fn_parray_push">parray_push()</a> - push element to end of array,
</li>
<li><a href="#fn_parray_shift">parray_shift()</a> - shift element on begin of array,
</li>
<li><a href="#fn_parray_malloc">parray_malloc()</a> - zero-initialize new element at end of array, and
</li>
<li><a href="#fn_parray_rmalloc">parray_rmalloc()</a> - zero-initialize new element at begin of array.
</li>
</ul>

<pre><code class="language-c">
parray* a;
usertype t;
usertype* tp;

fill_usertype( &amp;t );
parray_insert( a, 2, &amp;t );

fill_usertype( &amp;t );
parray_push( a, &amp;t );
parray_shift( a, &amp;t );

tp = (usertype*)parray_malloc( a );
fill_usertype( tp );
tp = (usertype*)parray_rmalloc( a );
fill_usertype( tp );
</code></pre>

<h3 id="toc14">Accessing and iterating elements</h3>

<p>
Direct access to specific elements is done using
</p>

<ul>
<li><a href="#fn_parray_get">parray_get()</a> - get element by offset from begin, and
</li>
<li><a href="#fn_parray_rget">parray_rget()</a> - get element by offset from end.
</li>
<li><a href="#fn_parray_for">parray_for()</a> - Expands into a for-loop iterating over elements.
</li>
<li><a href="#fn_parray_iter">parray_iter()</a> - Iterate over all elements and call a function on each element.
</li>
<li><a href="#fn_parray_riter">parray_riter()</a> - Like <a href="#fn_parray_iter">parray_iter()</a>, but backwards.
</li>
</ul>

<p>
Iterating over the elements:
</p>

<pre><code class="language-c">
parray* a;
usertype* tp;

/* Using a pointer ---------------------------------------------------------- */

for( tp = parray_first( a ); tp; tp = parray_next( a, tp ) )
	;

/* Shortcut */
parray_for( a, tp )
	;

/* Using a callback function ------------------------------------------------ */

void tp_callback( usertype* tp )
{
	/* ... */
}

parray_iter( a, (parrayfn)tp_callback ); /* Forwards... */
parray_riter( a, (parrayfn)tp_callback ); /* Backwards... */

/* Using a counter ---------------------------------------------------------- */
int i;

/* Iterate from first to last. */
for( i = 0; ( tp = (usertype*)parray_get( a, i ) ); i++ )
	;

/* Iterate from last to first. */
for( i = 0; ( tp = (usertype*)parray_rget( a, i ) ); i++ )
	;
</code></pre>

<p>
Quick access to the first or last elements is gained by <a href="#fn_parray_last">parray_last()</a> and <a href="#fn_parray_first">parray_first()</a>.
</p>
<p>
To get a predecessor or successor of an element, use <a href="#fn_parray_prev">parray_prev()</a> respectively <a href="#fn_parray_next">parray_next()</a>.
</p>
<p>
Elements can be replaced by <a href="#fn_parray_put">parray_put()</a> and <a href="#fn_parray_rput">parray_rput()</a> via their index.
</p>

<h3 id="toc15">Removing elements</h3>

<p>
Elements can be removed with
</p>

<ul>
<li><a href="#fn_parray_remove">parray_remove()</a> - remove element at any desired offset,
</li>
<li><a href="#fn_parray_pop">parray_pop()</a> - remove last element like from a stack, and
</li>
<li><a href="#fn_parray_unshift">parray_unshift()</a> - remove first element.
</li>
</ul>

<pre><code class="language-c">
parray* a;
usertype t;
usertype* tp;

parray_remove( a, 2, &amp;t );
tp = (usertype*)parray_pop( a );
tp = (usertype*)parray_unshift( a );
</code></pre>

<h3 id="toc16">Additional functions</h3>

<p>
Other, useful functions are
</p>

<ul>
<li><a href="#fn_parray_count">parray_count()</a> - get number of elements within object,
</li>
<li><a href="#fn_parray_offset">parray_offset()</a> - get offset of element by pointer,
</li>
<li><a href="#fn_parray_partof">parray_partof()</a> - check if element is part of object,
</li>
<li><a href="#fn_parray_swap">parray_swap()</a> - swap two elements within an object,
</li>
<li><a href="#fn_parray_reserve">parray_reserve()</a> - assume memory pre-allocation; This is interesting for stack operations.
</li>
</ul>

<h2 id="toc17">plist: Linked lists, hash-tables, queues and stacks</h2>

<h3 id="toc18">Overview</h3>

<p>
Next to the <b>parray</b> object, the <b>plist</b> object is a powerful C implementation of a double-linked list with some extra features. It is also used for handling homogenious elements of the same size in a dynamic way, and can be used for many tasks.
</p>
<p>
<b>plist</b> can be seen as a superset of the <b>parray</b> object, because it features nearly the same operations but with other underlying data management methods.
</p>
<p>
The <b>plist</b> object implements:
</p>

<ul>
<li>a double linked-list
</li>
<li>hashable entries (hash table, including same element key stacking)
</li>
<li>dynamic stack functionalities
</li>
<li>data object collections
</li>
<li>set functions
</li>
</ul>

<p>
<b>plist</b> can be used as a generic data structure for
</p>

<ul>
<li>hash tables
</li>
<li>queues
</li>
<li>arrays
</li>
<li>stacks
</li>
</ul>

<p>
The <b>plist</b> object brings the following advantages and disadvantages:
</p>

<ul>
<li><u>Advantages</u>
  <ul>
  <li>Allows pointer-mode and entity-mode configuration (PLIST_MOD_PTR)
  </li>
  <li>Additionally find objects using a hash-table
  </li>
  <li>Provides element recycling methods (PLIST_MOD_RECYCLE)
  </li>
  <li>Elements are chained and can be re-arraged
  </li>
  <li>Automatical sorting using individual sort-functions
  </li>
  <li>Simple set-theory functions (union, diff)
  </li>
  </ul>
</li>
<li><u>Disadvantages</u>
  <ul>
  <li>High memory consumption, especially in case when used with hash-tables
  </li>
  <li>Iteration over elements is much slower
  </li>
  <li>List elements are chained as <b>plistel</b> data structures, while the data members must be called separately
  </li>
  <li>All operations require more computing power in comparison to <b>parray</b>
  </li>
  </ul>
</li>
</ul>

<h3 id="toc19">Construction and destruction</h3>

<p>
<b>plist</b> objects are created using <a href="#fn_plist_create">plist_create()</a> or initialized with <a href="#fn_plist_init">plist_init()</a>. The specific functions require the objects byte size that is required for every single element, and a flag configuration, that configures the <b>plist</b> object to a specified behavior.
</p>
<p>
Possible flags are listed below, and can be combined using bitwise or (|).
</p>

<ul>
<li><b>PLIST_MOD_NONE</b> no flags, this can also be just 0.
</li>
<li><b>PLIST_MOD_PTR</b> to use the plist-object in pointer-mode: Each element contains only a pointer to an object in the memory and returns this, instead of copying from or into pointers.
</li>
<li><b>PLIST_MOD_RECYCLE</b> to configure that elements that are removed during list usage will be reused later, which reduces dynamic memory consumption.
</li>
<li><b>PLIST_MOD_AUTOSORT</b> to automatically sort the list on insert operations.
</li>
<li><b>PLIST_MOD_EXTKEYS</b> to configure that string pointers to hash-table key values are stored elsewhere, so the plist-module only uses the original pointers instead of copying them.
</li>
<li><b>PLIST_MOD_PTRKEYS</b> disables string keys and uses the pointer/value provided as key directly.
</li>
<li><b>PLIST_MOD_UNIQUE</b> to disallow hash-table-key collisions, so elements with a key that already exist in the object will be rejected.
</li>
<li><b>PLIST_MOD_WCHAR</b> to let all key values handle as wide-character strings.
</li>
</ul>

<p>
The mode <b>PLIST_MOD_PTR</b> is automatically set if the elements size is specified as 0.
</p>
<p>
A <b>plist</b> object must be freed using <a href="#fn_plist_free">plist_free()</a> or cleared with <a href="#fn_plist_clear">plist_clear()</a>.
</p>

<pre><code class="language-c">
plist* l;

l = plist_create( sizeof( usertype ), PLIST_MOD_RECYCLE );

/* Do something... */

plist_free( l );
</code></pre>

<h3 id="toc20">Inserting elements</h3>

<p>
Elements can be inserted with
</p>

<ul>
<li><a href="#fn_plist_insert">plist_insert()</a> - insert element, optionally with key, at any desired position,
</li>
<li><a href="#fn_plist_push">plist_push()</a> - push element to end of list,
</li>
<li><a href="#fn_plist_shift">plist_shift()</a> - shift element on begin of list,
</li>
<li><a href="#fn_plist_malloc">plist_malloc()</a> - zero-initialize new element at end of list, and
</li>
<li><a href="#fn_plist_rmalloc">plist_rmalloc()</a> - zero-initialize new element at begin of list.
</li>
</ul>

<pre><code class="language-c">
plist* l;
usertype t;
usertype* tp;

/* Insert to position */
fill_usertype( &amp;t );
plist_insert( l, plist_get( l, 2 ), (char*)NULL, &amp;t );

/* Insert to end, with key value */
plist_insert( l, (plistel*)NULL, "hello", &amp;t );

/* Insert and end and begin */
fill_usertype( &amp;t );
plist_push( a, &amp;t );
plist_shift( a, &amp;t );

/* Retrieve fresh element memory at end and begin */
tp = (usertype*)plist_malloc( a );
fill_usertype( tp );
tp = (usertype*)plist_rmalloc( a );
fill_usertype( tp );
</code></pre>

<h3 id="toc21">Accessing and iterating elements</h3>

<p>
Elements within a <b>plist</b> object are references by <b>plistel</b> items. To access the data element behind a <b>plistel</b> item, the function <a href="#fn_plist_access">plist_access()</a> is used, in combination with element retrival functions, like
</p>

<ul>
<li><a href="#fn_plist_get">plist_get()</a> - get element by offset,
</li>
<li><a href="#fn_plist_rget">plist_rget()</a> - get element by offset from the end,
</li>
<li><a href="#fn_plist_first">plist_first()</a> - get first element,
</li>
<li><a href="#fn_plist_last">plist_last()</a> - get last element,
</li>
<li><a href="#fn_plist_get_by_key">plist_get_by_key()</a> - retrieve element by key (in a hash table),
</li>
<li><a href="#fn_plist_get_by_ptr">plist_get_by_ptr()</a> - retrieve element by its data pointer.
</li>
<li><a href="#fn_plist_for">plist_for()</a> - Expands into a for-loop iterating over elements.
</li>
<li><a href="#fn_plist_iter">plist_iter()</a> - Iterate over all elements and call a function on each element.
</li>
<li><a href="#fn_plist_riter">plist_riter()</a> - Like <a href="#fn_plist_iter">plist_iter()</a>, but backwards.
</li>
</ul>

<pre><code class="language-c">
plist* l;
plistel* e;
usertype* tp;
int i;

/* Get 6th data element */
tp = (usertype*)plist_access( plist_get( l, 5 ) );

/* Get data element with key "hello" */
tp = (usertype*)plist_access( plist_get_by_key( l, "hello" ) );

/* Iterate from begin to end */
for( e = plist_first( l ); e; e = plist_next( e ) )
	tp = (usertype*)plist_access( e );

/* Alternative: Using the plist_for()-macro */
plist_for( l, e )
	tp = (usertype*)plist_access( e );

/* Alternative: Using offset */
for( i = 0; ( tp = (usertype*)plist_access( plist_get( l, i ) ) ); i++ )
	;

/* Reversely iterate from end to begin */
for( e = plist_last( l ); e; e = plist_prev( e ) )
	tp = (usertype*)plist_access( e );

/* Reverse alternative: Using offset */
for( i = 0; ( tp = (usertype*)plist_access( plist_rget( l, i ) ) ); i++ )
	;
</code></pre>

<h3 id="toc22">Removing elements</h3>

<p>
To remove elements from a <b>plist</b> object, the following functions can be used.
</p>

<ul>
<li><a href="#fn_plist_remove">plist_remove()</a> - remove any element,
</li>
<li><a href="#fn_plist_pop">plist_pop()</a> - pop last element as from a stack,
</li>
<li><a href="#fn_plist_unshift">plist_unshift()</a> - remove first element as from a queue.
</li>
</ul>

<pre><code class="language-c">
plist* l;
usertype t;

plist_remove( l, plist_get( l, 7 ) );
plist_pop( a, &amp;t );
plist_unshift( a, &amp;t );
</code></pre>

<h3 id="toc23">Sorting elements</h3>

<p>
<b>plist</b> objects provide a sorting automatism, so that elements can be sorted on demand or on the fly at each element insertation.
</p>
<p>
The sorting order and rule is defined using an element comparison callback-function, which returns element lower, greater or equality like strcmp() does.
This function can be individually set using <a href="#fn_plist_set_sortfn">plist_set_sortfn()</a>, and defaultly points to a callback function that uses memcmp() as the element comparison function.
</p>
<p>
As prototype and example, the following comparison function:
</p>

<pre><code class="language-c">
int my_compare( plist* list, plistel* l, plistel* r )
{
	usertype*	tr;
	usertype*	tl;

	tl = (usertype*)plist_access( l );
	tr = (usertype*)plist_access( r );

	if( tl &lt; tr )
		return -1;
	else if( tl &gt; tr )
		return 1;

	return 0;
}
</code></pre>

<p>
This can, than, be attached to the <b>plist</b> object with
</p>

<pre><code class="language-c">
plist_set_sortfn( l, my_compare );
</code></pre>

<p>
To configure a <b>plist</b> object to be auto-sorted, the flag PLIST_MOD_AUTOSORT should be used at construction.
The sorting can be also be performed by invoking the functions
</p>

<ul>
<li><a href="#fn_plist_sort">plist_sort()</a> - to sort the entire list,
</li>
<li><a href="#fn_plist_subsort">plist_subsort()</a> - to sort only a part of the list (begin- and end-elements required).
</li>
</ul>

<h3 id="toc24">Interchanging functions</h3>

<p>
<b>plist</b> objects also provide functions to handle data collections and sets, by providing functions that can deal with two objects of kind <b>plist</b>. Both lists must be configured with the same element memory size, else all functions will fail.
</p>
<p>
To implement these functions, every <b>plist</b> object also refers to a comparison-callback function. This is, by default, the same function as used for the sorting, and has also the same signature. This function can be implemented to check for element equality within set handling functions.
</p>

<ul>
<li><a href="#fn_plist_diff">plist_diff()</a> - checks two lists for same items (equality),
</li>
<li><a href="#fn_plist_union">plist_union()</a> - extends a list to all elements of a second list that are not equal to elements in the first list.
</li>
</ul>

<h3 id="toc25">Additional functions</h3>

<p>
<b>plist</b> provides these additional functions:
</p>

<ul>
<li><a href="#fn_plist_swap">plist_swap()</a> - swaps the two elements within a list,
</li>
<li><a href="#fn_plist_dup">plist_dup()</a> - duplicate list and its items,
</li>
<li><a href="#fn_plist_count">plist_count()</a> - return number of items in a list.
</li>
</ul>

<h2 id="toc26">pccl: Character-classes</h2>

<p>
The <b>pccl</b> object is established on top of the <b>plist</b> object and encapsulates easy-to-handle low-level functions for character-class handling.
</p>
<p>
These functions are heavily used by the library's regular expressions and parser implementations, but may also be helpful for other related projects. The <b>pccl</b> can handle character classes, by chaining ranges.
</p>
<p>
It supports a fully-fledged set theory automatism, including construction of intersections, unions, range removal or appending. <b>pccl</b> objects are designed to work on huge alphabets with a low memory consumption. By default, characters are specified as <b>wchar_t</b> (wide-character unicode) values.
</p>

<ul>
<li><a href="#fn_p_ccl_create">p_ccl_create()</a> - create and optionally parse a new character-class,
</li>
<li><a href="#fn_p_ccl_parse">p_ccl_parse()</a> - parse characters and ranges from a string into a character-class,
</li>
<li><a href="#fn_p_ccl_negate">p_ccl_negate()</a> - negate a character-class over the character universe,
</li>
<li><a href="#fn_p_ccl_add">p_ccl_add()</a>, <a href="#fn_p_ccl_addrange">p_ccl_addrange()</a> - add single characters or ranges to the class,
</li>
<li><a href="#fn_p_ccl_del">p_ccl_del()</a>, <a href="#fn_p_ccl_delrange">p_ccl_delrange()</a> - delete single characters or ranges from the class,
</li>
<li><a href="#fn_p_ccl_test">p_ccl_test()</a>, <a href="#fn_p_ccl_tesrange">p_ccl_tesrange()</a> - test if a character or range matches a class,
</li>
<li><a href="#fn_p_ccl_to_str">p_ccl_to_str()</a> - convert a character-class into a string,
</li>
<li><a href="#fn_p_ccl_free">p_ccl_free()</a> - detroy a previously created character-class,
</li>
</ul>

<pre><code class="language-c">
pccl* ccl;

/* Construct a character-class within a universe of the ASCII-alphabet (0-255):
	"-0123456789ABCDEFGHIJKLMNOQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
*/
ccl = p_ccl_create( 0, 255, "A-Za-z0-9_-" );

/* Invert character class */
p_ccl_negate( ccl );

/* Remove system chars */
p_ccl_delrange( ccl, 0, 31 );

/* Oh, and delete the "z" */
p_ccl_del( ccl, 'z' );

/* But add tab again! */
p_ccl_add( ccl, '\t' );

/* Enable all from 32 to 126  */
p_ccl_addrange( ccl, ' ', '~' );

/* Alternative way: */
p_ccl_parse( ccl, " -~", TRUE );

/* Test for characters */
printf( "A is in? %s\n", BOOLEAN_STR( p_ccl_test( ccl, 'A' ) );
printf( "a-z are in? %s\n", BOOLEAN_STR( p_ccl_testrange( ccl, 'a', 'z' ) );
printf( "\\n is in? %s\n", BOOLEAN_STR( p_ccl_test( ccl, '\n' ) );

/* Generate string */
printf( "My ccl is: %s\n", p_ccl_to_str( ccl, TRUE ) );

/* Drop it! */
p_ccl_free( ccl );
</code></pre>

<p>
Useful, additional functions when working with <b>pccl</b> are:
</p>

<ul>
<li><a href="#fn_p_ccl_compare">p_ccl_compare()</a> - compare character-classes,
</li>
<li><a href="#fn_p_ccl_diff">p_ccl_diff()</a> - create differencing character-class of two classes,
</li>
<li><a href="#fn_p_ccl_erase">p_ccl_erase()</a> - clear character-class,
</li>
<li><a href="#fn_p_ccl_get">p_ccl_get()</a> - retrieve characters or ranges by offset,
</li>
<li><a href="#fn_p_ccl_instest">p_ccl_instest()</a> - like <a href="#fn_p_ccl_test">p_ccl_test()</a>, but with insensitve-character check,
</li>
<li><a href="#fn_p_ccl_intersect">p_ccl_intersect()</a> - create intersection character-class of two classes,
</li>
<li><a href="#fn_p_ccl_print">p_ccl_print()</a> - print character-class (for debug),
</li>
<li><a href="#fn_p_ccl_parsechar">p_ccl_parsechar()</a> - parse an escaped character sequence into a wide-character,
</li>
<li><a href="#fn_p_ccl_parseshorthand">p_ccl_parseshorthand()</a> - parse a typical shorthand (\d, \w) into a character-class.
</li>
</ul>

<h1 id="toc27">pregex, plex: Regular expression handling and lexical analyzers</h1>

<h2 id="toc28">Overview</h2>

<p>
libphorward provides a powerful set of functions relating to general string pattern matching and lexical analysis using regular expressions.
</p>

<ul>
<li>The <b>pregex</b> object encapsulates several regular expression patterns into one data structure that is compiled into a reusable DFA (deterministic finite automata) for quick pattern processing. Strings can be matched, split or replaced on patterns.
  <ul>
  <li>Based on the <b>pregex</b> object, the functions <a href="#fn_pregex_qmatch">pregex_qmatch()</a>, <a href="#fn_pregex_qsplit">pregex_qsplit()</a> and <a href="#fn_pregex_qreplace">pregex_qreplace()</a> are provided, for one-line string processing.
  </li>
  </ul>
</li>
<li>The <b>plex</b> object ecapsulates a regular expression-based scanner for lexical analysis into one object. It is used by libphorward's <a href="#pparse">build-in parser generator</a> for lexical analysis also.
</li>
<li>All functions are designed to work on wide-character alphabets to fully support Unicode. Therefore, the flags PREGEX_COMP_WCHAR and PREGEX_RUN_WCHAR are provided, to allow processing on patterns and input strings provided as wide-character strings. If not explicitly deactivated by build-flags (-DUTF8), UTF-8 input is generally supported on all functions.
</li>
<li>Supports anchoring and back-references.
</li>
<li>Patterns are internally encapsulated in structures of <i>pregex_ptn</i> objects, which are then used to generate the NFA (nondeterministic finite automata) from which a DFA is constructed (subset construction algorithm).
</li>
<li>Matches are described in a structure called <i>prange</i>.
</li>
<li>DFAs can be deployed in form of a two dimensional array containing all information that is required to run the regex without the slower, object-oriented data structure layers.
</li>
</ul>

<h3 id="toc29">Meta constructs</h3>

<p>
In general, regular expressions are made-up of the following elements:
</p>

<table border="1">
<tr>
<th>Construct</th>
<th>Usage</th>
</tr>
<tr>
<td><code>[...]</code> or <code>[^...]</code></td>
<td>Specifies a character, character-class or negated character-class (^).</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Specifies a character-class standing for "any character". Using this construct causes the terminal to be configured as "non-greedy".</td>
</tr>
<tr>
<td><code>(</code> and <code>)</code></td>
<td>Parantheses to build sub-expressions.</td>
</tr>
<tr>
<td><code>|</code></td>
<td>The alternative operator to define multiple expressions at one expression level.</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Kleene closure (none or several of previous expression) modifier.</td>
</tr>
<tr>
<td><code>+</code></td>
<td>Positive closure (one or several of previous expression) modifier.</td>
</tr>
<tr>
<td><code>?</code></td>
<td>Optional closure (none or one of previous expression) modifier.</td>
</tr>
</table>

<p>
All meta-characters can be escaped by backslash, so they are interpretered as usual characters.
</p>

<h3 id="toc30">Characters and escape sequences</h3>

<p>
Any other character coming up is consumed as one expression to be matched in the input.
By default, all strings are interpretered in UTF-8 encoded unicode style, so unicode is fully supported.
</p>
<p>
Escape sequences (C-style) are supported according to the following table:
</p>

<table border="1">
<tr>
<th>Escape sequence</th>
<th>Description</th>
</tr>
<tr>
<td><code>\a</code></td>
<td>Bell (alert)</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Backspace</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>Formfeed</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>New line</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Horizontal tab</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>Vertical tab</td>
</tr>
<tr>
<td><code>\'</code></td>
<td>Single quotation mark</td>
</tr>
<tr>
<td><code>\"</code></td>
<td>Double quotation mark</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>Backslash</td>
</tr>
<tr>
<td><code>\OOO</code></td>
<td>ASCII character in octal notation, (O = octal digit)</td>
</tr>
<tr>
<td><code>\xHH</code></td>
<td>ASCII character in hexadecimal notation (H = hexadecimal digit)</td>
</tr>
<tr>
<td><code>\uHHHH</code></td>
<td>32-Bit Unicode character in hexadecimal notation (H = hexadecimal digit)</td>
</tr>
<tr>
<td><code>\UHHHHHHHH</code></td>
<td>64-Bit Unicode character in hexadecimal notation (H = hexadecimal digit)</td>
</tr>
</table>

<p>
<u><b>Note:</b> When specifying escape-sequences in static strings within C-code, they must be double-escaped, because they are first analyzed by the C compiler and then by libphorward's regex-parser. Therefore, specifiying a backslash <code>\\</code> must become <code>\\\\</code> in the C-Code, which then yields in <code>\\</code> after compiling the C program.</u>
</p>

<h3 id="toc31">Shorthand character classes</h3>

<p>
Pre-defined shorthand character-classes are also supported by libphorward's pregex and plex tools.
</p>

<table border="1">
<tr>
<th>Shorthand</th>
<th>Complains with</th>
<th>Explanation</th>
</tr>
<tr>
<td>\w</td>
<td>[A-Za-z0-9_]</td>
<td>All alphanumeric characters (ASCII only)</td>
</tr>
<tr>
<td>\W</td>
<td>[^A-Za-z0-9_]</td>
<td>Any other than (ASCII only) alphanumeric characters</td>
</tr>
<tr>
<td>\d</td>
<td>[0-9]</td>
<td>All digit characters (ASCII-only)</td>
</tr>
<tr>
<td>\D</td>
<td>[^0-9]</td>
<td>Any other than (ASCII only) digit characters</td>
</tr>
<tr>
<td>\s</td>
<td>[ \f\n\r\t\v]</td>
<td>All whitespace characters (ASCII-only)</td>
</tr>
<tr>
<td>\S</td>
<td>[^ \f\n\r\t\v]</td>
<td>Any other than (ASCII only) whitespace characters</td>
</tr>
</table>

<h3 id="toc32">Anchoring</h3>

<p>
The following anchors are supported, when specified at beginning or ending of an expression:
</p>

<table border="1">
<tr>
<th>Anchor</th>
<th>Usage</th>
</tr>
<tr>
<td><code>^</code></td>
<td>Anchor at begin of pattern, matching begin-of-line.</td>
</tr>
<tr>
<td><code>$</code></td>
<td>Anchor at end of pattern, matching end-of-line.</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Anchor at begin of pattern, matching begin-of-word.</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Anchor at end of pattern, matching end-of-word.</td>
</tr>
</table>

<p>
Anchors can be entirely switched off when setting the PREGEX_COMP_NOANCHORS on compile-time, respectively PREGEX_RUN_NOANCHORS on run-time.
</p>

<h3 id="toc33">Examples</h3>

<p>
Some examples:
</p>

<ul>
<li><code>Hello World</code> matches "Hello World",
</li>
<li><code>Hello? World</code> matches "Hello World" and "Hell World",
</li>
<li><code>Hello+ World</code> matches "Hello World" or "Hellooooooooo World",
</li>
<li><code>Hello* World</code> matches "Hello World", "Hellooooooooo World" or even "Hell World",
</li>
<li><code>(Hello)? World</code> matches "Hello World" and " World",
</li>
<li><code>(Hello)+ World</code> matches "Hello World" and "HelloHelloHello World",
</li>
<li><code>(Hello)* World</code> matches "Hello World", "HelloHelloHello World" or even " World",
</li>
<li><code>[any]+ World</code> matches "any World", "n World, "nyan World" or "nayayayaaa World",
</li>
<li><code>[^none]* World</code> matches "yuluthisisfun World", "xyz World" and " World",
</li>
<li><code>'([^']|\\')*'</code> matches "''", "'Hello World'" or even "'What\'s Up?'",
</li>
<li><code>Hello|World</code> matches "Hello" or "World",
</li>
<li><code>Hello (World|Universe)</code> matches both "Hello World" or "Hello Universe".
</li>
</ul>

<p>
(TODO: more examples)
</p>

<h2 id="toc34">pregex: Operating on regular expressions</h2>

<p>
The <b>pregex</b> object is the object-oriented interface for string operations based on regular expressions.
</p>
<p>
Patterns are compiled into a DFA and associated with the <b>pregex</b> object as a reusable state machine that can be executed several times.
</p>
<p>
Generally, the actions
</p>

<ul>
<li>matching
</li>
<li>finding
</li>
<li>splitting
</li>
<li>replacing
</li>
</ul>

<p>
are supported by the compiled pattern.
</p>

<h3 id="toc35">Construction and destruction</h3>

<p>
<b>pregex</b> objects are constructed by <a href="#fn_pregex_create">pregex_create()</a>. First parameter is the regular expression pattern string that is compiled into a DFA. The second parameter allows to specify several flags for influencing the compile- and execution process. All flags can be combined using the bitwise or-operator (|).
</p>

<table border="1">
<tr>
<th>Flag</th>
<th>Usage</th>
</tr>
<tr>
<td>PREGEX_COMP_WCHAR</td>
<td>The regular expression provided to pregex_create() shall be casted to wchar_t.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOANCHORS</td>
<td>Ignore anchor tokens, handle them as normal characters</td>
</tr>
<tr>
<td>PREGEX_COMP_NOREF</td>
<td>Don't compile references.</td>
</tr>
<tr>
<td>PREGEX_COMP_NONGREEDY</td>
<td>Compile regex to be forced nongreedy.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOERRORS</td>
<td>Don't report errors, and try to compile as much as possible</td>
</tr>
<tr>
<td>PREGEX_COMP_INSENSITIVE</td>
<td>Parse regular expression as case insensitive.</td>
</tr>
<tr>
<td>PREGEX_COMP_STATIC</td>
<td>The regular expression passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped.</td>
</tr>
<tr>
<td>PREGEX_RUN_WCHAR</td>
<td>Run regular expression with wchar_t as input.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOANCHORS</td>
<td>Ignore anchors while processing the regex.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOREF</td>
<td>Don't create references.</td>
</tr>
<tr>
<td>PREGEX_RUN_NONGREEDY</td>
<td>Force run regular expression nongreedy.</td>
</tr>
<tr>
<td>PREGEX_RUN_DEBUG</td>
<td>Debug mode; output some debug to stderr.</td>
</tr>
</table>

<p>
<a href="#fn_pregex_free">pregex_free()</a> destructs and releases a <b>pregex</b> object after its use.
</p>

<pre><code class="language-c">
pregex* r;

r = pregex_create( "[_A-Za-z]+", 0 );

/* do something with r */

pregex_free( r );
</code></pre>

<h3 id="toc36">Matching</h3>

<p>
To immediatelly test if a <b>pregex</b>-object matches on a string, the function <a href="#fn_pregex_match">pregex_match()</a> shall be invoked.
</p>

<pre><code class="language-c">
pregex* r;
char* s = "a1337b";
char* e;

r = pregex_create( "[0-9]+", 0 );
pregex_match( r, s, &amp;e ); /* returns FALSE */
pregex_match( r, s + 1, &amp;e ); /* returns TRUE, e receives s+5. */
</code></pre>

<p>
<a href="#fn_pregex_match">pregex_match()</a> only tests for a string that immediatelly matches the pattern. To find a matching pattern within a string, the function <a href="#fn_pregex_find">pregex_find()</a> shall be invoked, which is called with the same parameters, but returns the position of the match instead of a bool state.
</p>

<pre><code class="language-c">
pregex_find( r, s, &amp;e ); /* returns s + 1, e receives s+5. */
</code></pre>

<p>
To find all matching patterns, <a href="#fn_pregex_find">pregex_find()</a> must be called in a loop.
</p>

<pre><code class="language-c">
while( ( s = pregex_find( r, s, &amp;e ) ) )
{
	printf( "&gt;%.*s&lt;\n", e - s, s );
	s = e;
}
</code></pre>

<p>
The function <a href="#fn_pregex_findall">pregex_findall()</a> can do this with one call, and fills an <i>parray</i> object with <i>prange</i> structures.
</p>

<pre><code class="language-c">
parray* a;
prange* rg;

pregex_findall( r, s, &amp;a );

while( ( rg = (prange*)parray_shift( a ) ) )
	printf( "&gt;%.*s&lt;\n", rg-&gt;end - rg-&gt;begin, rg-&gt;begin );

parray_free( a );
</code></pre>

<h3 id="toc37">Splitting</h3>

<p>
Splitting a string by a regular expression can be done with <a href="#fn_pregex_split">pregex_split()</a>. This function takes several parameters, and is designed to be called in a loop.
</p>

<pre><code class="language-c">
pregex* r;
char* s = "5 and 6 are the cross sums of 23 and 42.";
char* e;
char* n;

r = pregex_create( "[0-9]+", 0 );

while( s )
{
	if( ( s = pregex_split( r, s, &amp;e, &amp;n ) ) )
			printf( "&gt;%.*s&lt;\n", e - s, s );

	s = n;
}
</code></pre>

<p>
There is also an one call shortcut <a href="#fn_pregex_splitall">pregex_splitall()</a>, filling an array:
</p>

<pre><code class="language-c">
parray* a;
prange* rg;

pregex_splitall( r, s, &amp;a );

while( ( rg = (prange*)parray_shift( a ) ) )
	printf( "&gt;%.*s&lt;\n", rg-&gt;end - rg-&gt;begin, rg-&gt;begin );

parray_free( a );
</code></pre>

<h3 id="toc38">Replacing</h3>

<p>
The function <a href="#fn_pregex_replace">pregex_replace()</a> allows for replacing parts of strings by regular expressions.
</p>

<pre><code class="language-c">
char* ns;

ns = pregex_replace( r, s, "int" );
</code></pre>

<p>
The result of this function is always an dynamically allocated string that contains the replaces version of the input string, even if there hadn't been any matches. The above example will return "int and int are the cross sums of int and int." when executed on the string of previous chapter. The returned string must always be released with <a href="#fn_pfree">pfree()</a> after its use.
</p>
<p>
The replacement may also allow backreference-placeholders defined as <code>$&lt;backreference&gt;</code>, to take parts of the matched regular expression into the replaces string. A back-reference is created for every opening that exists in the regular expression, and begins counting at 1.
</p>
<p>
This modified version
</p>

<pre><code class="language-c">
r = pregex_create( "([0-9]+)", 0 );
ns = pregex_replace( r, s, "int[$1]" );
</code></pre>

<p>
will return "int[5] and int[6] are the cross sums of int[23] and int[42]." when executed on the example string.
</p>
<p>
To disable the backreference replacement features, the regular expression flag PREGEX_RUN_NOREF must be switched.
</p>

<h3 id="toc39">Quick-access functions</h3>

<p>
Based on the <b>pregex</b>-object, libphorward provides the shortcut functons
</p>

<ul>
<li><a href="#fn_pregex_qmatch">pregex_qmatch()</a> - match strings by pattern,
</li>
<li><a href="#fn_pregex_qsplit">pregex_qsplit()</a> - split strings by pattern,
</li>
<li><a href="#fn_pregex_qreplace">pregex_qreplace()</a> - replace strings by pattern
</li>
</ul>

<p>
for immediate use, without creating and destroying a <b>pregex</b>-object. Because this is done within the function calls, multiple calls of these functions result in huger runtime latencies and produce more overhead.
</p>

<h2 id="toc40">plex: Lexical analysis using regular expressions</h2>

<p>
The second part of libphorwards regular expression tools is the <b>plex</b>-object, which encapsulates all required features for creating lexical analyzers (in terms of compiler-writers also called "scanners" or "lexers") into one handy object.
</p>
<p>
A <b>plex</b>-object can be seen as a container, which merges multiple regular expressions together into one state machine to recognize tokens. A token is then identified by an unique number that is associated with the matching regular expression.
</p>

<ul>
<li><a href="#fn_plex_create">plex_create()</a> - creates a new <b>plex</b>-object,
</li>
<li><a href="#fn_plex_define">plex_define()</a> - adds a new token matcher,
</li>
<li><a href="#fn_plex_lex">plex_lex()</a> - immediatelly tests for a direct match on a string,
</li>
<li><a href="#fn_plex_next">plex_next()</a> - finds the next match within a string, where unrecognized characters are ignored,
</li>
<li><a href="#fn_plex_tokenize">plex_tokenize()</a> - generates an array of all tokens from a string,
</li>
<li><a href="#fn_plex_free">plex_free()</a> - destructs the <b>plex</b>-object after its usage,
</li>
</ul>

<p>
To tokenize a C-styled variable assignment, one could write a simple lexical analyzer, like this:
</p>

<pre><code class="language-c">
enum
{
	IDENT = 1, INTEGER, EQUALS, PLUS_OP, SEMICOLON
};

char* nid[] = { "ident", "integer", "equals", "plus_op", "semicolon" };

int m;
char* s = "sum = 5 + 23 + x;";
char* e;
plex* l;

l = plex_create( 0 );

plex_define( l, "[A-Za-z_][A-Za-z0-9_]*", IDENT, 0 );
plex_define( l, "[0-9]+", INTEGER, 0 );
plex_define( l, "=", EQUALS, 0 );
plex_define( l, "+", PLUS_OP, 0 );
plex_define( l, ";", SEMICOLON, 0 );

while( *s &amp;&amp; ( s = plex_next( l, s, &amp;m, &amp;e ) ) )
{
	printf( "%s &gt;%.*s&lt;\n", nid[m - 1], e - s, s );
	s = e;
}

plex_free( l );
</code></pre>

<p>
When running, this yields in the output:
</p>

<pre><code class="language-c">
ident &gt;sum&lt;
equals &gt;=&lt;
integer &gt;5&lt;
plus_op &gt;+&lt;
integer &gt;23&lt;
plus_op &gt;+&lt;
ident &gt;x&lt;
semicolon &gt;;&lt;
</code></pre>

<h1 id="toc41">ppgram, ppar, ppast: Grammars, parsers and abstact-syntax trees</h1>

<h2 id="toc42">Overview</h2>

<p>
The libphorward serves as a parser generator and language processing toolchain. It provides a flexible, integrated and consequent solution for many parsing-reated issues.
</p>

<ul>
<li><b>ppgram</b>, <b>ppsym</b> and <b>ppprod</b> objects provide a way to describe grammars, symbols and productions,
</li>
<li><b>pppar</b> encapsulates a parser with an <i>plex</i>-based lexer,
</li>
<li><b>ppast</b> is a linked data structure that represents parse trees generated by the parser, and allows for browsing it in any desired way.
</li>
</ul>

<p>
We assume that the reader of this section is familiar with the terminology of parsing, grammars and algorithms.
</p>

<h2 id="toc43">Grammars</h2>

<p>
Grammars are described using <b>ppgram</b> objects, which in turn are build from <i>terminal</i> and <i>nonterminal</i> symbols, described by <b>ppsym</b>, and productions, described by <b>ppprod</b>.
</p>
<p>
Whether a symbol is a terminal or a nonterminal is defined by its identifying name. Any symbol starting with a lower-case character in its name is identified as a <i>nonterminal</i> symbol. Symbols with an upper-case character or any other non-alphabetic character, as well as symbols entirely without an identifiying name, are treated as <i>terminal</i> symbols.
</p>
<p>
Here are some examples:
</p>

<ul>
<li><code>expression</code> is a nonterminal,
</li>
<li><code>Identifier</code> is a terminal,
</li>
<li><code>_expression</code> is a terminal,
</li>
<li><code>!</code> is a terminal,
</li>
<li><code>xPRESSION</code> is a nonterminal.
</li>
</ul>

<p>
The distinction rules are defined within the macro <a href="#fn_PPSYM_IS_TERMINAL">PPSYM_IS_TERMINAL()</a>, and may be changed.
</p>

<h3 id="toc44">Hand-crafting a grammar</h3>

<p>
Grammars may be hand-crafted using the various construction functions for the
different objects.
</p>
<p>
Here is the little piece of code for little BNF-rule <code>a: a A | b</code>:
</p>

<pre><code class="language-c">
ppgram* g;
ppsym*  a;
ppsym*  A;
ppsym*  b;

g = pp_gram_create();

a = pp_sym_create( g, "a", 0 );
A = pp_sym_create( g, "A", 0 );
b = pp_sym_create( g, "b", 0 );

pp_prod_create( g, a, a, A, NULL );         /* a: a A */
pp_prod_create( g, a, b, NULL );            /* a: b */

/* Alternatively: */
pprod*  p;

p = pp_prod_create( g, a, NULL );
pp_prod_append( p, a );
pp_prod_append( p, A );                     /* a: a A */

p = pp_prod_create( g, a, NULL );
pp_prod_append( p, b );                     /* a: b */
</code></pre>

<p>
Indeed, this is nasty and error-prone.
</p>

<h3 id="toc45">Expressing grammars in Backus-Naur-Form</h3>

<p>
Grammars are usually expressed in Backus-Naur-Form (BNF).
</p>
<p>
For this case, the Phorward library provides parsers to compile BNF-like input into Phorward grammar objects.
</p>

<ul>
<li><a href="#fn_pp_gram_from_bnf">pp_gram_from_bnf()</a> - Simple parser to compile BNF without any extensions.
</li>
<li><a href="#fn_pp_gram_from_ebnf">pp_gram_from_ebnf()</a> - Extended parser to compile extended BNF definitions.
</li>
<li><a href="#fn_pp_gram_from_pbnf">pp_gram_from_pbnf()</a> - Full-fledged, Phorward-style BNF parser.
</li>
</ul>

<h4>Simple BNF</h4>

<p>
Our above example grammar from the hand-crafting example can easily be constructed with the simple BNF parser, by using the function <a href="#fn_pp_gram_from_bnf">pp_gram_from_bnf()</a> on an previously created <i>ppgram</i>-object.
</p>

<pre><code class="language-c">
pp_gram_from_bnf( g, "a: a A | b;" );
</code></pre>

<p>
The simple BNF parser allows for any symbol name which consists of any character except whitespace and the meta characters <code>:</code>, <code>|</code> and <code>;</code>. Generally, the rules for the naming of terminals and nonterminals, as described above, apply.
</p>

<ul>
<li><code>:</code> is the separator between left-hand side and productions,
</li>
<li><code>|</code> is the separator between productions,
</li>
<li><code>;</code> ends a definition block to start another one.
</li>
</ul>

<h4>Extended BNF</h4>

<p>
The EBNF parser is the extended version of the simple BNF parser, and allows for further syntactical constructs.
</p>
<p>
These constructs are
</p>

<ul>
<li><code>(</code> and <code>)</code> construct inline-nonterminals with an automatically determined name, and allows for multiple productions,
</li>
<li><code>?</code> behind a right-hand side symbol defines it as optional (optional closure),
</li>
<li><code>+</code> behind a right-hand side symbol defines it as one-or-multiple (positive closure),
</li>
<li><code>*</code> behind a right-hand side symbol defines it as none-or-multiple (kleene closure).
</li>
</ul>

<p>
This example defines an (ambigous) grammar for floating-point numbers:
</p>

<pre><code class="language-c">
pp_gram_from_ebnf( g, "dig : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ;"
                      "float: dig+ . dig* | dig* . dig+ ;" );
</code></pre>

<h4>Phorward BNF</h4>

<p>
The most powerful parser for grammars is the Phorward BNF parser (PBNF). This part of the Phorward library is still under construction and will be enhanced in future to more features and elements.
</p>
<p>
Additional to the EBNF syntax, this dialect enables to define
</p>

<ul>
<li>nodes in the resulting AST using the <code>:=</code> and <code>=</code> operators,
</li>
<li>lexical recognizers for terminal symbols, using <code>"ast-node generating string"</code>, <code>'string'</code> and <code>/regular expression/</code>,
</li>
<li>whitespace symbols via the <code>%skip</code> directive,
</li>
<li>a start symbol via <code>$</code>.
</li>
</ul>

<p>
The well known four-function calculator, expressed in pbnf:
</p>

<pre><code class="language-c">
%skip   /[\s]+/ ;
Int     : /[0-9]+/ = int;

factor  : Int
        | '(' expr ')'
        ;

term    : term '*' factor = mul
        | term '/' factor = div
        | factor
        ;

expr$   : expr '+' term = add
        | expr '-' term = sub
        | term
        ;
</code></pre>

<h3 id="toc46">More grammar-related functions</h3>

<p>
There are some more functions on grammars that need to be mentioned.
</p>

<ul>
<li><a href="#fn_pp_gram_prepare">pp_gram_prepare()</a> prepares a grammar by generating additional compile-time-specific information that is required by subsequent tasks,
</li>
<li><a href="#fn_pp_gram_to_str">pp_gram_to_str()</a> generates a BNF-like representation of the grammar,
</li>
<li><a href="#fn_PP_GRAM_DUMP">PP_GRAM_DUMP()</a> dumps a grammar's productions and symbols into trace,
</li>
<li><a href="#fn_pp_gram_free">pp_gram_free()</a> frees a grammar object and all its values.
</li>
</ul>

<h2 id="toc47">Parsers</h2>

<p>
In definitions of the Phorward library, a parser is the union of a grammar, a lexical analyzer and a parsing algorithm.
</p>

<ul>
<li>The grammar is the fundamental part of the parser, and is described via <i>ppgram</i>,
</li>
<li>as lexical analyzer, a <i>plex</i> object is used and managed, but this can also be changed to any other token emitting process,
</li>
<li>as parsing algorithm, so far only LALR(1) is supported, but more algorithms are planned in future.
</li>
</ul>

<p>
Parsers are described and implemented as a <i>pppar</i> object.
</p>

<ul>
<li><a href="#fn_pp_par_create">pp_par_create()</a> creates an new parser object that is based on an existing grammar,
</li>
<li><a href="#fn_pp_par_lex">pp_par_lex()</a> and <a href="#fn_pp_par_autolex">pp_par_autolex()</a> allow to define tokens to be recognized by the <i>plex</i> object,
</li>
<li><a href="#fn_pp_par_parse">pp_par_parse()</a> finally is the parser interpreter, that parses an input string and generates an AST from its structure,
</li>
<li><a href="#fn_pp_par_free">pp_par_free()</a> drops the parser object again.
</li>
</ul>

<p>
The current state of Phorward's internal parsing tools runs on strings (char*) only. Later extensions and enhancements may provide facilities to read from files or streams.
</p>

<h2 id="toc48">Abstract Syntax Tree</h2>

<p>
The <i>ppast</i> object represents a node in the abstract syntax tree.
</p>

<pre><code class="language-c">
typedef struct _ppast       ppast;

/* AST */
struct _ppast
{
    char*                   emit;       /* AST node name */

    ppsym*                  sym;        /* Emitting symbol */
    ppprod*                 prod;       /* Emitting production */

    /* Match */
    char*                   start;      /* Begin of fragment */
    char*                   end;        /* End of fragment */
    size_t                  len;        /* Fragment length */

    /* Source */
    unsigned long           row;        /* Appearance in row */
    unsigned long           col;        /* Appearance in column */

    /* AST */
    ppast*                  child;      /* First child element */
    ppast*                  prev;       /* Previous element in current scope */
    ppast*                  next;       /* Next element in current scope */
};
</code></pre>

<p>
It is usually not constructed by hand, but by parsing functions while or after parsing has completed.
</p>
<p>
The following functions may be interesting:
</p>

<ul>
<li><a href="#fn_pp_ast_dump">pp_ast_dump()</a> and <a href="#fn_pp_ast_dump_short">pp_ast_dump_short()</a> dump a <i>ppast</i> as a textual tree into a stream, <a href="#fn_PP_AST_DUMP">PP_AST_DUMP()</a> does so into the trace,
</li>
<li><a href="#fn_pp_ast_dump_json">pp_ast_dump_json()</a> dumps a <i>ppast</i> as JSON string into a stream,
</li>
<li><a href="#fn_pp_ast_dump_tree2svg">pp_ast_dump_tree2svg()</a> dumps a <i>ppast</i> as a string that can be fed to tree2svg, a free program to visually print trees,
</li>
<li><a href="#fn_pp_ast_eval">pp_ast_eval()</a> runs an evaluation on every node,
</li>
<li><a href="#fn_pp_ast_get">pp_ast_get()</a> returns element from chain by index,
</li>
<li><a href="#fn_pp_ast_len">pp_ast_len()</a> returns the length of a tree chain (by next pointer),
</li>
<li><a href="#fn_pp_ast_select">pp_ast_select()</a> like <a href="#fn_pp_ast_get">pp_ast_get()</a>, but checking for same node names,
</li>
<li><a href="#fn_pp_ast_free">pp_ast_free()</a> frees a <i>ppast</i> structure and all subsequent links.
</li>
</ul>

<h1 id="toc49">Miscelleanous</h1>

<h2 id="toc50">Advanced memory management functions</h2>

<p>
The standard memory management functions can be replaced by these pendants:
</p>

<ul>
<li><a href="#fn_pmalloc">pmalloc()</a> - allocate and zero-intialize memory, stop on error.
</li>
<li><a href="#fn_prealloc">prealloc()</a> - reallocate memory, stop on error.
</li>
<li><a href="#fn_pfree">pfree()</a> - free memory and return (void*)NULL pointer.
</li>
<li><a href="#fn_pmemdup">pmemdup()</a> - shorthand for a malloc() with memcpy().
</li>
</ul>

<p>
These functions are used throughout libphorward's internal object mapping functions.
</p>

<h2 id="toc51">Extended string processing functions</h2>

<p>
The libphorward provides a set of functions for extended, dynamic string memory handling. These functions are named according to their standard C library counterparts, with a preceded "p", or introduce entirely new features.
</p>
<p>
String functions overview:
</p>

<ul>
<li><a href="#fn_pstrcasecmp">pstrcasecmp()</a> - case-insensitive string comparison,
</li>
<li><a href="#fn_pstrcatchar">pstrcatchar()</a> - append character to string with dynamic allocation,
</li>
<li><a href="#fn_pstrcatstr">pstrcatstr()</a> - append string to string with dynamic allocation,
</li>
<li><a href="#fn_pstrdup">pstrdup()</a> - duplicate string, also accepts NULL-pointers,
</li>
<li><a href="#fn_pstrget">pstrget()</a> - securely get string from a pointer,
</li>
<li><a href="#fn_pstrlen">pstrlen()</a> - return length ot string, also accepts NULL-pointers,
</li>
<li><a href="#fn_pstrltrim">pstrltrim()</a> - remove prefixing whitespace,
</li>
<li><a href="#fn_pstrlwr">pstrlwr()</a> - convert string to lower-case-order,
</li>
<li><a href="#fn_pstrncasecmp">pstrncasecmp()</a> - case-insensitive string comparison over maximum length,
</li>
<li><a href="#fn_pstrncatstr">pstrncatstr()</a> - append string to string with dynamic allocation and maximum length,
</li>
<li><a href="#fn_pstrndup">pstrndup()</a> - duplicate a string with maximum length,
</li>
<li><a href="#fn_pstrput">pstrput()</a> - securely set an allocated string into a pointer,
</li>
<li><a href="#fn_pstrrender">pstrrender()</a> - dynamically render a string with placeholder substitution,
</li>
<li><a href="#fn_pstrreplace">pstrreplace()</a> - dynamically replace substrings within string,
</li>
<li><a href="#fn_pstrrtrim">pstrrtrim()</a> - remove trailing whitespace,
</li>
<li><a href="#fn_pstrsplit">pstrsplit()</a> - dynamic tokenizer,
</li>
<li><a href="#fn_pstrtrim">pstrtrim()</a> - remove prefixing and trailing whitespace,
</li>
<li><a href="#fn_pstrupr">pstrupr()</a> - convert string to lower-case-order.
</li>
</ul>

<p>
Additionally, the following pendants for wide-character strings (wchar_t) exist and are available, when libphorward is compiled with the UNICODE flag enabled.
</p>

<ul>
<li><a href="#fn_pwcscatchar">pwcscatchar()</a> - append character to wide-character string with dynamic allocation,
</li>
<li><a href="#fn_pwcscatstr">pwcscatstr()</a> - append wide-character string to wide-character string with dynamic allocation,
</li>
<li><a href="#fn_pwcsdup">pwcsdup()</a> - duplicate wide-character string, also accepts NULL-pointers,
</li>
<li><a href="#fn_pwcsget">pwcsget()</a> - securely get wide-character string from a pointer,
</li>
<li><a href="#fn_pwcslen">pwcslen()</a> - return length ot wide-character string, also accepts NULL-pointers,
</li>
<li><a href="#fn_pwcsncatstr">pwcsncatstr()</a> - append wide-character string to wide-character string with dynamic allocation and maximum length,
</li>
<li><a href="#fn_pwcsndup">pwcsndup()</a> - duplicate a wide-character string with maximum length,
</li>
<li><a href="#fn_pwcsput">pwcsput()</a> - securely set an allocated wide-character string into a pointer.
</li>
</ul>

<p>
Althought the wide-character pendants to the standard extended string functions are not consistent right now, they may be extended in the future, when the existence of such functions is needed, or another, brave programmer is having the fun to implement them.
</p>

<h2 id="toc52">System-related functions</h2>

<p>
The Phorward library provides some useful functions for system-related interactions.
</p>

<ul>
<li><a href="#fn_pbasename">pbasename()</a> returns the basename of a path (the last part),
</li>
<li><a href="#fn_pfiletostr">pfiletostr()</a> reads the content of an entire file into a dynamically allocated char*,
</li>
<li><a href="#fn_pfileexists">pfileexists()</a> checks for file existence,
</li>
<li><a href="#fn_pgetopt">pgetopt()</a> provides a simple to use, but effective GNU-style command-line argument parser,
</li>
<li><a href="#fn_pwhich">pwhich()</a> checks for a file using <a href="#fn_pfileexists">pfileexists()</a> in a PATH-like, delimited search path definition
</li>
</ul>

<h2 id="toc53">Boolean data type</h2>

<p>
libphorward makes a heavy usage of the self-hosted data-type <b>pboolean</b>, which is also referenced by a define <i>BOOLEAN</i>, and the constants <i>TRUE</i> and <i>FALSE</i>.
</p>
<p>
It is known, that several header files and projects define these constants on their own, so that <b>pboolean</b>, the data-type, exists on its own using the p-prefix, but any of the defines are conditionally flagged with
</p>

<pre><code class="language-c">
#ifndef TRUE
#define TRUE					1
#endif
</code></pre>

<p>
within <code>phorward.h</code>.
</p>

<h2 id="toc54">Debug and trace facilities</h2>

<p>
Althought this option is not widely used in modern C/C++ projects, libphorward offers an own debug and trace facility that can be turned on for modules for detecting bugs or view the program trace.
</p>
<p>
For this, the library provides the following macros:
</p>

<ul>
<li><a href="#fn_LOG">LOG()</a> - message logging with printf-style formatting
</li>
<li><a href="#fn_MSG">MSG()</a> - message logging (older style)
</li>
<li><a href="#fn_PROC">PROC()</a> - starting macro marking a functions entry point,
</li>
<li><a href="#fn_PARMS">PARMS()</a> - log function parameters,
</li>
<li><a href="#fn_RETURN">RETURN()</a> - return a value
</li>
<li><a href="#fn_VARS">VARS()</a> - log variables,
</li>
<li><a href="#fn_VOIDRET">VOIDRET</a> - return from a void function.
</li>
</ul>

<p>
So when a function is written like this in libphorward's way:
</p>

<pre><code class="language-c">
int faculty( int x )
{
	int ret;

	PROC( "faculty" );
	PARMS( "x", "%d", x );

	if( x &lt; 0 )
	{
		WRONGPARAM;
		RETURN( -1 );
	}
	else if( x == 0 )
	{
		MSG( "x is 0, so faculty is 1" );
		RETURN( 1 );
	}
	else
	{
		MSG( "Calling faculty recursively with:" );
		VARS( "x - 1", "%d", x - 1 );
		ret = x * faculty( x - 1 );
	}

	VARS( "ret", "%d", ret );
	RETURN( ret );
}
</code></pre>

<p>
Trace is written to stderr, and only will be compiled into the executable code if the DEBUG preprocessor-flag is defined with a value &gt; 0.
</p>
<p>
Calling this function with
</p>

<pre><code class="language-c">
faculty( 3 );
</code></pre>

<p>
yields in a debug log
</p>

<pre><code class="language-c">
(demo.c:  380) {
(demo.c:  380) .ENTRY : faculty
(demo.c:  381) .PARMS : x = &gt;3&lt;
(demo.c:  395) .MSG   : Calling faculty recursively with:
(demo.c:  396) .VARS  : x - 1 = &gt;2&lt;
(demo.c:  380) .{
(demo.c:  380) ..ENTRY : faculty
(demo.c:  381) ..PARMS : x = &gt;2&lt;
(demo.c:  395) ..MSG   : Calling faculty recursively with:
(demo.c:  396) ..VARS  : x - 1 = &gt;1&lt;
(demo.c:  380) ..{
(demo.c:  380) ...ENTRY : faculty
(demo.c:  381) ...PARMS : x = &gt;1&lt;
(demo.c:  395) ...MSG   : Calling faculty recursively with:
(demo.c:  396) ...VARS  : x - 1 = &gt;0&lt;
(demo.c:  380) ...{
(demo.c:  380) ....ENTRY : faculty
(demo.c:  381) ....PARMS : x = &gt;0&lt;
(demo.c:  390) ....MSG   : x is 0, so faculty is 1
(demo.c:  391) ....RETURN: faculty
(demo.c:  391) ...}
(demo.c:  400) ...VARS  : ret = &gt;1&lt;
(demo.c:  401) ...RETURN: faculty
(demo.c:  401) ..}
(demo.c:  400) ..VARS  : ret = &gt;2&lt;
(demo.c:  401) ..RETURN: faculty
(demo.c:  401) .}
(demo.c:  400) .VARS  : ret = &gt;6&lt;
(demo.c:  401) .RETURN: faculty
(demo.c:  401) }
</code></pre>

<p>
when previously setting the environment variable <code>TRACEMODULE="demo.c"</code> or <code>TRACEFUNCTION="faculty"</code>.
</p>

<h2 id="toc55">Command-line tools</h2>

<p>
The Phorward library provides some useful command-line tools which can also be used or forked.
</p>

<h3 id="toc56">pregex</h3>

<p>
<b>pregex</b> is a command-line tool for regular expression operations on files and strings. It can be used for match, find, split and replace actions.
</p>

<pre><code class="language-c">
Usage: pregex OPTIONS {expression-only-if-no-other} [input-file]

   -a  --action    ACTION    Perform regular expression action:
                             match (default), find, split, replace
   -d  --delimiter STRING    Use STRING as result delimiter
                             (newline is default)
   -D                        Dump constructed DFA
   -e  --exec      EXPR      Use string EXPR as expression.
   -f  --file      FILENAME  Read expression from FILENAME
   -h  --help                Show this help, and exit.
   -i  --input     INPUT     Use string INPUT as input.
   -r  --replace   STRING    Replacement string for 'replace' action.
   -V  --version             Show version info and exit.
</code></pre>

<h3 id="toc57">plex</h3>

<p>
<b>plex</b> is a command-line tool to construct and run lexical analyzers. It returns a list of tokens on success to stdout.
</p>

<pre><code class="language-c">
Usage: plex OPTIONS patterns...

   -b  --begin     STRING    Use STRING as result begin separator
                             (' &gt;' is default)
   -e  --end       STRING    Use STRING as result end separator
                             ('&lt;\n' is default)
   -f  --file      FILENAME  Read input from FILENAME
   -h  --help                Show this help, and exit.
   -i  --input     INPUT     Use string INPUT as input.
   -V  --version             Show version info and exit.
</code></pre>

<h3 id="toc58">pparse</h3>

<p>
<b>pparse</b> is a command-line tool to compile and run parsers via command-line. It outputs the parse trees (if any) of the parsed inputs, or just checks for correct syntax.
</p>

<pre><code class="language-c">
Usage: pparse OPTIONS grammar [input [input ...]]

   grammar                   Grammar to create a parser from.
   input                     Input to be processed by the parser.

   -f  --format  TYPE        Which input grammar parser to use, either
                             pbnf (default), ebnf, bnf
   -G                        Dump constructed grammar
   -h  --help                Show this help, and exit.
   -r  --render  RENDERER    Use AST renderer RENDERER:
                             short (default), full, json, tree2svg
   -v  --verbose             Print processing information.
   -V  --version             Show version info and exit.
</code></pre>

<h2 id="toc59">Other tools</h2>

<p>
There are also some more, useful command-line tools for C programmers, which are installed and made available. These tools are heavily used by libphorward's own build process, but may also be interesting to others. These tools are all written using standard GNU utilities like sh, awk, grep and sed.
</p>

<ul>
<li>pproto - is a C function prototype generator,
</li>
<li>pinclude - is some kind of simple pre-processor to generate one big file from various smaller ones,
</li>
<li>premcomments - remove any comments from C sources,
</li>
<li>pdostounix - convert DOS-formatted text into Unix format.
</li>
</ul>

<h1 id="toc60">Reference</h1>

<h2 id="toc61">Macros</h2>

<!-- NEED 17 -->
<div class='function'>

<h3 id="fn_LOG">LOG</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
LOG( char* format, ... ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write any logging output to trace.
</p>
<p>
This function is newer than the previous ones, and allows for a printf-like
format string with variable amount of parameters.
</p>
<p>
<i>format</i> is a <a href="#fn_printf">printf()</a>-like format-string.
<i>...</i> parameters in the way they occur in the format-string.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_MSG">MSG</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
MSG( char* message ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write a message to trace.
</p>
<p>
<i>message</i> is your message!
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_PARMS">PARMS</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
PARMS( char* param_name, char* format, param_type parameter ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write parameter content to trace.
</p>
<p>
The PARMS-macro is used to write parameter names and values to the program
trace. <a href="#fn_PARMS">PARMS()</a> should - by definition - only be used right behind <a href="#fn_PROC">PROC()</a>.
If the logging of variable values is wanted during a function exection to
trace, the <a href="#fn_VARS">VARS()</a>-macro shall be used.
</p>
<p>
<i>param_name</i> is the name of the parameter
<i>format</i> is a printf-styled format placeholder.
<i>parameter</i> is the parameter itself.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_PPSYM_IS_TERMINAL">PPSYM_IS_TERMINAL</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
PPSYM_IS_TERMINAL( ppsym* sym ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Check for a symbol type, whether it is configured to be a terminal or a
nonterminal symbol.
</p>
<p>
Returns TRUE in case <i>sym</i> is a terminal symbol, and FALSE otherwise.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_PP_AST_DUMP">PP_AST_DUMP</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
PP_AST_DUMP( ppast* ast ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dump AST to trace.
</p>
<p>
The PP_AST_DUMP-macro is used to dump all relevant contents of a ppast object
into the program trace, for debugging purposes.
 <a href="#fn_PP_AST_DUMP">PP_AST_DUMP()</a> can only be used when the function was trace-enabled by <a href="#fn_PROC">PROC()</a>
before.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_PP_GRAM_DUMP">PP_GRAM_DUMP</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
PP_GRAM_DUMP( ppgram* g ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dump grammar to trace.
</p>
<p>
The PP_GRAM_DUMP-macro is used to dump all relevant contents of a ppgram object
into the program trace, for debugging purposes.
 <a href="#fn_PP_GRAM_DUMP">PP_GRAM_DUMP()</a> can only be used when the function was trace-enabled by <a href="#fn_PROC">PROC()</a>
before.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_PROC">PROC</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
PROC( char* func_name ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write function entry to trace.
</p>
<p>
The PROC-macro introduces a new function level, if compiled with trace.
</p>
<p>
The PROC-macro must be put behind the last local variable declaration and the
first code line, else it won't compile. A PROC-macro must exists within a
function to allow for other trace-macro usages. If <a href="#fn_PROC">PROC()</a> is used within a
function, the macros <a href="#fn_RETURN">RETURN()</a> or VOIDRET, according to the function return
value, must be used. If PROC is used without RETURN, the trace output will
output a wrong call level depth.
</p>
<p>
The parameter <i>func_name</i> is a static string for the function name.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_RETURN">RETURN</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
RETURN( function_type return_value ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write function return to trace.
 <a href="#fn_RETURN">RETURN()</a> can only be used if <a href="#fn_PROC">PROC()</a> is used at the beginning of the function.
For void-functions, use the macro VOIDRET.
</p>
<p>
<i>return_value</i> is return-value of the function.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_VARS">VARS</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
VARS( char* var_name, char* format, var_type variable ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write variable content to trace.
</p>
<p>
The VARS-macro is used to write variable names and values to the program trace.
For parameters taken to functions, the <a href="#fn_PARMS">PARMS()</a>-macro shall be used.
</p>
<p>
<i>var_name</i> is the name of the variable
<i>format</i> is a printf-styled format placeholder.
<i>variable</i> is the the parameter itself.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_VOIDRET">VOIDRET</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
VOIDRET - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write void function return to trace.
</p>
<p>
VOIDRET can only be used if <a href="#fn_PROC">PROC()</a> is used at the beginning of the function.
For typed functions, use the macro <a href="#fn_RETURN">RETURN()</a>.
</div>
<!-- NEED 32 -->
<div class='function'>
</p>

<h3 id="fn_parray_for">parray_for</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
parray_for( parray* array, void* ptr ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Macro that expands into a for-loop iterating a parray-object <i>array</i> using
and pointer variable <i>ptr</i> as walker.
</p>
<p>
This macro expands into a for-loop in the format
</p>

<pre><code class="language-c">
for( ptr = parray_first( array ); ptr; ptr = parray_next( array, ptr ) )
</code></pre>

<p>
where <i>ptr</i> is a walker variable of the same type size of the array's size
for each element.
</p>
<p>
<b>Example:</b>
</p>

<pre><code class="language-c">
usertype* 	t;
parray		a;

parray_init( &amp;a, sizeof( usertype ), 0 );

parray_for( a, t )
{
	/* Do something with t *}
</code></pre>

</div>
<!-- NEED 31 -->
<div class='function'>

<h3 id="fn_plist_for">plist_for</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plist_for( plist* l, plistel* e ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Macro that expands into a for-loop iterating a plist-object <i>l</i> using
the element variable <i>e</i> as walker.
</p>
<p>
This macro expands into a for-loop of the format
</p>

<pre><code class="language-c">
for( e = plist_first( l ); e; e = plist_next( e ) )
</code></pre>

<p>
where <i>e</i> is a walker variable for each element.
</p>
<p>
<b>Example:</b>
</p>

<pre><code class="language-c">
plist*		my_list;
plistel*	e;

plist_for( my_list, e )
{
	/* Access current element data part *	ptr = (cast*)plist_access( e );
	...
}
</code></pre>

</div>

<h2 id="toc74">Functions</h2>

<!-- NEED 16 -->
<div class='function'>

<h3 id="fn_p_ccl_add">p_ccl_add</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_add( pccl* ccl, wchar_t ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Integrates a single character into a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be affected.
<i>ch</i> is the character to be integrated.
</p>
<p>
The function is a shortcut for <a href="#fn_p_ccl_addrange">p_ccl_addrange()</a>.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_addrange">p_ccl_addrange</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_addrange( pccl* ccl, wchar_t begin, wchar_t end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Integrates a character range into a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be affected. If <i>ccl</i> is
provided as (pccl*)NULL, it will be created by the function.
</p>
<p>
<i>begin</i> is the begin of character range to be integrated.
<i>end</i> is the end of character range to be integrated.
</p>
<p>
If <i>begin</i> is greater than <i>end</i>, the values will be swapped.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_compare">p_ccl_compare</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int p_ccl_compare( pccl* left, pccl* right )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Checks for differences in two character-classes.
</p>
<p>
<i>left</i> is the pointer to the first character-class.
<i>right</i> is the pointer to the second character-class.
</p>
<p>
Returns a value &lt; 0 if <i>left</i> is lower than <i>right</i>, 0 if <i>left</i> is
equal to <i>right</i> or a value &gt; 0 if <i>left</i> is greater than <i>right</i>.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_compat">p_ccl_compat</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_compat( pccl* l, pccl* r )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Checks if the character-classes <i>l</i> and <i>r</i> are in the same
character universe and compatible for operations.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_count">p_ccl_count</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int p_ccl_count( pccl* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the number of characters within a character-class.
</p>
<p>
<i>ccl</i> is a pointer to the character-class to be processed.
</p>
<p>
Returns the total number of characters the class is holding.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_create">p_ccl_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* p_ccl_create( int min, int max, char* ccldef )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructor function to create a new character-class.
</p>
<p>
Returns a pointer to the newly created character-class. This pointer should be
released with <a href="#fn_p_ccl_free">p_ccl_free()</a> when its existence is no longer required.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_del">p_ccl_del</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_del( pccl* ccl, wchar_t ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes a character from a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be affected.
<i>ch</i> is the character to be removed from <i>ccl</i>.
</p>
<p>
The function is a shortcut for <a href="#fn_p_ccl_delrange">p_ccl_delrange()</a>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_delrange">p_ccl_delrange</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_delrange( pccl* ccl, wchar_t begin, wchar_t end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes a character range from a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be affected.
<i>begin</i> is the begin of character range to be removed.
<i>end</i> is the end of character range to be removed.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_diff">p_ccl_diff</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* p_ccl_diff( pccl* ccl, pccl* rem )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the difference quantity of two character-classes.
All elements from <i>rem</i> will be removed from <i>ccl</i>, and put into a
new character-class.
</p>
<p>
<i>ccl</i> is the pointer to the first character-class.
<i>rem</i> is the pointer to the second character-class.
</p>
<p>
Returns a new pointer to a copy of <i>ccl</i>, without the ranges contained in
<i>rem</i>. Returns (pccl*)NULL in case of memory allocation or parameter
error.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_dup">p_ccl_dup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* p_ccl_dup( pccl* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicates a character-class into a new one.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be duplicated.
</p>
<p>
Returns a pointer to the duplicate of <i>ccl</i>, or (pcrange)NULL
in error case.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_erase">p_ccl_erase</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_erase( pccl* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Erases a character-class <i>ccl</i>.
</p>
<p>
The function sets a character-class to zero, as it continas no character range
definitions. The object <i>ccl</i> will be still alive. To delete the entire
object, use <a href="#fn_p_ccl_free">p_ccl_free()</a>.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_free">p_ccl_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* p_ccl_free( pccl* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees a character-class <i>ccl</i> and all its used memory.
</p>
<p>
The function always returns (pccl*)NULL.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_get">p_ccl_get</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_get( wchar_t* from, wchar_t* to, pccl* ccl, int offset )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return a character or a character-range by its offset.
</p>
<p>
If the function is called only with pointer <i>from</i> provided, and <i>to</i> as
(wchar_t*)NULL, it writes the character in <i>offset</i>th position of the
character-class into from.
</p>
<p>
If the function is called both with pointer <i>from</i> and <i>to</i> provided,
it writes the <i>begin</i> and <i>end</i> character of the character-range in the
<i>offset</i>th position of the character-class into <i>from</i> and <i>to</i>.
</p>
<p>
If no character or range with the given offset was found, the function
returns FALSE, meaning that the end of the characters is reached.
On success, the function will always return TRUE.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_instest">p_ccl_instest</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_instest( pccl* ccl, wchar_t ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tests for a character in case-insensitive-mode if it matches
a character-class.
</p>
<p>
<i>ccl</i> is the pointer to character-class to be tested.
<i>ch</i> is the character to be tested.
</p>
<p>
The function is a shortcut for <a href="#fn_p_ccl_testrange">p_ccl_testrange()</a>.
</p>
<p>
It returns TRUE, if the character matches the class, and FALSE if not.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_intersect">p_ccl_intersect</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* p_ccl_intersect( pccl* ccl, pccl* within )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns a new character-class with all characters that exist in both
provided character-classes.
</p>
<p>
<i>ccl</i> is the pointer to the first character-class.
<i>within</i> is the pointer to the second character-class.
</p>
<p>
Returns a new character-class containing the insersections from <i>ccl</i>
and <i>within</i>. If there is no intersection between both character-classes,
the function returns (pccl*)NULL.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_negate">p_ccl_negate</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* p_ccl_negate( pccl* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Negates all ranges in a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be negated.
</p>
<p>
Returns a pointer to <i>ccl</i>.
</div>
<!-- NEED 25 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_parse">p_ccl_parse</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_parse( pccl* ccl, char* ccldef, pboolean extend )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Parses the character-class definition provided in <i>ccldef</i> and assigns
this definition to the character-class <i>ccl</i>. <i>ccldef</i> may contain
UTF-8 formatted input. Escape-sequences will be interpretered to their correct
character representations.
</p>
<p>
A typical character-class definition simply exists of single characters and
range definitions. For example, "$A-Z#0-9" defines a character-class that
consists of the characters "$#0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".
</p>
<p>
The parameter <i>extend</i> specifies, if the provided character-class overwrites
(<i>extend</i> = FALSE) or extends (<i>extend</i> = TRUE) the provided
character-class. This means that definitions that already exist in the
character-class, should be erased first or not.
</p>
<p>
The function returns TRUE on success, and FALSE on an error.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_parsechar">p_ccl_parsechar</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t p_ccl_parsechar( wchar_t* retc, char *str, pboolean escapeseq )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Reads a character from a string. The character may exist of one single
character or it may be made up of an escape sequence or UTF-8 character.
The function returns the number of bytes read.
</p>
<p>
<i>retc</i> is the return pointer for the character code of the escaped string.
<i>str</i> is the begin pointer of the string at which character parsing begins.
If <i>escapeseq</i> is TRUE, the function regards escape sequences, else it ignores
them.
</p>
<p>
Returns the number of bytes that had been read for the character.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_parseshorthand">p_ccl_parseshorthand</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_parseshorthand( pccl* ccl, char **str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tries to parse a shorthand sequence from a string. This matches the
shorthands \w, \W, \d, \D, \s and \S. If it matches, all characters are
added to <i>ccl</i>.
</p>
<p>
The function returns TRUE in case a shorthand has been parsed. If so,
the pointer <i>str</i> is moved the characters consumed.
</p>
<p>
If no shorthand sequence could be found, it returns FALSE, remaining <i>ccl</i>
untouched.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_print">p_ccl_print</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void p_ccl_print( FILE* stream, pccl* ccl, int break_after )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Print character-class to output stream.
This function is provided for debug-purposes only.
</p>
<p>
<i>stream</i> is the output stream to dump the character-class to; This can be
left (FILE*)NULL, so <i>stderr</i> will be used.
<i>ccl</i> is the pointer to character-class
</p>
<p>
<i>break_after</i> defines:
</p>

<ul>
<li>if &lt; 0 print with pointer info
</li>
<li>if 0 print all into one line
</li>
<li>if &gt; 0 print linewise
</li>
</ul>

</div>
<!-- NEED 17 -->
<div class='function'>

<h3 id="fn_p_ccl_size">p_ccl_size</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int p_ccl_size( pccl* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the number of range pairs within a character-class.
</p>
<p>
<i>ccl</i> is a pointer to the character-class to be processed.
</p>
<p>
To retrieve the number of characters in a character-class, use <a href="#fn_p_ccl_count">p_ccl_count()</a> instead.
</p>
<p>
Returns the number of pairs the charclass holds.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_test">p_ccl_test</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_test( pccl* ccl, wchar_t ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tests a character-class if it cointains a character.
</p>
<p>
<i>ccl</i> is the pointer to character-class to be tested.
<i>ch</i> is the character to be tested.
</p>
<p>
The function is a shortcut for <a href="#fn_p_ccl_testrange">p_ccl_testrange()</a>.
</p>
<p>
It returns TRUE, if the character matches the class, and FALSE if not.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_testrange">p_ccl_testrange</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean p_ccl_testrange( pccl* ccl, wchar_t begin, wchar_t end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tests a character-class to match a character range.
</p>
<p>
<i>ccl</i> is a pointer to the character-class to be tested.
<i>begin</i> is the begin of character-range to be tested.
<i>end</i> is the end of character-range to be tested.
</p>
<p>
Returns TRUE if the entire character range matches the class, and FALSE if not.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_to_str">p_ccl_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* p_ccl_to_str( pccl* ccl, pboolean escape )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a character-class back to a string representation of the
character-class definition, which in turn can be converted back into a
character-class using <a href="#fn_p_ccl_create">p_ccl_create()</a>.
</p>
<p>
<i>ccl</i> is the pointer to character-class to be converted.
<i>escape</i>, if TRUE, escapes "unprintable" characters in their hexadecimal
representation. If FALSE, it prints all characters, except the zero, which will
be returned as "\0"
</p>
<p>
Returns a pointer to the generated string that represents the charclass.
The returned pointer belongs to the <i>ccl</i> and is managed by the
character-class handling functions, so it should not be freed manually.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_p_ccl_union">p_ccl_union</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* p_ccl_union( pccl* ccl, pccl* add )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Unions two character-classes into a new, normalized one.
</p>
<p>
<i>ccl</i> is the pointer to the character-class that will be extended to all
ranges contained in <i>add</i>.
<i>add</i> is character-class that will be unioned with <i>ccl</i>.
</p>
<p>
The function creates and returns a new character-class that is the union
if <i>ccl</i> and <i>add</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_convert">pany_convert</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pany_convert( pany* val, panytype type )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a pany-structure to any supported type.
</p>
<p>
<i>val</i> is the pany-object to be converted.
<i>type</i> is the type define to which <i>val</i> should be converted to.
</p>
<p>
The function returns TRUE on success, FALSE else.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_pany_copy">pany_copy</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pany_copy( pany* dest, pany* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Copy any value from <i>src</i> into <i>dest</i>.
</p>
<p>
<i>dest</i> will be reset and stand on its own after copying.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_create">pany_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pany* pany_create( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates a new pany-object.
</p>
<p>
It allows for parsing a value from <i>str</i>.
</p>
<p>
This object must be released after usage using <a href="#fn_pany_free">pany_free()</a>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pany_dup">pany_dup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pany* pany_dup( pany* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate the object <i>src</i> into a new object that stands on its own.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_fprint">pany_fprint</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pany_fprint( FILE* stream, pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Print the type and value of <i>val</i> to <i>stream</i>
without any conversion. This function shall be used for debug only.
</p>
<p>
<i>stream</i> is the stream to write to.
<i>val</i> is the pany-object to be printed.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_pany_free">pany_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pany* pany_free( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees an allocated pany object and all its used memory.
</p>
<p>
The function always returns (pany*)NULL.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_bool">pany_get_bool</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pany_get_bool( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>pboolean</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as pboolean.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_char">pany_get_char</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char pany_get_char( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>char</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as char.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_cstr">pany_get_cstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pany_get_cstr( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>char*</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as char*.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_cwcs">pany_get_cwcs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pany_get_cwcs( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>wchar_t*</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as wchar_t*.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_double">pany_get_double</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
double pany_get_double( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>double</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as double.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_float">pany_get_float</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
float pany_get_float( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>float</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as float.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_int">pany_get_int</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pany_get_int( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>int</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as int.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_long">pany_get_long</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
long pany_get_long( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>long</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as long.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_ptr">pany_get_ptr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* pany_get_ptr( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>void*</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as void*.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_str">pany_get_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pany_get_str( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>char*</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as char*.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_ulong">pany_get_ulong</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
unsigned long pany_get_ulong( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>unsigned long</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as unsigned long.
This value could be converted from the original value.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pany_get_wcs">pany_get_wcs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pany_get_wcs( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <code>wchar_t*</code>-value of <i>val</i>.
</p>
<p>
<i>val</i> is the pointer to the pany-object.
</p>
<p>
If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to <i>val</i> as wchar_t*.
This value could be converted from the original value.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_pany_init">pany_init</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pany_init( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Initializes a pany-element.
</p>
<p>
<i>val</i> is the pointer to the pany-structure to be initialized.
</div>
<!-- NEED 24 -->
<div class='function'>
</p>

<h3 id="fn_pany_parse">pany_parse</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pany_parse( pany* val, char* str, panytype enforce )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Parse any value from a string.
</p>
<p>
The function will check and ignore for leading and following whitespace, and
matches long integer, double values and strings.
</p>
<p>
If a string is encapsulated between C-styled string or character tokens (", '),
the content between the delimiters will be taken as a string and ran through an
escaping function.
</p>
<p>
Any other content is taken as string. If the parameter <i>enforce</i> is set to
an desired PANY_-type, this type will be enforced, and no special recognition
is done.
</p>
<p>
This function tries to detect
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_reset">pany_reset</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pany_reset( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees all memory used by a pany-element.
</p>
<p>
All memory used by the element is freed, and the union's structure is reset
to be of type PANYTYPE_NULL.
</p>
<p>
<i>val</i> is the pointer to pany structure.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_bool">pany_set_bool</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pany_set_bool( pany* val, pboolean b )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>pboolean</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>b</i> is the <code>pboolean</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>b</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_char">pany_set_char</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char pany_set_char( pany* val, char c )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>char</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>c</i> is the <code>char</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>c</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_cstr">pany_set_cstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pany_set_cstr( pany* val, char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>char*</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>s</i> is the <code>char*</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>s</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_cwcs">pany_set_cwcs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pany_set_cwcs( pany* val, wchar_t* ws )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>wchar_t*</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>ws</i> is the <code>wchar_t*</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>ws</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_double">pany_set_double</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
double pany_set_double( pany* val, double d )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>double</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>d</i> is the <code>double</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>d</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_float">pany_set_float</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
float pany_set_float( pany* val, float f )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>float</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>f</i> is the <code>float</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>f</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_int">pany_set_int</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pany_set_int( pany* val, int i )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>int</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>i</i> is the <code>int</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>i</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_long">pany_set_long</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
long pany_set_long( pany* val, long l )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>long</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>l</i> is the <code>long</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>l</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_ptr">pany_set_ptr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* pany_set_ptr( pany* val, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>void*</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>ptr</i> is the <code>void*</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>ptr</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_str">pany_set_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pany_set_str( pany* val, char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>char*</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>s</i> is the <code>char*</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>s</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_ulong">pany_set_ulong</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
unsigned long pany_set_ulong( pany* val, unsigned long ul )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>unsigned long</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>ul</i> is the <code>unsigned long</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>ul</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pany_set_wcs">pany_set_wcs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pany_set_wcs( pany* val, wchar_t* ws )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets the <code>wchar_t*</code>-value and type of <i>va</i>.
</p>
<p>
<i>val</i> is the pany-object to be set.
<i>ws</i> is the <code>wchar_t*</code>-value to be assigned to <i>val</i>.
</p>
<p>
The function always returns the value <i>ws</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_bool">pany_to_bool</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pany_to_bool( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a pboolean value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the pboolean-value of <i>val</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_char">pany_to_char</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char pany_to_char( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a char value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the char-value of <i>val</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_double">pany_to_double</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
double pany_to_double( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a double value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the double-value of <i>val</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_float">pany_to_float</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
float pany_to_float( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a float value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the float-value of <i>val</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_int">pany_to_int</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pany_to_int( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a int value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the int-value of <i>val</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_long">pany_to_long</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
long pany_to_long( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a long value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the long-value of <i>val</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_ptr">pany_to_ptr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* pany_to_ptr( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a void* value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the void*-value of <i>val</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_str">pany_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pany_to_str( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a char* value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the char*-value of <i>val</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_ulong">pany_to_ulong</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
unsigned long pany_to_ulong( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a unsigned long value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the unsigned long-value of <i>val</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pany_to_wcs">pany_to_wcs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pany_to_wcs( pany* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts the current value of <i>val</i> into a wchar_t* value.
</p>
<p>
<i>val</i> is the pany-object to convert from.
</p>
<p>
The function returns the wchar_t*-value of <i>val</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_parray_count">parray_count</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t parray_count( parray* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the number of elements in a array.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_create">parray_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
parray* parray_create( size_t size, size_t chunk )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Create a new parray as an object with an element allocation size <i>size</i>
and a reallocation-chunk-size of <i>chunk</i>.
</p>
<p>
The returned memory must be released with <a href="#fn_parray_free">parray_free()</a>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_parray_erase">parray_erase</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean parray_erase( parray* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Erase a dynamic array.
</p>
<p>
The array must not be reinitialized after destruction, using <a href="#fn_parray_init">parray_init()</a>.
</p>
<p>
<i>array</i> is the pointer to the array to be erased.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_first">parray_first</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_first( parray* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access first element of the array.
</p>
<p>
Returns the address of the accessed item, and (void*)NULL if nothing is in
the array.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_parray_free">parray_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
parray* parray_free( parray* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Releases all the memory <i>array</i> uses and destroys the array object.
</p>
<p>
The function always returns (parray*)NULL.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_parray_get">parray_get</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_get( parray* array, size_t offset )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access an element from the array by its offset position from the left.
</p>
<p>
<i>array</i> is the pointer to array where to access the element from.
<i>offset</i> is the offset of the element to be accessed from the array's
base address.
</p>
<p>
Returns the address of the accessed item, and (void*)NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the last of array).
</p>
<p>
Use <a href="#fn_parray_rget">parray_rget()</a> for access items from the end.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_parray_init">parray_init</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean parray_init( parray* array, size_t size, size_t chunk )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs an array initialization.
</p>
<p>
<i>array</i> is the pointer to the array to be initialized.
</p>
<p>
<i>size</i> defines the size of one array element, in bytes.
This should be evaluated using the <a href="#fn_sizeof">sizeof()</a>-macro.
</p>
<p>
<i>chunk</i> defines the chunk size, where an array-(re)allocation will be performed.
If, e.g. this is set to 128, then, if the 128th item is created within the
array, a realloction is done. Once allocated memory remains until the array is
freed again.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_parray_insert">parray_insert</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_insert( parray* array, size_t offset, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Insert item <i>item</i> at <i>offset</i> into array <i>array</i>.
Items right to <i>offset</i> will move up.
</p>
<p>
Gap space between the offset is filled with zero elements;
Handle with care!
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_iter">parray_iter</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_iter( parray* array, parrayfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates over <i>array</i>.
</p>
<p>
Iterates over all items of <i>array</i> and calls the function <i>callback</i> on
every item.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_last">parray_last</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_last( parray* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access last element of the array.
</p>
<p>
Returns the address of the accessed item, and (void*)NULL if nothing is in
the array.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_malloc">parray_malloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_malloc( parray* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Pushes and "allocates" an empty element on the array.
</p>
<p>
This function is just a shortcut to <code>`parray_push( array, (void*)NULL )`</code>,
and the memory of the pushed element is initialized to zero.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_next">parray_next</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_next( parray* array, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access next element from <i>ptr</i> in <i>array</i>.
</p>
<p>
Returns the address of the next element, and (void*)NULL if the access gets
out of bounds.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_parray_offset">parray_offset</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t parray_offset( parray* array, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return offset of element <i>ptr</i> in array <i>array</i>.
Returns the offset of <i>ptr</i> in <i>array</i>.
The function returns the size of the array (which is an invalid offset)
if <i>ptr</i> is not part of <i>array</i>.
</p>
<p>
To check if a pointer belongs to an array, call <a href="#fn_parray_partof">parray_partof()</a>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_parray_partof">parray_partof</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean parray_partof( parray* array, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns TRUE, if <i>ptr</i> is an element of array <i>array</i>.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_parray_pop">parray_pop</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_pop( parray* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes an element from the end of an array.
</p>
<p>
The function returns the pointer of the popped item. Because dynamic arrays only
grow and no memory is freed, the returned data pointer is still valid, and will
only be overidden with the next push operation.
</p>
<p>
<i>array</i> is the pointer to array where to pop an item off.
</p>
<p>
The function returns the address of the popped item, and (void*)NULL if the
item could not be popped (e.g. array is empty).
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_prev">parray_prev</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_prev( parray* array, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access previous element from <i>ptr</i> in <i>array</i>.
</p>
<p>
Returns the address of the previous element, and (void*)NULL if the access gets
out of bounds.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_parray_push">parray_push</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_push( parray* array, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends an element to the end of the array.
</p>
<p>
The element's memory is copied during the push. The item must be of the same
memory size as used at array initialization.
</p>
<p>
<i>array</i> is the pointer to array where to push an item on.
</p>
<p>
<i>item</i> is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left (void*)NULL, so no memory will be copied.
</p>
<p>
The function returns the address of the newly pushed item, and (void*)NULL if
the item could not be pushed.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_parray_put">parray_put</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_put( parray* array, size_t offset, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Put an element <i>item</i> at position <i>offset</i> of array <i>array</i>.
</p>
<p>
<i>array</i> is the pointer to array where to put the element to.
<i>offset</i> is the offset of the element to be set.
<i>item</i> is a pointer to the memory that will be copied into the
position at <i>offset</i>. If this is NULL, the position at <i>offset</i> will be
set to zero.
</p>
<p>
Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_parray_remove">parray_remove</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_remove( parray* array, size_t offset, void** item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Remove item on <i>offset</i> from array <i>array</i>.
</p>
<p>
The removed item will be copied into <i>item</i>, if <i>item</i> is not NULL.
The function returns the memory of the removed item (it will contain the
moved up data part or invalid memory, if on the end).
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_reserve">parray_reserve</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean parray_reserve( parray* array, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Reserves memory for <i>n</i> items in <i>array</i>.
</p>
<p>
This function is only used to assume that no memory reallocation is done when
the next <i>n</i> items are inserted/malloced.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_parray_rget">parray_rget</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_rget( parray* array, size_t offset )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access an element from the array by its offset position from the right.
</p>
<p>
<i>array</i> is the pointer to array where to access the element from.
<i>offset</i> is the offset of the element to be accessed from the array's
base address.
</p>
<p>
Returns the address of the accessed item, and (void*)NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the bottom of
the array).
</p>
<p>
Use <a href="#fn_parray_get">parray_get()</a> for access items from the begin.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_riter">parray_riter</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_riter( parray* array, parrayfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates backwards over <i>array</i>.
</p>
<p>
Backwardly iterates over all items of <i>array</i> and calls the function
<i>callback</i> on every item.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_rmalloc">parray_rmalloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_rmalloc( parray* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Unshifts and "allocates" an empty element on the array.
</p>
<p>
This function is just a shortcut to <code>`parray_unshift( array, (void*)NULL )`</code>,
and the memory of the unshifted element is initialized to zero.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_parray_rput">parray_rput</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_rput( parray* array, size_t offset, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Put an element <i>item</i> at position <i>offset</i> from the right of
array <i>array</i>.
</p>
<p>
<i>array</i> is the pointer to array where to put the element to.
<i>offset</i> is the offset of the element to be set.
<i>item</i> is a pointer to the memory that will be copied into the
position at <i>offset</i>. If this is NULL, the position at <i>offset</i> will be
set to zero.
</p>
<p>
Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_parray_shift">parray_shift</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_shift( parray* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes an element from the begin of an array.
</p>
<p>
The function returns the pointer of the shifted item.
Because dynamic arrays only grow and no memory is freed, the returned data
pointer is still valid, and will only be overidden with the next unshift
operation.
</p>
<p>
<i>array</i> is the pointer to array where to pop an item off.
</p>
<p>
The function returns the address of the shifted item, and (void*)NULL if the
item could not be popped (e.g. array is empty).
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_parray_swap">parray_swap</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_swap( parray* array, size_t pos1, size_t pos2 )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Swap two elements of an array.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_parray_unshift">parray_unshift</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_unshift( parray* array, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends an element to the begin of the array.
</p>
<p>
The elements memory is copied during the unshift. The item must be of the same
memory size as used at array initialization.
</p>
<p>
<i>array</i> is the pointer to array where to push an item to the beginning.
</p>
<p>
<i>item</i> is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left (void*)NULL, so no memory will be copied.
</p>
<p>
The function returns the address of the newly unhshifted item, and (void*)NULL
if the item could not be unshifted.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pasprintf">pasprintf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pasprintf( char* fmt, ... )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Implementation and replacement for asprintf. <a href="#fn_pasprintf">pasprintf()</a> takes only the
format-string and various arguments. It outputs an allocated string to be freed
later on.
</p>
<p>
<i>fmt</i> is the format string.
<i>...</i> are the parameters according to the placeholders set in <i>fmt</i>.
</p>
<p>
Returns a char* Returns the allocated string which cointains the format string
with inserted values.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pbasename">pbasename</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pbasename( char* path )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the basename of a file.
</p>
<p>
<i>path</i> is the file path pointer.
</p>
<p>
Returns a pointer to the basename, which is a part of <i>path</i>.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pdbl_to_str">pdbl_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pdbl_to_str( double d )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a double-value into an allocated string buffer.
</p>
<p>
<i>d</i> is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become "1.65" in its
string representation.
</p>
<p>
Returns a pointer to the newly allocated string, which contains the
string-representation of the double value. This pointer must be released
by the caller.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pdbl_to_wcs">pdbl_to_wcs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pdbl_to_wcs( double d )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a double-value into an allocated wide-character string buffer.
</p>
<p>
<i>d</i> is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become L"1.65" in its
wide-character string representation.
</p>
<p>
Returns a pointer to the newly allocated wide-character string, which contains
the string-representation of the double value. This pointer must be released
by the caller.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pfileexists">pfileexists</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pfileexists( char* filename )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Checks for file existence.
</p>
<p>
<i>filename</i> is the path to a file that will be checked.
</p>
<p>
Returns TRUE on success, FALSE if not.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pfiletostr">pfiletostr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pfiletostr( char** cont, char* filename )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Maps the content of an entire file into memory.
</p>
<p>
<i>cont</i> is the file content return pointer.
<i>filename</i> is the path to file to be mapped
</p>
<p>
The function returns TRUE on success.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pfree">pfree</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* pfree( void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Free allocated memory.
</p>
<p>
The function is a wrapper for the system-function <a href="#fn_free">free()</a>, but accepts
NULL-pointers and returns a (void*)NULL pointer for direct pointer memory reset.
</p>
<p>
It could be used this way to immedatelly reset a pointer to NULL:
</p>

<pre><code class="language-c">
ptr = pfree( ptr );
</code></pre>

<p>
<i>ptr</i> is the pointer to be freed.
</p>
<p>
Returns always (void*)NULL.
</div>
<!-- NEED 37 -->
<div class='function'>
</p>

<h3 id="fn_pgetopt">pgetopt</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pgetopt( char* opt, char** param, int* next, int argc, char** argv, char* optstr, char* loptstr, int idx )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Implementation of a command-line option interpreter.
</p>
<p>
This function works similar to the <a href="#fn_getopt">getopt()</a> functions of the GNU Standard
Library, but uses a different style of parameter submit.
</p>
<p>
It supports both short- and long- option-style parameters.
This function is currently under recent development relating to the issues it
is used for. It can't be seen as compatible or feature-proven, and does not
follow a clear concept right now.
</p>

<ul>
<li><i>opt</i> is a pointer to a buffer with enough space to store the requested parameter to. For short parameters, this is only one char, for long-parameters the full name. The string will be zero-terminated.
</li>
<li><i>param</i> is a pointer to store a possible parameter value to, if the detected option allows for parameters.
</li>
<li><i>next</i> receives the index in argv of the next evaluated option. It can be left (int*)NULL. It points to the next valid index in argv[] after all parameters have been evaluated. Check it for &lt; argc, to point to valid data.
</li>
<li><i>argc</i> is the argument count as taken from the <a href="#fn_main">main()</a> function.
</li>
<li><i>argv</i> are the argument values as taken from the <a href="#fn_main">main()</a> function.
</li>
<li><i>optstr</i> contains the possible short-options. This is a string where each character defines an option. If an option takes a parameter, a colon (:) is submitted. E.g. "abc:def:g". The Options "-c" and "-f" will take a parameter that is
returned to param. This parameter can be (char*)NULL.
</li>
<li><i>loptstr</i> contains the possible long-options. This is a string containing all long option names, each separated by a blank. Long options taking parameters have an attached colon (:) to the name.  E.g. "hello world: next" defines three long options, where option 'world' takes one parameter that is returned to param. This parameter can be (char*)NULL.
</li>
<li><i>idx</i> is the index of the requested option, 0 for the first option behind argv[0].
</li>
</ul>

<p>
The function returns 0, if the parameter with the given index was
successfully evaluated. It returns 1, if there are still command-line
parameters, but not as part of options. The parameter <i>param</i> will receive
the given pointer. It returns -1 if no more options could be read, or if an
option could not be evaluated (unknown option). In such case, <i>param</i> will
hold a string to the option that is unknown to <a href="#fn_pgetopt">pgetopt()</a>.
</div>
<!-- NEED 32 -->
<div class='function'>
</p>

<h3 id="fn_plex_create">plex_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plex* plex_create( int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructor function to create a new plex object.
</p>
<p>
<i>flags</i> can be a combination of compile- and runtime-flags and are merged
with special compile-time flags provided for each pattern.
</p>

<table border="1">
<tr>
<th>Flag</th>
<th>Usage</th>
</tr>
<tr>
<td>PREGEX_COMP_WCHAR</td>
<td>The regular expressions are provided as wchar_t.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOANCHORS</td>
<td>Ignore anchor tokens, handle them as normal characters</td>
</tr>
<tr>
<td>PREGEX_COMP_NOREF</td>
<td>Don't compile references.</td>
</tr>
<tr>
<td>PREGEX_COMP_NONGREEDY</td>
<td>Compile all patterns to be forced nongreedy.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOERRORS</td>
<td>Don't report errors, and try to compile as much as possible</td>
</tr>
<tr>
<td>PREGEX_COMP_INSENSITIVE</td>
<td>Parse regular expressions as case insensitive.</td>
</tr>
<tr>
<td>PREGEX_COMP_STATIC</td>
<td>The regular expressions passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped.</td>
</tr>
<tr>
<td>PREGEX_RUN_WCHAR</td>
<td>Run regular expressions with wchar_t as input.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOANCHORS</td>
<td>Ignore anchors while processing the lexer.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOREF</td>
<td>Don't create references.</td>
</tr>
<tr>
<td>PREGEX_RUN_NONGREEDY</td>
<td>Force run lexer nongreedy.</td>
</tr>
<tr>
<td>PREGEX_RUN_DEBUG</td>
<td>Debug mode; output some debug to stderr.</td>
</tr>
</table>

<p>
On success, the function returns the allocated pointer to a plex-object.
This must be freed later using <a href="#fn_plex_free">plex_free()</a>.
</div>
<!-- NEED 36 -->
<div class='function'>
</p>

<h3 id="fn_plex_define">plex_define</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* plex_define( plex* lex, char* pat, int match_id, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Defines and parses a regular expression pattern into the plex-object.
</p>
<p>
<i>pat</i> is the regular expression string, or a pointer to a pregex_ptn*
structure in case PREGEX_COMP_PTN is flagged.
</p>
<p>
<i>match_id</i> must be a token match ID, a value &gt; 0. The lower the match ID is,
the higher precedence takes the appended expression when there are multiple
matches.
</p>
<p>
<i>flags</i> may ONLY contain compile-time flags, and is combined with the
compile-time flags of the plex-object provided at <a href="#fn_plex_create">plex_create()</a>.
</p>

<table border="1">
<tr>
<th>Flag</th>
<th>Usage</th>
</tr>
<tr>
<td>PREGEX_COMP_WCHAR</td>
<td>The regular expressions are provided as wchar_t.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOANCHORS</td>
<td>Ignore anchor tokens, handle them as normal characters</td>
</tr>
<tr>
<td>PREGEX_COMP_NOREF</td>
<td>Don't compile references.</td>
</tr>
<tr>
<td>PREGEX_COMP_NONGREEDY</td>
<td>Compile all patterns to be forced nongreedy.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOERRORS</td>
<td>Don't report errors, and try to compile as much as possible</td>
</tr>
<tr>
<td>PREGEX_COMP_INSENSITIVE</td>
<td>Parse regular expressions as case insensitive.</td>
</tr>
<tr>
<td>PREGEX_COMP_STATIC</td>
<td>The regular expressions passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped.</td>
</tr>
<tr>
<td>PREGEX_COMP_PTN</td>
<td>The regular expression passed already is a pattern, and shall be integrated.</td>
</tr>
</table>

<p>
Returns a pointer to the pattern object that just has been added. This allows
for changing e.g. the accept flag later on. In case of an error, the value
returned is NULL.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plex_free">plex_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plex* plex_free( plex* lex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Destructor function for a plex-object.
</p>
<p>
<i>lex</i> is the pointer to a plex-structure that will be released.
</p>
<p>
Returns always (plex*)NULL.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_plex_lex">plex_lex</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plex_lex( plex* lex, char* start, char** end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs a lexical analysis using the object <i>lex</i> on pointer <i>start</i>.
</p>
<p>
If a token can be matched, the function returns the related id of the matching
pattern, and <i>end</i> receives the pointer to the last matched character.
</p>
<p>
The function returns 0 in case that there was no direct match.
The function <a href="#fn_plex_next">plex_next()</a> ignores unrecognized symbols and directly moves to the
next matching pattern.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_plex_next">plex_next</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* plex_next( plex* lex, char* start, unsigned int* id, char** end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs lexical analysis using <i>lex</i> from begin of pointer <i>start</i>, to
the next matching token.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the plex-object).
</p>
<p>
If a token can be matched, the function returns the pointer to the position
where the match starts at. <i>id</i> receives the id of the matching patternn,
<i>end</i> receives the end pointer of the match, when provided. <i>id</i> and <i>end</i>
can be omitted by providing NULL-pointers.
</p>
<p>
The function returns (char*)NULL in case that there is no match.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plex_prepare">plex_prepare</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plex_prepare( plex* lex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Prepares the DFA state machine of a plex-object <i>lex</i> for execution.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plex_reset">plex_reset</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plex_reset( plex* lex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Resets the DFA state machine of a plex-object <i>lex</i>.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_plex_tokenize">plex_tokenize</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t plex_tokenize( plex* lex, char* start, parray** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tokenizes the string beginning at <i>start</i> using the lexical analyzer
<i>lex</i>.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the plex-object).
</p>
<p>
The function initializes and fills the array <i>matches</i>, if provided, with
items of size prange. It returns the total number of matches.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_access">plist_access</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* plist_access( plistel* e )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access data-content of the current element <i>e</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_clear">plist_clear</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_clear( plist* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Clear content of the list <i>list</i>.
</p>
<p>
The function has nearly the same purpose as <a href="#fn_plist_erase">plist_erase()</a>, except that
the entire list is only cleared, but if the list was initialized with
PLIST_MOD_RECYCLE, existing pointers are hold for later usage.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_concat">plist_concat</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_concat( plist* dest, plist* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Concats the elements of list <i>src</i> to the elements of list <i>dest</i>.
</p>
<p>
The function will not run if both lists have different element size settings.
</p>
<p>
The function returns the number of elements added to <i>dest</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_count">plist_count</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_count( plist* l )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return element count of list <i>l</i>.
</div>
<!-- NEED 29 -->
<div class='function'>
</p>

<h3 id="fn_plist_create">plist_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plist* plist_create( size_t size, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Create a new plist as an object with an element allocation size <i>size</i>.
Providing a <i>size</i> of 0 causes automatic configuration of PLIST_MOD_PTR.
</p>
<p>
<i>flags</i> defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage. The flags can be merged together using
bitwise or (|).
</p>
<p>
Possible flags are:
</p>

<ul>
<li><b>PLIST_MOD_NONE</b> for no special flagging.
</li>
<li><b>PLIST_MOD_PTR</b> to use the plist-object in pointer-mode: Each plistel-element cointains only a pointer to an object in the memory and returnsthis, instead of copying from or into pointers.
</li>
<li><b>PLIST_MOD_RECYCLE</b> to configure that elements that are removed during listusage will be reused later.
</li>
<li><b>PLIST_MOD_AUTOSORT</b> to automatically sort elements on insert operations.
</li>
<li><b>PLIST_MOD_EXTKEYS</b> to configure that string pointers to hash-table keyvalues are stored elsewhere, so the plist-module only uses the originalpointers instead of copying them.
</li>
<li><b>PLIST_MOD_PTRKEYS</b> disables string keys and uses the pointer/valueprovided as key directly.
</li>
<li><b>PLIST_MOD_UNIQUE</b> to disallow hash-table-key collisions, so elements witha key that already exist in the object will be rejected.
</li>
<li><b>PLIST_MOD_WCHAR</b> to let all key values handle as wide-character strings.
</li>
</ul>

<p>
Use <a href="#fn_plist_free">plist_free()</a> to erase and release the returned list object.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_plist_diff">plist_diff</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_diff( plist* left, plist* right )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tests the contents (data parts) of the list <i>left</i> and the list <i>right</i>
for equal elements.
</p>
<p>
The function returns a value &lt; 0 if <i>left</i> is lower <i>right</i>, a value &gt; 0
if <i>left</i> is greater <i>right</i> and a value == 0 if <i>left</i> is equal to
<i>right</i>.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_dup">plist_dup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plist* plist_dup( plist* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates an independent copy of <i>list</i> and returns it.
</p>
<p>
All elements of <i>list</i> are duplicated and stand-alone.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_erase">plist_erase</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_erase( plist* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Erase all allocated content of the list <i>list</i>.
</p>
<p>
The object <i>list</i> will be still alive, but must be re-configured
using <a href="#fn_plist_init">plist_init()</a>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_first">plist_first</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_first( plist* l )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return first element of list <i>l</i>.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_free">plist_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plist* plist_free( plist* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Releases all the memory <i>list</i> uses and destroys the list object.
</p>
<p>
The function always returns (plist*)NULL.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_get">plist_get</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_get( plist* list, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list element by its index from the begin.
</p>
<p>
The function returns the <i>n</i>th element of the list <i>list</i>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_get_by_key">plist_get_by_key</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_get_by_key( plist* list, char* key )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list element by hash-table key.
</p>
<p>
This function tries to fetch a list entry plistel from list <i>list</i>
with the key <i>key</i>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_get_by_ptr">plist_get_by_ptr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_get_by_ptr( plist* list, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list element by pointer.
</p>
<p>
This function returns the list element of the unit within the list <i>list</i>
that is the pointer <i>ptr</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_hashnext">plist_hashnext</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_hashnext( plistel* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access next element with same hash value of current unit <i>u</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_hashprev">plist_hashprev</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_hashprev( plistel* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access previous element with same hash value of a current unit <i>u</i>.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_init">plist_init</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_init( plist* list, size_t size, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Initialize the list <i>list</i> with an element allocation size <i>size</i>.
<i>flags</i> defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_plist_insert">plist_insert</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_insert( plist* list, plistel* pos, char* key, void* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Insert <i>src</i> as element to the list <i>list</i> <u>before</u> position <i>pos</i>.
</p>
<p>
If <i>pos</i> is NULL, the new element will be attached to the end of the
list.
</p>
<p>
If <i>key</i> is not NULL, the element will be additionally engaged
into the lists hash table.
</p>
<p>
If <i>src</i> is NULL, a zero-initialized element is inserted into the list for
further processing.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_iter">plist_iter</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_iter( plist* list, plistelfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates over <i>list</i>.
</p>
<p>
Iterates over all items of <i>list</i> and calls the function <i>callback</i> on
every item. The callback function receives the plistel-element pointer of
the list element.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_iter_access">plist_iter_access</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_iter_access( plist* list, plistfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates over <i>list</i> and accesses every item.
</p>
<p>
Iterates over all items of <i>list</i> and calls the function <i>callback</i> on
every item's access. The callback function receives a pointer to the accessed
element.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_key">plist_key</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* plist_key( plistel* e )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access key-content of the current element <i>e</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_last">plist_last</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_last( plist* l )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return last element of list <i>l</i>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_malloc">plist_malloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* plist_malloc( plist* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Allocates memory for a new element in list <i>list</i>, push it to the end and
return the pointer to this.
</p>
<p>
The function works as a shortcut for <a href="#fn_plist_access">plist_access()</a> in combination with <a href="#fn_plist_push">plist_push()</a>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_next">plist_next</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_next( plistel* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access next element of current unit <i>u</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_offset">plist_offset</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_offset( plistel* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return the offset of the unit <i>u</i> within the list it belongs to.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_plist_pop">plist_pop</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_pop( plist* list, void* dest )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Pop last element to <i>dest</i> off the list <i>list</i>.
</p>
<p>
Like <i>list</i> would be a stack, the last element of the list is poppend and
its content is written to <i>dest</i>, if provided at the end of the list.
</p>
<p>
<i>dest</i> can be omitted and given as (void*)NULL, so the last element will
be popped off the list and discards.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_prev">plist_prev</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_prev( plistel* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access previous element of a current unit <i>u</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_push">plist_push</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_push( plist* list, void* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Push <i>src</i> to end of <i>list</i>.
</p>
<p>
Like <i>list</i> would be a stack, <i>src</i> is pushed at the end of the list.
This function can only be used for linked lists without the hash-table feature
in use.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_plist_remove">plist_remove</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_remove( plist* list, plistel* e )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes the element <i>e</i> from the the <i>list</i> and frees it or puts
it into the unused element chain if PLIST_MOD_RECYCLE is flagged.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_rget">plist_rget</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_rget( plist* list, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list element by its index from the end.
</p>
<p>
The function returns the <i>n</i>th element of the list <i>list</i>
from the right.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_riter">plist_riter</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_riter( plist* list, plistelfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates backwards over <i>list</i>.
</p>
<p>
Backwardly iterates over all items of <i>list</i> and calls the function
<i>callback</i> on every item. The callback function receives the plistel-element
pointer of the list element.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_riter_access">plist_riter_access</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_riter_access( plist* list, plistfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates backwards over <i>list</i>.
</p>
<p>
Backwardly iterates over all items of <i>list</i> and calls the function
<i>callback</i> on every  item's access. The callback function receives a pointer
to the accessed element.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_rmalloc">plist_rmalloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* plist_rmalloc( plist* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Allocates memory for a new element in list <i>list</i>, shift it at the begin
and return the pointer to this.
</p>
<p>
The function works as a shortcut for <a href="#fn_plist_access">plist_access()</a> in combination with <a href="#fn_plist_shift">plist_shift()</a>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_set_comparefn">plist_set_comparefn</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_set_comparefn( plist* list, int (*comparefn)( plist*, plistel*, plistel* ) )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Set compare function
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_set_printfn">plist_set_printfn</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_set_printfn( plist* list, void (*printfn)( plist* ) )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Set an element dump function.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_set_sortfn">plist_set_sortfn</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_set_sortfn( plist* list, int (*sortfn)( plist*, plistel*, plistel* ) )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Set sort function
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_shift">plist_shift</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_shift( plist* list, void* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Shift <i>src</i> at begin of <i>list</i>.
</p>
<p>
Like <i>list</i> would be a queue, <i>src</i> is shifted at the begin of the list.
This function can only be used for linked lists without the hash-table feature
in use.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_size">plist_size</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_size( plist* l )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return element size of list <i>l</i>.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_plist_sort">plist_sort</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_sort( plist* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sorts <i>list</i> according to the sort-function that was set for the list.
</p>
<p>
To sort only parts of a list, use <a href="#fn_plist_subsort">plist_subsort()</a>.
</p>
<p>
The sort-function can be modified by using <a href="#fn_plist_set_sortfn">plist_set_sortfn()</a>.
The default sort function sorts the list by they contents, internally by using
the <a href="#fn_memcmp">memcmp()</a> standard function.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_plist_subsort">plist_subsort</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_subsort( plist* list, plistel* from, plistel* to )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sorts <i>list</i> between the elements <i>from</i> and <i>to</i> according to the
sort-function that was set for the list.
</p>
<p>
To sort the entire list, use <a href="#fn_plist_sort">plist_sort()</a>.
</p>
<p>
The sort-function can be modified by using <a href="#fn_plist_set_sortfn">plist_set_sortfn()</a>.
The default sort function sorts the list by they contents, internally by using
the <a href="#fn_memcmp">memcmp()</a> standard function.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_swap">plist_swap</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_swap( plistel* a, plistel* b )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Swaps the positions of the list elemements <i>a</i> and <i>b</i> with each
other. The elements must be in the same plist object, else the function
returns with FALSE.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_plist_union">plist_union</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_union( plist* all, plist* from )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Unions elements from list <i>from</i> into list <i>all</i>.
</p>
<p>
An element is only added to <i>all</i>, if there exists no other
element with the same size and content.
</p>
<p>
The function will not run if both lists have different element size settings.
</p>
<p>
The function returns the number of elements added to <i>from</i>.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_plist_unshift">plist_unshift</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_unshift( plist* list, void* dest )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Take first element to <i>dest</i> from the list <i>list</i>.
</p>
<p>
Like <i>list</i> would be a queue, the first element of the list is taken and
its content is written to <i>dest</i>.
</p>
<p>
<i>dest</i> can be omitted and given as (void*)NULL, so the first element will
be taken from the list and discards.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_pmalloc">pmalloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* pmalloc( size_t size )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamically allocate heap memory.
</p>
<p>
The function is a wrapper for the system function <a href="#fn_malloc">malloc()</a>, but with memory
initialization to zero, and immediatelly stops the program if no more memory
can be allocated.
</p>
<p>
<i>size</i> is the size of memory to be allocated, in bytes.
</p>
<p>
The function returns the allocated heap memory pointer. The returned memory
address should be freed using <a href="#fn_pfree">pfree()</a> after it is not required anymore.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pmemdup">pmemdup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* pmemdup( void* ptr, size_t size )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicates a memory entry onto the heap.
</p>
<p>
<i>ptr</i> is the pointer to the memory to be duplicated.
<i>size</i> is the size of pointer's data storage.
</p>
<p>
Returns the new pointer to the memory copy. This should be casted back to the
type of <i>ptr</i> again.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_dump">pp_ast_dump</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pp_ast_dump( FILE* stream, ppast* ast )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dump detailed <i>ast</i> to <i>stream</i>.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_dump_json">pp_ast_dump_json</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pp_ast_dump_json( FILE* stream, ppast* ast )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dump <i>ast</i> to <i>stream</i> as JSON-formatted string.
</p>
<p>
Only opening matches are printed.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_dump_pvm">pp_ast_dump_pvm</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pp_ast_dump_pvm( pvmprog* prog, ppast* ast )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dump <i>ast</i> into pvm program
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_dump_short">pp_ast_dump_short</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pp_ast_dump_short( FILE* stream, ppast* ast )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dump simplified <i>ast</i> to <i>stream</i>.
</p>
<p>
Only opening matches are printed.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_dump_tree2svg">pp_ast_dump_tree2svg</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pp_ast_dump_tree2svg( FILE* stream, ppast* ast )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dump <i>ast</i> in notation for the tree2svg tool that generates a
graphical view of the parse tree.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_eval">pp_ast_eval</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pp_ast_eval( ppast* ast, pastevalfn func )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Evaluate <i>ast</i> using evaluation function <i>func</i>.
</p>
<p>
The evaluation function has the prototype
</p>

<pre><code class="language-c">
void (*pastevalfn)( ppasteval type, ppast* node )
</code></pre>

<p>
and retrieves a <i>type</i> regarding the position where the evaluation currently
is positioned, and the node pointer.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_free">pp_ast_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppast* pp_ast_free( ppast* node )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees entire <i>ast</i> structure and subsequent links.
</p>
<p>
Always returns (ppast*)NULL.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_get">pp_ast_get</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppast* pp_ast_get( ppast* node, int n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <i>n</i>th element of <i>node</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_len">pp_ast_len</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pp_ast_len( ppast* node )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns length of <i>node</i> chain.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_ast_select">pp_ast_select</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppast* pp_ast_select( ppast* node, char* emit, int n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <i>n</i>th element matching emit <i>emit</i> starting at <i>node</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_gram_create">pp_gram_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppgram* pp_gram_create( void )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates a new ppgram-object.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_gram_free">pp_gram_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppgram* pp_gram_free( ppgram* g )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees grammar <i>g</i> and all its related memory.
</div>
<!-- NEED 32 -->
<div class='function'>
</p>

<h3 id="fn_pp_gram_from_bnf">pp_gram_from_bnf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pp_gram_from_bnf( ppgram* g, char* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Compiles a Backus-Naur-Format definition into a grammar.
</p>
<p>
<i>g</i> is the grammar that receives the result of the parse.
This grammar is extended to new definitions when it already contains symbols.
</p>
<p>
<i>src</i> is the BNF definition string that defines the grammar.
</p>
<p>
The function returns TRUE in case the grammar could be compiled,
FALSE otherwise.
</p>
<p>
<b>Grammar:</b>
</p>

<pre><code class="language-c">
symbol : Terminal | Nonterminal ;
sequence : sequence symbol | symbol ;
production : sequence | ;
alternation : alternation '|' production | production ;

nonterm : Nonterminal ':' alternation ';';
defs : defs nonterm | nonterm ;

grammar$ : defs ;
</code></pre>

</div>
<!-- NEED 33 -->
<div class='function'>

<h3 id="fn_pp_gram_from_ebnf">pp_gram_from_ebnf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pp_gram_from_ebnf( ppgram* g, char* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Compiles an Extended Backus-Naur-Format definition into a grammar.
</p>
<p>
<i>g</i> is the grammar that receives the result of the parse.
This grammar is extended to new definitions when it already contains symbols.
</p>
<p>
<i>src</i> is the EBNF definition string that defines the grammar.
</p>
<p>
The function returns TRUE in case the grammar could be compiled,
FALSE otherwise.
</p>
<p>
<b>Grammar:</b>
</p>

<pre><code class="language-c">
symbol : '(' alternation ')' | Terminal | Nonterminal ;
modifier : symbol | symbol '*' | symbol '+' | symbol '?' ;
sequence : sequence modifier | modifier ;
production : sequence | ;
alternation : alternation '|' production | production ;

nonterm : Nonterminal ':' alternation ';';
defs : defs nonterm | nonterm ;

grammar$ : defs ;
</code></pre>

</div>
<!-- NEED 77 -->
<div class='function'>

<h3 id="fn_pp_gram_from_pbnf">pp_gram_from_pbnf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pp_gram_from_pbnf( ppgram* g, char* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Compiles an Phorward Backus-Naur-Format definition into a parser.
</p>
<p>
<i>p</i> is the parser that receives the result of the parse.
</p>
<p>
In difference to <a href="#fn_pp_gram_from_bnf">pp_gram_from_bnf()</a> and <a href="#fn_pp_gram_from_ebnf">pp_gram_from_ebnf()</a>, <a href="#fn_pp_par_from_pbnf">pp_par_from_pbnf()</a> allows for a full-fledged parser definition with
lexical analyzer-specific definitions, grammar and AST construction features.
</p>
<p>
<b>Grammar:</b>
</p>

<pre><code class="language-c">
// Whitespace ------------------------------------------------------------------

%skip			/[ \t\r\n]+/ ;
%skip			/\/\/[^\n]*/n/ ;
%skip			/\//*([^*]|/*[^\/])*/*/// ;

// Terminals -------------------------------------------------------------------

[Terminal #fn_Terminal]		/[A-Z][A-Za-z0-9_]*/ ;
[Nonterminal #fn_Nonterminal]	/[a-z_][A-Za-z0-9_]*/ ;

[CCL #fn_CCL] 			/\[(\\.|[^\\\]])*/]/ ;
[String #fn_String] 		/'[^']*'/ ;
[Token #fn_Token]			/"[^"]*"/ ;
[Regex #fn_Regex] 			/\/(\\.|[^\\\/])*/// ;

[Int #fn_Int]			/[0-9]+/ ;
[Function #fn_Function]		/[A-Za-z_][A-Za-z0-9_]*/(\)/ ;

[Flag_emit #fn_Flag_emit]		'@([A-Za-z0-9_]+)?' ;
[Flag_goal #fn_Flag_goal]		'$' ;
[Flag_lexem #fn_Flag_lexem]		'!' ;
[Flag_ignore #fn_Flag_ignore]	/%(ignore|skip)/ ;

// Nonterminals ----------------------------------------------------------------

[inline #fn_inline]			: Flag_emit '(' alternation ')'
				|  '(' alternation ')'
				;

[symbol #fn_symbol] 		: Terminal | Nonterminal | CCL | String | Token
					| Regex | Function | inline ;

modifier		: ( symbol '*' )=kle
				| ( symbol '+' )=pos
				| ( symbol '?' )=opt
				| symbol
				;

sequence		: sequence modifier | modifier ;

[production #fn_production]	 	: sequence | ;

alternation		: alternation '|' production | production ;

[nontermdef #fn_nontermdef]		: Nonterminal ':' alternation ';'
				;

[termdef #fn_termdef]		: Terminal ':' ( CCL | String | Regex | Function ) ';'
				;

definition		: nontermdef
				| termdef
				;

grammar	$		: definition+ ;
</code></pre>

</div>
<!-- NEED 22 -->
<div class='function'>

<h3 id="fn_pp_gram_prepare">pp_gram_prepare</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pp_gram_prepare( ppgram* g )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Prepares the grammar <i>g</i> by computing all necessary stuff required for
runtime and parser generator.
</p>
<p>
The preparation process includes:
</p>

<ul>
<li>Setting up final symbol and productions IDs
</li>
<li>Nonterminals FIRST-set computation
</li>
<li>Marking of left-recursions
</li>
<li>The 'lexem'-flag pull-through the grammar.
</li>
</ul>

<p>
This function is only run internally.
Don't call it if you're unsure ;)...
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_gram_to_str">pp_gram_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pp_gram_to_str( ppgram* grm )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Get grammar string representation
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_lr_build">pp_lr_build</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pp_lr_build( unsigned int* cnt, unsigned int*** dfa, ppgram* grm )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Build parse tables
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_pp_par_autolex">pp_par_autolex</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pp_par_autolex( pppar* p )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Automatically generate lexical analysis for terminal symbols which
have not been defined with <a href="#fn_pp_par_lex">pp_par_lex()</a>.
</p>
<p>
Returns the number of inserted tokens on success.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pp_par_create">pp_par_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pppar* pp_par_create( ppgram* g )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates a new parser object with the underlying grammar <i>g</i>.
</p>
<p>
The grammar must either be parsed first via one of the BNF parsers
 <a href="#fn_pp_gram_from_pbnf">pp_gram_from_pbnf()</a>, <a href="#fn_pp_gram_from_ebnf">pp_gram_from_ebnf()</a>, <a href="#fn_pp_gram_from_bnf">pp_gram_from_bnf()</a>) or it
must be hand-crafted.
</p>
<p>
The provided grammar gets "frozen" when a parser is created from it.
Modifications on the grammar with a parser based on an older grammar state may
cause memory corruption and crashes.
</p>
<p>
The function returns a valid parser object on success, or (pppar*)NULL in case
the grammar is invalid.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_par_free">pp_par_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pppar* pp_par_free( pppar* p )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees the parser object <i>par</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pp_par_lex">pp_par_lex</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pp_par_lex( pppar* p, ppsym* sym, char* pat, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Defines a lexical matcher for <i>sym</i> in parser <i>p</i> from a
regular expression. <i>sym</i> must be a terminal symbol.
</p>
<p>
Returns TRUE on success, FALSE if the symbol already was defined as a lexing
token.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pp_par_parse">pp_par_parse</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pp_par_parse( ppast** root, pppar* par, char* start )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Run parser <i>p</i> with input <i>start</i>.
</p>
<p>
Currently, the used parsing method is only LALR(1).
</p>
<p>
It returns an abstract syntax tree to <i>root</i> on success.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_prod_append">pp_prod_append</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pp_prod_append( ppprod* p, ppsym* sym )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends the symbol <i>sym</i> to the right-hand-side of production <i>p</i>.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_pp_prod_create">pp_prod_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppprod* pp_prod_create( ppgram* g, ppsym* lhs, ... )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates a new production on left-hand-side <i>lhs</i>
within the grammar <i>g</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_prod_free">pp_prod_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppprod* pp_prod_free( ppprod* p )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees the production object <i>p</i> and releases any used memory.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_pp_prod_get">pp_prod_get</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppprod* pp_prod_get( ppgram* g, int n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Get the <i>n</i>th production from grammar <i>g</i>.
Returns (ppprod*)NULL if no symbol was found.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_pp_prod_getfromrhs">pp_prod_getfromrhs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_prod_getfromrhs( ppprod* p, int off )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the <i>off</i>s element from the right-hand-side of
production <i>p</i>. Returns (ppsym*)NULL if the requested element does
not exist.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_pp_prod_remove">pp_prod_remove</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pp_prod_remove( ppprod* p, ppsym* sym )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes all occurences of symbol <i>sym</i> from the right-hand-side of
production <i>p</i>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_pp_prod_to_str">pp_prod_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pp_prod_to_str( ppprod* p )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the string representation of production <i>p</i>.
</p>
<p>
The returned pointer is part of <i>p</i> and can be referenced multiple times.
It may not be freed by the caller.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_create">pp_sym_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_sym_create( ppgram* g, char* name, unsigned int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates a new symbol in the grammar <i>g</i>.
</p>
<p>
<i>name</i> is the unique name for the symbol. It can be left empty,
configuring the symbol as an unnamed symbol.
</p>
<p>
<i>flags</i> can be a combination of PPFLAG_-flags related to the symbol's
configuration.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_drop">pp_sym_drop</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_sym_drop( ppsym* sym )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes a symbol from its grammar.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_free">pp_sym_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_sym_free( ppsym* sym )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees a symbol.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_get">pp_sym_get</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_sym_get( ppgram* g, unsigned int n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Get the <i>n</i>th symbol from grammar <i>g</i>.
Returns (ppsym*)NULL if no symbol was found.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_get_by_name">pp_sym_get_by_name</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_sym_get_by_name( ppgram* g, char* name )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Get a symbol from grammar <i>g</i> by its <i>name</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_get_nameless_term_by_def">pp_sym_get_nameless_term_by_def</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_sym_get_nameless_term_by_def( ppgram* g, char* name )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Find a nameless terminal symbol by its pattern.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_getprod">pp_sym_getprod</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppprod* pp_sym_getprod( ppsym* sym, unsigned int n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Get the <i>n</i>th production from symbol <i>sym</i>.
<i>sym</i> must be a nonterminal.
</p>
<p>
Returns (ppprod*)NULL if the production is not found or the symbol is
configured differently.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_mod_kleene">pp_sym_mod_kleene</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_sym_mod_kleene( ppsym* sym )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs an optional positive ("kleene") closure from <i>sym</i>.
</p>
<p>
This helper function constructs the productions and symbol
</p>

<pre><code class="language-c">
pos_sym: sym pos_sym | sym ;
opt_sym: pos_sym | ;
</code></pre>

<p>
from <i>sym</i>, and returns the symbol <i>opt_sym</i>. If any of the given symbols
already exists, they are directly used. The function is a shortcut for a call
</p>

<pre><code class="language-c">
pp_sym_mod_optional( pp_sym_mod_positive( sym ) )
</code></pre>

</div>
<!-- NEED 18 -->
<div class='function'>

<h3 id="fn_pp_sym_mod_optional">pp_sym_mod_optional</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_sym_mod_optional( ppsym* sym )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs an optional closure from <i>sym</i>.
</p>
<p>
This helper function constructs the productions and symbol
</p>

<pre><code class="language-c">
opt_sym: sym | ;
</code></pre>

<p>
from <i>sym</i>, and returns the symbol <i>pos_sym</i>. If <i>opt_sym</i> already exists,
the symbol will be returned without any creation.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_mod_positive">pp_sym_mod_positive</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
ppsym* pp_sym_mod_positive( ppsym* sym )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs a positive closure from <i>sym</i>.
</p>
<p>
This helper function constructs the productions and symbol
</p>

<pre><code class="language-c">
pos_sym: sym pos_sym | sym ;
</code></pre>

<p>
from <i>sym</i>, and returns the symbol <i>pos_sym</i>. If <i>pos_sym</i> already exists,
the symbol will be returned without any creation.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pp_sym_to_str">pp_sym_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pp_sym_to_str( ppsym* sym )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the string representation of symbol <i>sym</i>.
</p>
<p>
Nonterminals are not expanded, they are just returned as their name.
The returned pointer is part of <i>sym</i> and can be referenced multiple
times. It may not be freed by the caller.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_prealloc">prealloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* prealloc( void* oldptr, size_t size )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamically (re)allocate memory on the heap.
</p>
<p>
The function is a wrapper to the system-function <a href="#fn_realloc">realloc()</a>, but always
accepts a NULL-pointer and immediatelly stops the program if no more memory
can be allocated.
</p>
<p>
<i>oldptr</i> is the pointer to be reallocated. If this is (void*)NULL, <a href="#fn_prealloc">prealloc()</a> works like a normal call to <a href="#fn_pmalloc">pmalloc()</a>.
</p>
<p>
<i>size</i> is the size of memory to be reallocated, in bytes.
</p>
<p>
The function returns the allocated heap memory pointer. The returned memory
address should be freed using <a href="#fn_pfree">pfree()</a> after it is not required anymore.
</div>
<!-- NEED 32 -->
<div class='function'>
</p>

<h3 id="fn_pregex_create">pregex_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex* pregex_create( char* pat, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructor function to create a new pregex object.
</p>
<p>
<i>pat</i> is a string providing a regular expression pattern.
<i>flags</i> can be a combination of compile- and runtime-flags.
</p>

<table border="1">
<tr>
<th>Flag</th>
<th>Usage</th>
</tr>
<tr>
<td>PREGEX_COMP_WCHAR</td>
<td>The regular expression <i>pat</i> is provided as wchar_t.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOANCHORS</td>
<td>Ignore anchor tokens, handle them as normal characters</td>
</tr>
<tr>
<td>PREGEX_COMP_NOREF</td>
<td>Don't compile references.</td>
</tr>
<tr>
<td>PREGEX_COMP_NONGREEDY</td>
<td>Compile regex to be forced non-greedy.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOERRORS</td>
<td>Don't report errors, and try to compile as much as possible</td>
</tr>
<tr>
<td>PREGEX_COMP_INSENSITIVE</td>
<td>Parse regular expression as case insensitive.</td>
</tr>
<tr>
<td>PREGEX_COMP_STATIC</td>
<td>The regular expression passed should be converted 1:1 asit where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped.</td>
</tr>
<tr>
<td>PREGEX_RUN_WCHAR</td>
<td>Run regular expression with wchar_t as input.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOANCHORS</td>
<td>Ignore anchors while processing the regex.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOREF</td>
<td>Don't create references.</td>
</tr>
<tr>
<td>PREGEX_RUN_NONGREEDY</td>
<td>Force run regular expression non-greedy.</td>
</tr>
<tr>
<td>PREGEX_RUN_DEBUG</td>
<td>Debug mode; output some debug to stderr.</td>
</tr>
</table>

<p>
On success, the function returns the allocated pointer to a pregex-object.
This must be freed later using <a href="#fn_pregex_free">pregex_free()</a>.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pregex_find">pregex_find</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pregex_find( pregex* regex, char* start, char** end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Find a match for the regular expression <i>regex</i> from begin of pointer
<i>start</i>.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).
</p>
<p>
If the expression can be matched, the function returns the pointer to the
position where the match begins. <i>end</i> receives the end pointer of the match,
when provided.
</p>
<p>
The function returns (char*)NULL in case that there is no match.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_pregex_findall">pregex_findall</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pregex_findall( pregex* regex, char* start, parray** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Find all matches for the regular expression <i>regex</i> from begin of pointer
<i>start</i>, and optionally return matches as an array.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).
</p>
<p>
The function fills the array <i>matches</i>, if provided, with items of size
prange. It returns the total number of matches.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pregex_free">pregex_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex* pregex_free( pregex* regex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Destructor function for a pregex-object.
</p>
<p>
<i>regex</i> is the pointer to a pregex-structure that will be released.
</p>
<p>
Returns always (pregex*)NULL.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_pregex_match">pregex_match</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pregex_match( pregex* regex, char* start, char** end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tries to match the regular expression <i>regex</i> at pointer <i>start</i>.
</p>
<p>
If the expression can be matched, the function returns TRUE and <i>end</i> receives
the pointer to the last matched character.
</div>
<!-- NEED 27 -->
<div class='function'>
</p>

<h3 id="fn_pregex_qmatch">pregex_qmatch</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pregex_qmatch( char* regex, char* str, int flags, parray** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs a regular expression match on a string, and returns an array of
matches via prange-structures, which hold pointers to the begin- and
end-addresses of all matches.
</p>
<p>
<i>regex</i> is the regular expression pattern to be processed.
</p>
<p>
<i>str</i> is the string on which the pattern will be executed on.
</p>
<p>
<i>flags</i> are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).
</p>
<p>
<i>matches</i> is the array of results to the matched substrings within <i>str</i>,
provided as parray-object existing of one prange-object for every match.
It is optional. <i>matches</i> must be released with <a href="#fn_parray_free">parray_free()</a> after its usage.
</p>
<p>
Returns the number of matches, which is the amount of result entries in the
returned array <i>matches</i>. If the value is negative, an error occured.
</div>
<!-- NEED 27 -->
<div class='function'>
</p>

<h3 id="fn_pregex_qreplace">pregex_qreplace</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pregex_qreplace( char* regex, char* str, char* replace, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Replaces all matches of a regular expression pattern within a string with
the replacement. Backreferences can be used with <code>$x</code> for each opening bracket
within the regular expression.
</p>
<p>
<i>regex</i> is the regular expression pattern to be processed.
</p>
<p>
<i>str</i> is the string on which the pattern will be executed on.
</p>
<p>
<i>replace</i> is the string that will be inserted as replacement for each pattern
match. <code>$x</code> back-references can be used.
</p>
<p>
<i>flags</i> are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).
</p>
<p>
Returns an allocated pointer to the generated string with the replacements.
This string must be released after its existence is no longer required by the
caller using <a href="#fn_pfree">pfree()</a>.
</div>
<!-- NEED 26 -->
<div class='function'>
</p>

<h3 id="fn_pregex_qsplit">pregex_qsplit</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pregex_qsplit( char* regex, char* str, int flags, parray** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs a regular expression search on a string and uses the expression as
separator; All strings that where split are returned as <i>matches</i>-array.
</p>
<p>
<i>regex</i> is the regular expression pattern to be processed.
</p>
<p>
<i>str</i> is the string on which the pattern will be executed on.
</p>
<p>
<i>flags</i> are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).
</p>
<p>
<i>matches</i> is the array of results to the matched substrings within <i>str</i>,
provided as parray-object existing of one prange-object for every match.
It is optional. <i>matches</i> must be released with <a href="#fn_parray_free">parray_free()</a> after its usage.
</p>
<p>
Returns the number of split substrings, which is the amount of result entries in
the returned array <i>matches</i>. If the value is negative, an error occured.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_pregex_replace">pregex_replace</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pregex_replace( pregex* regex, char* str, char* replacement )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Replaces all matches of a regular expression object within a string <i>str</i>
with <i>replacement</i>. Backreferences in <i>replacement</i> can be used with <i>$x</i>
for each opening bracket within the regular expression.
</p>
<p>
<i>regex</i> is the pregex-object used for pattern matching.
<i>str</i> is the string on which <i>regex</i> will be executed.
<i>replacement</i> is the string that will be inserted as the replacement for each
match of a pattern described in <i>regex</i>. The notation <i>$x</i> can be used for
backreferences, where x is the offset of opening brackets in the pattern,
beginning at 1.
</p>
<p>
The function returns the string with the replaced elements, or (char*)NULL
in error case.
</div>
<!-- NEED 24 -->
<div class='function'>
</p>

<h3 id="fn_pregex_split">pregex_split</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pregex_split( pregex* regex, char* start, char** end, char** next )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the range between string <i>start</i> and the next match of <i>regex</i>.
</p>
<p>
This function can be seen as a "negative match", so the substrings that are
not part of the match will be returned.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).
<i>end</i> receives the last position of the string before the regex.
<i>next</i> receives the pointer of the next split element behind the matched
substring, so <i>next</i> should become the next <i>start</i> when <a href="#fn_pregex_split">pregex_split()</a> is
called in a loop.
</p>
<p>
The function returns (char*)NULL in case that there is no more string to split,
else it returns <i>start</i>.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pregex_splitall">pregex_splitall</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pregex_splitall( pregex* regex, char* start, parray** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Split a string at all matches of the regular expression <i>regex</i> from
begin of pointer <i>start</i>, and optionally return the splitted matches as an
array.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).
</p>
<p>
The function fills the array <i>matches</i>, if provided, with items of size
prange. It returns the total number of matches.
</div>
<!-- NEED 24 -->
<div class='function'>
</p>

<h3 id="fn_pstr_to_wcs">pstr_to_wcs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pstr_to_wcs( char* str, pboolean freestr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
This functions converts an UTF-8-multi-byte string into an Unicode
wide-character string.
</p>
<p>
The string conversion is performed into dynamically allocated memory.
The function wraps <a href="#fn_mbstowcs">mbstowcs()</a>, so <a href="#fn_set_locale">set_locale()</a> must be done before this
function works properly.
</p>
<p>
<i>str</i> is the zero-terminated multi-byte-character string to be converted
into a wide-character string.
<i>freestr</i> defines if the input-string shall be freed after successfull
conversion, if set to TRUE.
</p>
<p>
Returns the wide-character pendant of <i>str</i> as pointer to dynamically
allocated memory.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pstrcasecmp">pstrcasecmp</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pstrcasecmp( char* s1, char* s2 )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Compare a string by ignoring case-order.
</p>
<p>
<i>s1</i> is the string to compare with <i>s2</i>.
<i>s2</i> is the string to compare with <i>s1</i>.
</p>
<p>
Returns 0 if both strings are equal. Returns a value &lt;0 if <i>s1</i> is lower than
<i>s2</i> or a value &gt;0 if <i>s1</i> is greater than <i>s2</i>.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pstrcatchar">pstrcatchar</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrcatchar( char* str, char chr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamically appends a character to a string.
</p>
<p>
<i>str</i> is the pointer to a string to be appended. If this is (char*)NULL,
the string will be newly allocated. <i>chr</i> is the the character to be appended
to str.
</p>
<p>
Returns a char*-pointer to the (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated. This pointer must
be released with <a href="#fn_pfree">pfree()</a> when its existence is no longer required.
</div>
<!-- NEED 24 -->
<div class='function'>
</p>

<h3 id="fn_pstrcatstr">pstrcatstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrcatstr( char* dest, char* src, pboolean freesrc )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamically appends a zero-terminated string to a dynamic string.
</p>
<p>
<i>str</i> is the pointer to a zero-terminated string to be appended.
If this is (char*)NULL, the string is newly allocated.
</p>
<p>
<i>append</i> is the string to be appended at the end of <i>str</i>.
</p>
<p>
<i>freesrc</i> frees the pointer provided as <i>append</i> automatically by
this function, if set to TRUE. This parameter has only a comfort-function.
</p>
<p>
Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL. If <i>dest</i> is NULL and <i>freesrc</i> is FALSE, the function
automatically returns the pointer <i>src</i>. This pointer must be released with <a href="#fn_pfree">pfree()</a> when its existence is no longer required.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pstrdup">pstrdup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrdup( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate a string in memory.
</p>
<p>
<i>str</i> is the string to be copied in memory. If <i>str</i> is provided as NULL,
the function will also return NULL.
</p>
<p>
Returns a char*-pointer to the newly allocated copy of <i>str</i>. This pointer
must be released with <a href="#fn_pfree">pfree()</a> when its existence is no longer required.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_pstrget">pstrget</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrget( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Savely reads a string.
</p>
<p>
<i>str</i> is the string pointer to be savely read. If <i>str</i> is NULL, the
function returns a pointer to a static address holding an empty string.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pstrlen">pstrlen</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t pstrlen( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return length of a string.
</p>
<p>
<i>str</i> is the parameter string to be evaluated. If (char*)NULL, the function
returns 0. <a href="#fn_pstrlen">pstrlen()</a> is much more saver than <a href="#fn_strlen">strlen()</a> because it returns 0 when
a NULL-pointer is provided.
</p>
<p>
Returns the length of the string <i>str</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pstrltrim">pstrltrim</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrltrim( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes whitespace on the left of a string.
</p>
<p>
<i>s</i> is the string to be left-trimmed.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pstrlwr">pstrlwr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrlwr( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Convert a string to lower-case order.
</p>
<p>
<i>s</i> is the acts both as input and output-string.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_pstrncasecmp">pstrncasecmp</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pstrncasecmp( char* s1, char* s2, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Compare a string by ignoring case-order about a maximum of <i>n</i> bytes.
</p>
<p>
<i>s1</i> is the string to compare with <i>s2</i>.
<i>s2</i> is the string to compare with <i>s1</i>.
<i>n</i> is the number of bytes to compare.
</p>
<p>
Returns 0 if both strings are equal. Returns a value &lt;0 if <i>s1</i> is lower than
<i>s2</i> or a value &gt;0 if <i>s1</i> is greater than <i>s2</i>.
</div>
<!-- NEED 24 -->
<div class='function'>
</p>

<h3 id="fn_pstrncatstr">pstrncatstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrncatstr( char* str, char* append, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamicaly appends a number of n-characters from one string to another
string.
</p>
<p>
The function works similar to <a href="#fn_pstrcatstr">pstrcatstr()</a>, but allows to copy only a maximum
of <i>n</i> characters from <i>append</i>.
</p>
<p>
<i>str</i> is the pointer to a string to be appended. If this is (char*)NULL,
the string is newly allocated. <i>append</i> is the begin of character sequence to
be appended. <i>n</i> is the number of characters to be appended to <i>str</i>.
</p>
<p>
Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL. This pointer must be released with <a href="#fn_pfree">pfree()</a> when its existence
is no longer required.
</div>
<!-- NEED 24 -->
<div class='function'>
</p>

<h3 id="fn_pstrndup">pstrndup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrndup( char* str, size_t len )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate <i>n</i> characters from a string in memory.
</p>
<p>
The function mixes the functionalities of <a href="#fn_strdup">strdup()</a> and <a href="#fn_strncpy">strncpy()</a>.
The resulting string will be zero-terminated.
</p>
<p>
<i>str</i> is the parameter string to be duplicated. If this is provided as
(char*)NULL, the function will also return (char*)NULL.
<i>n</i> is the the number of characters to be copied and duplicated from <i>str</i>.
If <i>n</i> is greater than the length of <i>str</i>, copying will stop at the zero
terminator.
</p>
<p>
Returns a char*-pointer to the allocated memory holding the zero-terminated
string duplicate. This pointer must be released with <a href="#fn_pfree">pfree()</a> when its existence
is no longer required.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_pstrput">pstrput</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrput( char** str, char* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Assign a string into a dynamically allocated pointer.
 <a href="#fn_pstrput">pstrput()</a> manages the assignment of an dynamically allocated string.
</p>
<p>
<i>str</i> is a pointer receiving the target pointer to be (re)allocated. If
<i>str</i> already references a string, this pointer will be freed and reassigned
to a copy of <i>val</i>.
</p>
<p>
<i>val</i> is the the string to be assigned to <i>str</i> (as a independent copy).
</p>
<p>
Returns a pointer to the allocated heap memory on success, (char*)NULL else.
This is the same pointer as returned like calling <code>*str</code>. The returned pointer
must be released with <a href="#fn_pfree">pfree()</a> or another call of <a href="#fn_pstrput">pstrput()</a>. Calling <a href="#fn_pstrput">pstrput()</a>
as <code>pstrput( &amp;p, (char*)NULL );</code> is equivalent to <code>p = pfree( &amp;p )</code>.
</div>
<!-- NEED 29 -->
<div class='function'>
</p>

<h3 id="fn_pstrrender">pstrrender</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrrender( char* tpl, ... )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
String rendering function.
</p>
<p>
Inserts multiple values dynamically into the according wildcards positions of
a template string. The function can be compared to the function of <a href="#fn_pstrreplace">pstrreplace()</a>, but allows to replace multiple substrings by multiple replacement
strings.
</p>
<p>
<i>tpl</i> is the template string to be rendered with values.
<i>...</i> are the set of values to be inserted into the desired position;
</p>
<p>
These consist of three values each:
</p>

<ul>
<li><i>char* name</i> as a wildcard-name
</li>
<li><i>char* value</i> as the replacement value for the wildcard
</li>
<li><i>pboolean freeflag</i> defines if <i>value</i> shall be freed after processing
</li>
</ul>

<p>
Returns an allocated string which is the resulting source. This string must be
release by <a href="#fn_pfree">pfree()</a> or another function releasing heap memory when its existence
is no longer required.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pstrreplace">pstrreplace</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrreplace( char* str, char* find, char* replace )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Replace a substring sequence within a string.
</p>
<p>
<i>str</i> is the string to be replaced in. <i>find</i> is the substring to be
matched. <i>replace</i> is the the string to be inserted for each match of the
substring <i>find</i>.
</p>
<p>
Returns a pointer to char* containing the allocated string which is the
resulting source. This pointer must be released with <a href="#fn_pfree">pfree()</a> when its existence
is no longer required.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pstrrtrim">pstrrtrim</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrrtrim( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes trailing whitespace on the right of a string.
</p>
<p>
<i>s</i> is the string to be right-trimmed.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pstrsplit">pstrsplit</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pstrsplit( char*** tokens, char* str, char* sep, int limit )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Splits a string at a delimiting token and returns an allocated array of
token reference pointers.
</p>
<p>
<i>tokens</i> is the an allocated array of tokenized array values.
Requires a pointer to char**.
<i>str</i> is the input string to be tokenized.
<i>sep</i> is the token separation substring.
<i>limit</i> is the token limit; If set to 0, there is no token limit available, so
that as much as possible tokens are read.
</p>
<p>
Returns the number of separated tokens, or -1 on error.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pstrtrim">pstrtrim</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrtrim( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes beginning and trailing whitespace from a string.
</p>
<p>
<i>s</i> is the string to be trimmed.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 40 -->
<div class='function'>
</p>

<h3 id="fn_pstrunescape">pstrunescape</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrunescape( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a string with included escape-sequences back into its natural form.
</p>
<p>
The following table shows escape sequences which are converted.
</p>

<table border="1">
<tr>
<th>Sequence</th>
<th>is replaced by</th>
</tr>
<tr>
<td>\n</td>
<td>newline</td>
</tr>
<tr>
<td>\t</td>
<td>tabulator</td>
</tr>
<tr>
<td>\r</td>
<td>carriage-return</td>
</tr>
<tr>
<td>\b</td>
<td>backspace</td>
</tr>
<tr>
<td>\f</td>
<td>form feed</td>
</tr>
<tr>
<td>\a</td>
<td>bell / alert</td>
</tr>
<tr>
<td>\'</td>
<td>single-quote</td>
</tr>
<tr>
<td>\"</td>
<td>double-quote</td>
</tr>
</table>

<p>
The replacement is done within the memory bounds of <i>str</i> itself, because the
unescaped version of the character requires lesser space that its previous
escape sequence.
</p>
<p>
The function always returns its input pointer.
</p>
<p>
<b>Example:</b>
</p>

<pre><code class="language-c">
char* s = (char*)NULL;

psetstr( &amp;s, "\\tHello\\nWorld!" );
printf( "&gt;%s&lt;\n", pstrunescape( s ) );

s = pfree( s );
</code></pre>

</div>
<!-- NEED 15 -->
<div class='function'>

<h3 id="fn_pstrupr">pstrupr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrupr( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Convert a string to upper-case order.
</p>
<p>
<i>s</i> is the acts both as input and output-string.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pvasprintf">pvasprintf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pvasprintf( char** str, char* fmt, va_list ap )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Implementation and replacement for vasprintf.
</p>
<p>
<i>str</i> is the pointer receiving the resultung, allocated string pointer.
<i>fmt</i> is the the format string.
<i>...</i> are the parameters according to the placeholders set in <i>fmt</i>.
</p>
<p>
Returns the number of characters written, or -1 in error case.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pvm_create">pvm_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pvm* pvm_create( void )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates a new virtual machine.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_pvm_define">pvm_define</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pvm_define( pvm* vm, char* mn, pvmop op )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Implements mnemonic <i>mn</i> with operational function <i>op</i> into <i>vm</i>.
</p>
<p>
Returns the operation's opcode, or a value &lt; 0 on error.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pvm_free">pvm_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pvm* pvm_free( pvm* vm )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees a virtual machine.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pvm_init">pvm_init</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pvm* pvm_init( pvm* vm )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Initializes the virtual machine <i>vm</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pvm_prog_run">pvm_prog_run</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pvm_prog_run( pany** ret, pvmprog* prog )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Run vm
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pvm_reset">pvm_reset</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pvm* pvm_reset( pvm* vm )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Resets a virtual machine <i>vm</i>.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pwcs_to_str">pwcs_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pwcs_to_str( wchar_t* str, pboolean freestr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
This functions converts a wide-character string into an UTF-8 string.
</p>
<p>
The string conversion is performed into dynamically allocated memory.
The function wraps the system function <a href="#fn_wcstombs">wcstombs()</a>, so <a href="#fn_set_locale">set_locale()</a> must be
called before this function works properly.
</p>
<p>
<i>str</i> is the zero-terminated string to be converted to UTF-8.
<i>freestr</i> defines if the input-string shall be freed after successfull
conversion, if set to TRUE.
</p>
<p>
Returns the UTF-8 character pendant of <i>str</i> as pointer to dynamically
allocated memory.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_pwcscatchar">pwcscatchar</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcscatchar( wchar_t* str, wchar_t chr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends a character to a dynamic wide-character string.
</p>
<p>
<i>str</i> is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated. <i>chr</i> is the the character
to be appended to str.
</p>
<p>
Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pwcscatstr">pwcscatstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcscatstr( wchar_t* dest, wchar_t* src, pboolean freesrc )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends a (possibly dynamic) wide-character string to a dynamic
wide-character string.
</p>
<p>
<i>str</i> is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
<i>append</i> is the the string to be appended.
<i>freesrc</i> if true, <i>append</i> is free'd automatically by this function.
</p>
<p>
Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pwcsdup">pwcsdup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsdup( wchar_t* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate a wide-character string in memory.
</p>
<p>
<i>str</i> is the string to be copied in memory. If <i>str</i> is provided as NULL,
the function will also return NULL.
</p>
<p>
Returns a wchar_t*-pointer to the newly allocated copy of <i>str</i>. This pointer
must be released with <a href="#fn_pfree">pfree()</a> when its existence is no longer required.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_pwcsget">pwcsget</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsget( wchar_t* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Savely reads a wide-character string.
</p>
<p>
<i>str</i> is the string pointer to be savely read. If <i>str</i> is NULL, the
function returns a pointer to a static address holding an empty string.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_pwcslen">pwcslen</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t pwcslen( wchar_t* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Saver strlen replacement for wide-character.
</p>
<p>
<i>str</i> is the parameter string to be evaluated. If (wchar_t*)NULL,
the function returns 0.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pwcsncatstr">pwcsncatstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsncatstr( wchar_t* str, wchar_t* append, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends a number of N characters from one wide-character string to a dynamic
string.
</p>
<p>
<i>str</i> is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
<i>append</i> is the begin of character sequence to be appended.
<i>n</i> is the amount of characters to be appended to str.
</p>
<p>
Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL.
</div>
<!-- NEED 26 -->
<div class='function'>
</p>

<h3 id="fn_pwcsndup">pwcsndup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsndup( wchar_t* str, size_t len )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate <i>n</i> characters from a wide-character string in memory.
</p>
<p>
The function mixes the functionalities of <a href="#fn_wcsdup">wcsdup()</a> and <a href="#fn_wcsncpy">wcsncpy()</a>.
The resulting wide-character string will be zero-terminated.
</p>
<p>
<i>str</i> is the parameter wide-character string to be duplicated.
If this is provided as (wchar_t*)NULL, the function will also return
(wchar_t*)NULL.
</p>
<p>
<i>n</i> is the the number of characters to be copied and duplicated from <i>str</i>.
If <i>n</i> is greater than the length of <i>str</i>, copying will stop at the zero
terminator.
</p>
<p>
Returns a wchar_t*-pointer to the allocated memory holding the zero-terminated
wide-character string duplicate. This pointer must be released with <a href="#fn_pfree">pfree()</a>
when its existence is no longer required.
</div>
<!-- NEED 25 -->
<div class='function'>
</p>

<h3 id="fn_pwcsput">pwcsput</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsput( wchar_t** str, wchar_t* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Assign a wide-character string into a dynamically allocated pointer.
 <a href="#fn_pwcsput">pwcsput()</a> manages the assignment of an dynamically allocated  wide-chararacter
string.
</p>
<p>
<i>str</i> is a pointer receiving the target pointer to be (re)allocated. If
<i>str</i> already references a wide-character string, this pointer will be freed
and reassigned to a copy of <i>val</i>.
</p>
<p>
<i>val</i> is the the wide-character string to be assigned to <i>str</i>
(as a independent copy).
</p>
<p>
Returns a pointer to the allocated heap memory on success, (char_t*)NULL else.
This is the same pointer as returned like calling <code>*str</code>. The returned pointer
must be released with <a href="#fn_pfree">pfree()</a> or another call of <a href="#fn_pwcsput">pwcsput()</a>. Calling <a href="#fn_pwcsput">pwcsput()</a>
as <code>pwcsput( &amp;p, (char*)NULL );</code> is equivalent to <code>p = pfree( &amp;p )</code>.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pwhich">pwhich</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pwhich( char* filename, char* directories )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Figures out a filepath by searching in a PATH definition.
</p>
<p>
<i>filename</i> is the filename to be searched for.
</p>
<p>
<i>directories</i> is a string specifying the directories to search in.
If this is (char*)NULL, the environment variable PATH will be used and
evaluated by using <a href="#fn_getenv">getenv()</a>. The path can be split with multiple pathes
by a character that depends on the current platform (Unix: ":", Windows: ";").
</p>
<p>
Returns a static pointer to the absolute path that contains the file specified
as filename, else it will return (char*)NULL.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_u8_char">u8_char</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t u8_char( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return single character (as wide-character value) from UTF-8 multi-byte
character string.
</p>
<p>
<i>str</i> is the pointer to character sequence begin.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_u8_isutf">u8_isutf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean u8_isutf( unsigned char c )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Check for UTF-8 character sequence signature.
</p>
<p>
The function returns TRUE, if the character <i>c</i> is the beginning of a UTF-8
character signature, else FALSE.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_u8_move">u8_move</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* u8_move( char* str, int count )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Moves <i>count</i> characters ahead in an UTF-8 multi-byte character sequence.
</p>
<p>
<i>str</i> is the pointer to UTF-8 string to begin moving.
<i>count</i> is the number of characters to move left.
</p>
<p>
The function returns the address of the next UTF-8 character sequence after
<i>count</i> characters. If the string's end is reached, it will return a
pointer to the zero-terminator.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_u8_parse_char">u8_parse_char</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t u8_parse_char( char** ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Read one character from an UTF-8 input sequence.
This character can be escaped, an UTF-8 character or an ordinary ASCII-char.
</p>
<p>
<i>chr</i> is the input- and output-pointer (the pointer is replaced by the pointer
to the next character or escape-sequence within the string.
</p>
<p>
The function teturns the character code of the parsed character.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_u8_seqlen">u8_seqlen</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int u8_seqlen(char *s)
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns length of next UTF-8 sequence in a multi-byte character string.
</p>
<p>
<i>s</i> is the pointer to begin of UTF-8 sequence.
</p>
<p>
Returns the number of bytes used for the next character.
</div>
</p>
</div>

<!-- xhtml code generated by txt2tags 2.6. (http://txt2tags.org) -->
<!-- cmdline: txt2tags -o phorward.html -t xhtml -\-toc -\-css-sugar -\-style=phorward.css phorward.t2t -->
</body></html>
