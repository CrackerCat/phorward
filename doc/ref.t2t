


= Macros =
'''
<!-- NEED 20 -->
'''
== PARMS ==[fn_PARMS]

**Definition:**

PARMS( char* param_name, char* format, param_type parameter ) - //Macro//

**Usage:**

Write parameter content to trace.

The PARMS-macro is used to write parameter names and values to the program
trace. [PARMS() #fn_PARMS] should - by definition - only be used right behind [PROC() #fn_PROC].
If the logging of variable values is wanted during a function exection to
trace, the [VARS() #fn_VARS]-macro shall be used.

//param_name// is the name of the parameter
//format// is a printf-styled format placeholder.
//parameter// is the parameter itself.
'''
<!-- NEED 22 -->
'''
== PROC ==[fn_PROC]

**Definition:**

PROC( char* func_name ) - //Macro//

**Usage:**

Write function entry to trace.

The PROC-macro introduces a new function level, if compiled with trace.

The PROC-macro must be put behind the last local variable declaration and the
first code line, else it won't compile. A PROC-macro must exists within a
function to allow for other trace-macro usages. If [PROC() #fn_PROC] is used within a
function, the macros [RETURN() #fn_RETURN] or VOIDRET, according to the function return
value, must be used. If PROC is used without RETURN, the trace output will
output a wrong call level depth.

The parameter //func_name// is a static string for the function name.
'''
<!-- NEED 15 -->
'''
== RETURN ==[fn_RETURN]

**Definition:**

RETURN( function_type return_value ) - //Macro//

**Usage:**

Write function return to trace.
 [RETURN() #fn_RETURN] can only be used if [PROC() #fn_PROC] is used at the beginning of the function.
For void-functions, use the macro VOIDRET.

//return_value// is return-value of the function.
'''
<!-- NEED 18 -->
'''
== VARS ==[fn_VARS]

**Definition:**

VARS( char* var_name, char* format, var_type variable ) - //Macro//

**Usage:**

Write variable content to trace.

The VARS-macro is used to write variable names and values to the program trace.
For parameters taken to functions, the [PARMS() #fn_PARMS]-macro shall be used.

//var_name// is the name of the variable
//format// is a printf-styled format placeholder.
//variable// is the the parameter itself.
'''
<!-- NEED 14 -->
'''
== VOIDRET ==[fn_VOIDRET]

**Definition:**

VOIDRET - //Macro//

**Usage:**

Write void function return to trace.

VOIDRET can only be used if [PROC() #fn_PROC] is used at the beginning of the function.
For typed functions, use the macro [RETURN() #fn_RETURN].
= Functions =
'''
<!-- NEED 16 -->
'''
== p_ccl_add ==[fn_p_ccl_add]

**Definition:**

pboolean p_ccl_add( pccl* ccl, wchar_t ch )

**Usage:**

Integrates a single character into a character-class.

//ccl// is the pointer to the character-class to be affected.
//ch// is the character to be integrated.

The function is a shortcut for [p_ccl_addrange() #fn_p_ccl_addrange].
'''
<!-- NEED 19 -->
'''
== p_ccl_addrange ==[fn_p_ccl_addrange]

**Definition:**

pboolean p_ccl_addrange( pccl* ccl, wchar_t begin, wchar_t end )

**Usage:**

Integrates a character range into a character-class.

//ccl// is the pointer to the character-class to be affected. If //ccl// is
provided as (pccl*)NULL, it will be created by the function.

//begin// is the begin of character range to be integrated.
//end// is the end of character range to be integrated.

If //begin// is greater than //end//, the values will be swapped.
'''
<!-- NEED 17 -->
'''
== p_ccl_compare ==[fn_p_ccl_compare]

**Definition:**

int p_ccl_compare( pccl* left, pccl* right )

**Usage:**

Checks for differences in two character-classes.

//left// is the pointer to the first character-class.
//right// is the pointer to the second character-class.

Returns a value < 0 if //left// is lower than //right//, 0 if //left// is
equal to //right// or a value > 0 if //left// is greater than //right//.
'''
<!-- NEED 12 -->
'''
== p_ccl_compat ==[fn_p_ccl_compat]

**Definition:**

pboolean p_ccl_compat( pccl* l, pccl* r )

**Usage:**

Checks if the character-classes //l// and //r// are in the same
character universe and compatible for operations.
'''
<!-- NEED 15 -->
'''
== p_ccl_count ==[fn_p_ccl_count]

**Definition:**

int p_ccl_count( pccl* ccl )

**Usage:**

Returns the number of characters within a character-class.

//ccl// is a pointer to the character-class to be processed.

Returns the total number of characters the class is holding.
'''
<!-- NEED 15 -->
'''
== p_ccl_create ==[fn_p_ccl_create]

**Definition:**

pccl* p_ccl_create( int min, int max, char* ccldef )

**Usage:**

Constructor function to create a new character-class.


Returns a pointer to the newly created character-class. This pointer should be
released with [p_ccl_free() #fn_p_ccl_free] when its existence is no longer required.
'''
<!-- NEED 16 -->
'''
== p_ccl_del ==[fn_p_ccl_del]

**Definition:**

pboolean p_ccl_del( pccl* ccl, wchar_t ch )

**Usage:**

Removes a character from a character-class.

//ccl// is the pointer to the character-class to be affected.
//ch// is the character to be removed from //ccl//.

The function is a shortcut for [p_ccl_delrange() #fn_p_ccl_delrange].
'''
<!-- NEED 15 -->
'''
== p_ccl_delrange ==[fn_p_ccl_delrange]

**Definition:**

pboolean p_ccl_delrange( pccl* ccl, wchar_t begin, wchar_t end )

**Usage:**

Removes a character range from a character-class.

//ccl// is the pointer to the character-class to be affected.
//begin// is the begin of character range to be removed.
//end// is the end of character range to be removed.
'''
<!-- NEED 20 -->
'''
== p_ccl_diff ==[fn_p_ccl_diff]

**Definition:**

pccl* p_ccl_diff( pccl* ccl, pccl* rem )

**Usage:**

Returns the difference quantity of two character-classes.
All elements from //rem// will be removed from //ccl//, and put into a
new character-class.

//ccl// is the pointer to the first character-class.
//rem// is the pointer to the second character-class.

Returns a new pointer to a copy of //ccl//, without the ranges contained in
//rem//. Returns (pccl*)NULL in case of memory allocation or parameter
error.
'''
<!-- NEED 16 -->
'''
== p_ccl_dup ==[fn_p_ccl_dup]

**Definition:**

pccl* p_ccl_dup( pccl* ccl )

**Usage:**

Duplicates a character-class into a new one.

//ccl// is the pointer to the character-class to be duplicated.

Returns a pointer to the duplicate of //ccl//, or (pcrange)NULL
in error case.
'''
<!-- NEED 15 -->
'''
== p_ccl_erase ==[fn_p_ccl_erase]

**Definition:**

pboolean p_ccl_erase( pccl* ccl )

**Usage:**

Erases a character-class //ccl//.

The function sets a character-class to zero, as it continas no character range
definitions. The object //ccl// will be still alive. To delete the entire
object, use [p_ccl_free() #fn_p_ccl_free].
'''
<!-- NEED 13 -->
'''
== p_ccl_free ==[fn_p_ccl_free]

**Definition:**

pccl* p_ccl_free( pccl* ccl )

**Usage:**

Frees a character-class //ccl// and all its used memory.

The function always returns (pccl*)NULL.
'''
<!-- NEED 23 -->
'''
== p_ccl_get ==[fn_p_ccl_get]

**Definition:**

pboolean p_ccl_get( wchar_t* from, wchar_t* to, pccl* ccl, int offset )

**Usage:**

Return a character or a character-range by its offset.

If the function is called only with pointer //from// provided, and //to// as
(wchar_t*)NULL, it writes the character in //offset//th position of the
character-class into from.

If the function is called both with pointer //from// and //to// provided,
it writes the //begin// and //end// character of the character-range in the
//offset//th position of the character-class into //from// and //to//.

If no character or range with the given offset was found, the function
returns FALSE, meaning that the end of the characters is reached.
On success, the function will always return TRUE.
'''
<!-- NEED 19 -->
'''
== p_ccl_instest ==[fn_p_ccl_instest]

**Definition:**

pboolean p_ccl_instest( pccl* ccl, wchar_t ch )

**Usage:**

Tests for a character in case-insensitive-mode if it matches
a character-class.

//ccl// is the pointer to character-class to be tested.
//ch// is the character to be tested.

The function is a shortcut for [p_ccl_testrange() #fn_p_ccl_testrange].

It returns TRUE, if the character matches the class, and FALSE if not.
'''
<!-- NEED 19 -->
'''
== p_ccl_intersect ==[fn_p_ccl_intersect]

**Definition:**

pccl* p_ccl_intersect( pccl* ccl, pccl* within )

**Usage:**

Returns a new character-class with all characters that exist in both
provided character-classes.

//ccl// is the pointer to the first character-class.
//within// is the pointer to the second character-class.

Returns a new character-class containing the insersections from //ccl//
and //within//. If there is no intersection between both character-classes,
the function returns (pccl*)NULL.
'''
<!-- NEED 15 -->
'''
== p_ccl_negate ==[fn_p_ccl_negate]

**Definition:**

pccl* p_ccl_negate( pccl* ccl )

**Usage:**

Negates all ranges in a character-class.

//ccl// is the pointer to the character-class to be negated.

Returns a pointer to //ccl//.
'''
<!-- NEED 25 -->
'''
== p_ccl_parse ==[fn_p_ccl_parse]

**Definition:**

pboolean p_ccl_parse( pccl* ccl, char* ccldef, pboolean extend )

**Usage:**

Parses the character-class definition provided in //ccldef// and assigns
this definition to the character-class //ccl//. //ccldef// may contain
UTF-8 formatted input. Escape-sequences will be interpretered to their correct
character representations.

A typical character-class definition simply exists of single characters and
range definitions. For example, "$A-Z#0-9" defines a character-class that
consists of the characters "$#0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".

The parameter //extend// specifies, if the provided character-class overwrites
(//extend// = FALSE) or extends (//extend// = TRUE) the provided
character-class. This means that definitions that already exist in the
character-class, should be erased first or not.

The function returns TRUE on success, and FALSE on an error.
'''
<!-- NEED 20 -->
'''
== p_ccl_parsechar ==[fn_p_ccl_parsechar]

**Definition:**

size_t p_ccl_parsechar( wchar_t* retc, char *str, pboolean escapeseq )

**Usage:**

Reads a character from a string. The character may exist of one single
character or it may be made up of an escape sequence or UTF-8 character.
The function returns the number of bytes read.

//retc// is the return pointer for the character code of the escaped string.
//str// is the begin pointer of the string at which character parsing begins.
If //escapeseq// is TRUE, the function regards escape sequences, else it ignores
them.

Returns the number of bytes that had been read for the character.
'''
<!-- NEED 17 -->
'''
== p_ccl_parseshorthand ==[fn_p_ccl_parseshorthand]

**Definition:**

size_t p_ccl_parseshorthand( pccl* ccl, char *str )

**Usage:**

Tries to parse a shorthand sequence from a string. This matches the
shorthands \w, \W, \d, \D, \s and \S. If it matches, all characters are
added to //ccl//.

The function returns the number of bytes that had been read for the character.
If no shorthand sequence could be found, it returns 0, and leaves //ccl//
untouched.
'''
<!-- NEED 22 -->
'''
== p_ccl_print ==[fn_p_ccl_print]

**Definition:**

void p_ccl_print( FILE* stream, pccl* ccl, int break_after )

**Usage:**

Print character-class to output stream.
This function is provided for debug-purposes only.

//stream// is the output stream to dump the character-class to; This can be
left (FILE*)NULL, so //stderr// will be used.
//ccl// is the pointer to character-class

//break_after// defines:
- if < 0 print with pointer info
- if 0 print all into one line
- if > 0 print linewise
-
'''
<!-- NEED 17 -->
'''
== p_ccl_size ==[fn_p_ccl_size]

**Definition:**

int p_ccl_size( pccl* ccl )

**Usage:**

Returns the number of range pairs within a character-class.

//ccl// is a pointer to the character-class to be processed.

To retrieve the number of characters in a character-class, use [p_ccl_count() #fn_p_ccl_count] instead.

Returns the number of pairs the charclass holds.
'''
<!-- NEED 18 -->
'''
== p_ccl_test ==[fn_p_ccl_test]

**Definition:**

pboolean p_ccl_test( pccl* ccl, wchar_t ch )

**Usage:**

Tests a character-class if it cointains a character.

//ccl// is the pointer to character-class to be tested.
//ch// is the character to be tested.

The function is a shortcut for [p_ccl_testrange() #fn_p_ccl_testrange].

It returns TRUE, if the character matches the class, and FALSE if not.
'''
<!-- NEED 17 -->
'''
== p_ccl_testrange ==[fn_p_ccl_testrange]

**Definition:**

pboolean p_ccl_testrange( pccl* ccl, wchar_t begin, wchar_t end )

**Usage:**

Tests a character-class to match a character range.

//ccl// is a pointer to the character-class to be tested.
//begin// is the begin of character-range to be tested.
//end// is the end of character-range to be tested.

Returns TRUE if the entire character range matches the class, and FALSE if not.
'''
<!-- NEED 22 -->
'''
== p_ccl_to_str ==[fn_p_ccl_to_str]

**Definition:**

char* p_ccl_to_str( pccl* ccl, pboolean escape )

**Usage:**

Converts a character-class back to a string representation of the
character-class definition, which in turn can be converted back into a
character-class using [p_ccl_create() #fn_p_ccl_create].

//ccl// is the pointer to character-class to be converted.
//escape//, if TRUE, escapes "unprintable" characters in their hexadecimal
representation. If FALSE, it prints all characters, except the zero, which will
be returned as "\0"

Returns a pointer to the generated string that represents the charclass.
The returned pointer belongs to the //ccl// and is managed by the
character-class handling functions, so it should not be freed manually.
'''
<!-- NEED 18 -->
'''
== p_ccl_union ==[fn_p_ccl_union]

**Definition:**

pccl* p_ccl_union( pccl* ccl, pccl* add )

**Usage:**

Unions two character-classes into a new, normalized one.

//ccl// is the pointer to the character-class that will be extended to all
ranges contained in //add//.
//add// is character-class that will be unioned with //ccl//.

The function creates and returns a new character-class that is the union
if //ccl// and //add//.
'''
<!-- NEED 11 -->
'''
== parray_count ==[fn_parray_count]

**Definition:**

size_t parray_count( parray* array )

**Usage:**

Returns the number of elements in a array.
'''
<!-- NEED 14 -->
'''
== parray_create ==[fn_parray_create]

**Definition:**

parray* parray_create( size_t size, size_t chunk )

**Usage:**

Create a new parray as an object with an element allocation size //size//
and a reallocation-chunk-size of //chunk//.

The returned memory must be released with [parray_free() #fn_parray_free].
'''
<!-- NEED 15 -->
'''
== parray_erase ==[fn_parray_erase]

**Definition:**

pboolean parray_erase( parray* array )

**Usage:**

Erase a dynamic array.

The array must not be reinitialized after destruction, using [parray_init() #fn_parray_init].

//array// is the pointer to the array to be erased.
'''
<!-- NEED 14 -->
'''
== parray_first ==[fn_parray_first]

**Definition:**

void* parray_first( parray* array )

**Usage:**

Access first element of the array.

Returns the address of the accessed item, and (void*)NULL if nothing is on
the array.
'''
<!-- NEED 13 -->
'''
== parray_free ==[fn_parray_free]

**Definition:**

parray* parray_free( parray* array )

**Usage:**

Releases all the memory //array// uses and destroys the array object.

The function always returns (parray*)NULL.
'''
<!-- NEED 20 -->
'''
== parray_get ==[fn_parray_get]

**Definition:**

void* parray_get( parray* array, size_t offset )

**Usage:**

Access an element from the array by its offset position from the left.

//array// is the pointer to array where to access the element from.
//offset// is the offset of the element to be accessed from the array's
base address.

Returns the address of the accessed item, and (void*)NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the last of array).

Use [parray_rget() #fn_parray_rget] for access items from the end.
'''
<!-- NEED 21 -->
'''
== parray_init ==[fn_parray_init]

**Definition:**

pboolean parray_init( parray* array, size_t size, size_t chunk )

**Usage:**

Performs an array initialization.

//array// is the pointer to the array to be initialized.

//size// defines the size of one array element, in bytes.
This should be evaluated using the [sizeof() #fn_sizeof]-macro.

//chunk// defines the chunk size, where an array-(re)allocation will be performed.
If, e.g. this is set to 128, then, if the 128th item is created within the
array, a realloction is done. Once allocated memory remains until the array is
freed again.
'''
<!-- NEED 15 -->
'''
== parray_insert ==[fn_parray_insert]

**Definition:**

void* parray_insert( parray* array, size_t offset, void* item )

**Usage:**

Insert item //item// at //offset// into array //array//.
Items right to //offset// will move up.

Gap space between the offset is filled with zero elements;
Handle with care!
'''
<!-- NEED 14 -->
'''
== parray_last ==[fn_parray_last]

**Definition:**

void* parray_last( parray* array )

**Usage:**

Access last element of the array.

Returns the address of the accessed item, and (void*)NULL if nothing is on
the array.
'''
<!-- NEED 14 -->
'''
== parray_malloc ==[fn_parray_malloc]

**Definition:**

void* parray_malloc( parray* array )

**Usage:**

Pushes and "allocates" an empty element on the array.

This function is just a shortcut to ```parray_push( array, (void*)NULL )```,
and the memory of the pushed element is initialized to zero.
'''
<!-- NEED 16 -->
'''
== parray_offset ==[fn_parray_offset]

**Definition:**

size_t parray_offset( parray* array, void* ptr )

**Usage:**

Return offset of element //ptr// in array //array//.
Returns the offset of //ptr// in //array//.
The function returns the size of the array (which is an invalid offset)
if //ptr// is not part of //array//.

To check if a pointer belongs to an array, call [parray_partof() #fn_parray_partof].
'''
<!-- NEED 11 -->
'''
== parray_partof ==[fn_parray_partof]

**Definition:**

pboolean parray_partof( parray* array, void* ptr )

**Usage:**

Returns TRUE, if //ptr// is an element of array //array//.
'''
<!-- NEED 20 -->
'''
== parray_pop ==[fn_parray_pop]

**Definition:**

void* parray_pop( parray* array )

**Usage:**

Removes an element from the end of an array.

The function returns the pointer of the popped item. Because dynamic arrays only
grow and no memory is freed, the returned data pointer is still valid, and will
only be overwritten with the next push operation.

//array// is the pointer to array where to pop an item off.

The function returns the address of the popped item, and (void*)NULL if the
item could not be popped (e.g. array is empty).
'''
<!-- NEED 23 -->
'''
== parray_push ==[fn_parray_push]

**Definition:**

void* parray_push( parray* array, void* item )

**Usage:**

Appends an element to the end of the array.

The element's memory is copied during the push. The item must be of the same
memory size as used at array initialization.

//array// is the pointer to array where to push an item on.

//item// is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left (void*)NULL, so no memory will be copied.

The function returns the address of the newly pushed item, and (void*)NULL if
the item could not be pushed.
'''
<!-- NEED 20 -->
'''
== parray_put ==[fn_parray_put]

**Definition:**

void* parray_put( parray* array, size_t offset, void* item )

**Usage:**

Put an element //item// at position //offset// of array //array//.

//array// is the pointer to array where to put the element to.
//offset// is the offset of the element to be set.
//item// is a pointer to the memory that will be copied into the
position at //offset//. If this is NULL, the position at //offset// will be
set to zero.

Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
'''
<!-- NEED 15 -->
'''
== parray_remove ==[fn_parray_remove]

**Definition:**

void* parray_remove( parray* array, size_t offset, void** item )

**Usage:**

Remove item on //offset// from array //array//.

The removed item will be copied into //item//, if //item// is not NULL.
The function returns the memory of the removed item (it will contain the
moved up data part or invalid memory, if on the end).
'''
<!-- NEED 14 -->
'''
== parray_reserve ==[fn_parray_reserve]

**Definition:**

pboolean parray_reserve( parray* array, size_t n )

**Usage:**

Reserves memory for //n// items in //array//.

This function is only used to assume that no memory reallocation is done when
the next //n// items are inserted/malloced.
'''
<!-- NEED 21 -->
'''
== parray_rget ==[fn_parray_rget]

**Definition:**

void* parray_rget( parray* array, size_t offset )

**Usage:**

Access an element from the array by its offset position from the right.

//array// is the pointer to array where to access the element from.
//offset// is the offset of the element to be accessed from the array's
base address.

Returns the address of the accessed item, and (void*)NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the bottom of
the array).

Use [parray_get() #fn_parray_get] for access items from the begin.
'''
<!-- NEED 14 -->
'''
== parray_rmalloc ==[fn_parray_rmalloc]

**Definition:**

void* parray_rmalloc( parray* array )

**Usage:**

Unshifts and "allocates" an empty element on the array.

This function is just a shortcut to ```parray_unshift( array, (void*)NULL )```,
and the memory of the unshifted element is initialized to zero.
'''
<!-- NEED 21 -->
'''
== parray_rput ==[fn_parray_rput]

**Definition:**

void* parray_rput( parray* array, size_t offset, void* item )

**Usage:**

Put an element //item// at position //offset// from the right of
array //array//.

//array// is the pointer to array where to put the element to.
//offset// is the offset of the element to be set.
//item// is a pointer to the memory that will be copied into the
position at //offset//. If this is NULL, the position at //offset// will be
set to zero.

Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
'''
<!-- NEED 21 -->
'''
== parray_shift ==[fn_parray_shift]

**Definition:**

void* parray_shift( parray* array )

**Usage:**

Removes an element from the begin of an array.

The function returns the pointer of the shifted item.
Because dynamic arrays only grow and no memory is freed, the returned data
pointer is still valid, and will only be overwritten with the next unshift
operation.

//array// is the pointer to array where to pop an item off.

The function returns the address of the shifted item, and (void*)NULL if the
item could not be popped (e.g. array is empty).
'''
<!-- NEED 11 -->
'''
== parray_swap ==[fn_parray_swap]

**Definition:**

void* parray_swap( parray* array, size_t pos1, size_t pos2 )

**Usage:**

Swap two elements of an array.
'''
<!-- NEED 23 -->
'''
== parray_unshift ==[fn_parray_unshift]

**Definition:**

void* parray_unshift( parray* array, void* item )

**Usage:**

Appends an element to the begin of the array.

The elements memory is copied during the unshift. The item must be of the same
memory size as used at array initialization.

//array// is the pointer to array where to push an item to the beginning.

//item// is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left (void*)NULL, so no memory will be copied.

The function returns the address of the newly unhshifted item, and (void*)NULL
if the item could not be unshifted.
'''
<!-- NEED 19 -->
'''
== pasprintf ==[fn_pasprintf]

**Definition:**

char* pasprintf( char* fmt, ... )

**Usage:**

Implementation and replacement for asprintf. [pasprintf() #fn_pasprintf] takes only the
format-string and various arguments. It outputs an allocated string to be freed
later on.

//fmt// is the format string.
//...// are the parameters according to the placeholders set in //fmt//.

Returns a char* Returns the allocated string which cointains the format string
with inserted values.
'''
<!-- NEED 15 -->
'''
== pbasename ==[fn_pbasename]

**Definition:**

char* pbasename( char* path )

**Usage:**

Returns the basename of a file.

//path// is the file path pointer.

Returns a pointer to the basename, which is a part of //path//.
'''
<!-- NEED 19 -->
'''
== pdbl_to_str ==[fn_pdbl_to_str]

**Definition:**

char* pdbl_to_str( double d )

**Usage:**

Converts a double-value into an allocated string buffer.

//d// is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become "1.65" in its
string representation.

Returns a pointer to the newly allocated string, which contains the
string-representation of the double value. This pointer must be released
by the caller.
'''
<!-- NEED 19 -->
'''
== pdbl_to_wcs ==[fn_pdbl_to_wcs]

**Definition:**

wchar_t* pdbl_to_wcs( double d )

**Usage:**

Converts a double-value into an allocated wide-character string buffer.

//d// is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become L"1.65" in its
wide-character string representation.

Returns a pointer to the newly allocated wide-character string, which contains
the string-representation of the double value. This pointer must be released
by the caller.
'''
<!-- NEED 15 -->
'''
== pfileexists ==[fn_pfileexists]

**Definition:**

pboolean pfileexists( char* filename )

**Usage:**

Checks for file existence.

//filename// is the path to a file that will be checked.

Returns TRUE on success, FALSE if not.
'''
<!-- NEED 16 -->
'''
== pfiletostr ==[fn_pfiletostr]

**Definition:**

pboolean pfiletostr( char** cont, char* filename )

**Usage:**

Maps the content of an entire file into memory.

//cont// is the file content return pointer.
//filename// is the path to file to be mapped

The function returns TRUE on success.
'''
<!-- NEED 22 -->
'''
== pfree ==[fn_pfree]

**Definition:**

void* pfree( void* ptr )

**Usage:**

Free allocated memory.

The function is a wrapper for the system-function [free() #fn_free], but accepts
NULL-pointers and returns a (void*)NULL pointer for direct pointer memory reset.

It could be used this way to immedatelly reset a pointer to NULL:

``` ptr = pfree( ptr );

//ptr// is the pointer to be freed.

Returns always (void*)NULL.
'''
<!-- NEED 56 -->
'''
== pgetopt ==[fn_pgetopt]

**Definition:**

int pgetopt( char* opt, char** param, int* next, int argc, char** argv, char* optstr, char* loptstr, int idx )

**Usage:**

Implementation of a command-line option interpreter.

This function works similar to the [getopt() #fn_getopt] functions of the GNU Standard
Library, but uses a different style of parameter submit.

It supports both short- and long- option-style parameters.
This function is currently under recent development relating to the issues it
is used for. It can't be seen as compatible or feature-proven, and does not
follow a clear concept right now.

//opt// is a pointer to a buffer with enough space to store the requested
parameter to. For short parameters, this is only one char, for long-parameters
the full name. The string will be zero-terminated.

//param// is a pointer to store a possible parameter value to, if the detected
option allows for parameters.

//next// receives the index in argv of the next evaluated option. It can be
left (int*)NULL. It points to the next valid index in argv[] after all
parameters have been evaluated. Check it for < argc, to point to valid data.

//argc// is the argument count as taken from the [main() #fn_main] function.

//argv// are the argument values as taken from the [main() #fn_main] function.

//optstr// contains the possible short-options. This is a string where each
character defines an option. If an option takes a parameter, a colon (:) is
submitted.
E.g. "abc:def:g". The Options "-c" and "-f" will take a parameter that is
returned to param. This parameter can be (char*)NULL.

//loptstr// contains the possible long-options. This is a string containing all
long option names, each separated by a blank. Long options taking parameters
have an attached colon (:) to the name.
E.g. "hello world: next" defines three long options, where option 'world' takes
one parameter that is returned to param. This parameter can be (char*)NULL.

//idx// is the index of the requested option, 0 for the first option behind
argv[0].

The function returns 0, if the parameter with the given index was
successfully evaluated. It returns 1, if there are sill command-line parameters,
but not as part of options. The parameter param will receive the given pointer.
It returns -1 if no more options could be read, or if an option could
not be evaluated (unknown option). In such case, param will hold a string to the
option that is unknown to [pgetopt() #fn_pgetopt].
'''
<!-- NEED 32 -->
'''
== plex_create ==[fn_plex_create]

**Definition:**

plex* plex_create( int flags )

**Usage:**

Constructor function to create a new plex object.

//flags// can be a combination of compile- and runtime-flags and are merged
with special compile-time flags provided for each pattern.

|| Flag | Usage |
| PREGEX_COMP_WCHAR | The regular expressions are provided as wchar_t. |
| PREGEX_COMP_NOANCHORS | Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile all patterns to be forced nongreedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expressions as case insensitive. |
| PREGEX_COMP_STATIC | The regular expressions passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped. |
| PREGEX_RUN_WCHAR | Run regular expressions with wchar_t as input. |
| PREGEX_RUN_NOANCHORS | Ignore anchors while processing the lexer. |
| PREGEX_RUN_NOREF | Don't create references. |
| PREGEX_RUN_NONGREEDY | Force run lexer nongreedy. |
| PREGEX_RUN_DEBUG | Debug mode; output some debug to stderr. |


On success, the function returns the allocated pointer to a plex-object.
This must be freed later using [plex_free() #fn_plex_free].
'''
<!-- NEED 29 -->
'''
== plex_define ==[fn_plex_define]

**Definition:**

pboolean plex_define( plex* lex, char* pat, int match_id, int flags )

**Usage:**

Defines and parses a regular expression pattern into the plex-object.

//pat// is the regular expression string.

//match_id// must be a token match ID, a value > 0. The lower the match ID is,
the higher precedence takes the appended expression when there are multiple
matches.

//flags// may ONLY contain compile-time flags, and is combined with the
compile-time flags of the plex-object provided at [plex_create() #fn_plex_create].

|| Flag | Usage |
| PREGEX_COMP_WCHAR | The regular expressions are provided as wchar_t. |
| PREGEX_COMP_NOANCHORS | Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile all patterns to be forced nongreedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expressions as case insensitive. |
| PREGEX_COMP_STATIC | The regular expressions passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped. |
'''
<!-- NEED 15 -->
'''
== plex_free ==[fn_plex_free]

**Definition:**

plex* plex_free( plex* lex )

**Usage:**

Destructor function for a plex-object.

//lex// is the pointer to a plex-structure that will be released.

Returns always (plex*)NULL.
'''
<!-- NEED 18 -->
'''
== plex_lex ==[fn_plex_lex]

**Definition:**

int plex_lex( plex* lex, char* start, char** end )

**Usage:**

Performs a lexical analysis using the object //lex// on pointer //start//.

If a token can be matched, the function returns the related id of the matching
pattern, and //end// receives the pointer to the last matched character.

The function returns 0 in case that there was no direct match.
The function [plex_next() #fn_plex_next] ignores unrecognized symbols and directly moves to the
next matching pattern.
'''
<!-- NEED 22 -->
'''
== plex_next ==[fn_plex_next]

**Definition:**

char* plex_next( plex* lex, char* start, int* id, char** end )

**Usage:**

Performs lexical analysis using //lex// from begin of pointer //start//, to
the next matching token.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the plex-object).

If a token can be matched, the function returns the pointer to the position
where the match starts at. //id// receives the id of the matching patternn,
//end// receives the end pointer of the match, when provided. //id// and //end//
can be omitted by providing NULL-pointers.

The function returns (char*)NULL in case that there is no match.
'''
<!-- NEED 11 -->
'''
== plex_prepare ==[fn_plex_prepare]

**Definition:**

pboolean plex_prepare( plex* lex )

**Usage:**

Prepares the DFA state machine of a plex-object //lex// for execution.
'''
<!-- NEED 11 -->
'''
== plex_reset ==[fn_plex_reset]

**Definition:**

pboolean plex_reset( plex* lex )

**Usage:**

Resets the DFA state machine of a plex-object //lex//.
'''
<!-- NEED 18 -->
'''
== plex_tokenize ==[fn_plex_tokenize]

**Definition:**

int plex_tokenize( plex* lex, char* start, parray** matches )

**Usage:**

Tokenizes the string beginning at //start// using the lexical analyzer
//lex//.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the plex-object).

The function initializes and fills the array //matches//, if provided, with
items of size prange. It returns the total number of matches.
'''
<!-- NEED 11 -->
'''
== plist_access ==[fn_plist_access]

**Definition:**

void* plist_access( plistel* e )

**Usage:**

Access data-content of the current element //e//.
'''
<!-- NEED 15 -->
'''
== plist_clear ==[fn_plist_clear]

**Definition:**

pboolean plist_clear( plist* list )

**Usage:**

Clear content of the list //list//.

The function has nearly the same purpose as [plist_erase() #fn_plist_erase], except that
the entire list is only cleared, but if the list was initialized with
PLIST_MOD_RECYCLE, existing pointers are hold for later usage.
'''
<!-- NEED 11 -->
'''
== plist_count ==[fn_plist_count]

**Definition:**

int plist_count( plist* l )

**Usage:**

Return element count of list //l//.
'''
<!-- NEED 29 -->
'''
== plist_create ==[fn_plist_create]

**Definition:**

plist* plist_create( size_t size, int flags )

**Usage:**

Create a new plist as an object with an element allocation size //size//.
Providing a //size// of 0 causes automatic configuration of PLIST_MOD_PTR.

//flags// defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage. The flags can be merged together using
bitwise or (|).

Possible flags are:
- **PLIST_MOD_NONE** for no special flagging.
- **PLIST_MOD_PTR** to use the plist-object in pointer-mode: Each plistel-element cointains only a pointer to an object in the memory and returnsthis, instead of copying from or into pointers.
- **PLIST_MOD_RECYCLE** to configure that elements that are removed during listusage will be reused later.
- **PLIST_MOD_AUTOSORT** to automatically sort elements on insert operations.
- **PLIST_MOD_EXTKEYS** to configure that string pointers to hash-table keyvalues are stored elsewhere, so the plist-module only uses the originalpointers instead of copying them.
- **PLIST_MOD_PTRKEYS** disables string keys and uses the pointer/valueprovided as key directly.
- **PLIST_MOD_UNIQUE** to disallow hash-table-key collisions, so elements witha key that already exist in the object will be rejected.
- **PLIST_MOD_WCHAR** to let all key values handle as wide-character strings.
-

Use [plist_free() #fn_plist_free] to erase and release the returned list object.
'''
<!-- NEED 16 -->
'''
== plist_diff ==[fn_plist_diff]

**Definition:**

int plist_diff( plist* left, plist* right )

**Usage:**

Tests the contents (data parts) of the list //left// and the list //right//
for equal elements.

The function returns a value < 0 if //left// is lower //right//, a value > 0
if //left// is greater //right// and a value == 0 if //left// is equal to
//right//.
'''
<!-- NEED 13 -->
'''
== plist_dup ==[fn_plist_dup]

**Definition:**

plist* plist_dup( plist* list )

**Usage:**

Creates an independent copy of //list// and returns it.

All elements of //list// are duplicated and stand-alone.
'''
<!-- NEED 14 -->
'''
== plist_erase ==[fn_plist_erase]

**Definition:**

pboolean plist_erase( plist* list )

**Usage:**

Erase all allocated content of the list //list//.

The object //list// will be still alive, but must be re-configured
using [plist_init() #fn_plist_init].
'''
<!-- NEED 11 -->
'''
== plist_first ==[fn_plist_first]

**Definition:**

plistel* plist_first( plist* l )

**Usage:**

Return first element of list //l//.
'''
<!-- NEED 13 -->
'''
== plist_free ==[fn_plist_free]

**Definition:**

plist* plist_free( plist* list )

**Usage:**

Releases all the memory //list// uses and destroys the list object.

The function always returns (plist*)NULL.
'''
<!-- NEED 13 -->
'''
== plist_get ==[fn_plist_get]

**Definition:**

plistel* plist_get( plist* list, size_t n )

**Usage:**

Retrieve list element by its index from the begin.

The function returns the //n//th element of the list //list//.
'''
<!-- NEED 14 -->
'''
== plist_get_by_key ==[fn_plist_get_by_key]

**Definition:**

plistel* plist_get_by_key( plist* list, char* key )

**Usage:**

Retrieve list element by hash-table key.

This function tries to fetch a list entry plistel from list //list//
with the key //key//.
'''
<!-- NEED 14 -->
'''
== plist_get_by_ptr ==[fn_plist_get_by_ptr]

**Definition:**

plistel* plist_get_by_ptr( plist* list, void* ptr )

**Usage:**

Retrieve list element by pointer.

This function returns the list element of the unit within the list //list//
that is the pointer //ptr//.
'''
<!-- NEED 15 -->
'''
== plist_hash_rebuild ==[fn_plist_hash_rebuild]

**Definition:**

static pboolean plist_hash_rebuild( plist* list );/* Compare hash-table elements */static int plist_hash_compare( plist* list, char* l, char* r )

**Usage:**

Write a message to trace.

//param_name// is the name of the parameter
//format// is the A printf-styled format string.
//parameter// is the parameter itself.
'''
<!-- NEED 11 -->
'''
== plist_hashnext ==[fn_plist_hashnext]

**Definition:**

plistel* plist_hashnext( plistel* u )

**Usage:**

Access next element with same hash value of current unit //u//.
'''
<!-- NEED 11 -->
'''
== plist_hashprev ==[fn_plist_hashprev]

**Definition:**

plistel* plist_hashprev( plistel* u )

**Usage:**

Access previous element with same hash value of a current unit //u//.
'''
<!-- NEED 13 -->
'''
== plist_init ==[fn_plist_init]

**Definition:**

pboolean plist_init( plist* list, size_t size, int flags )

**Usage:**

Initialize the list //list// with an element allocation size //size//.
//flags// defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage.
'''
<!-- NEED 15 -->
'''
== plist_insert ==[fn_plist_insert]

**Definition:**

plistel* plist_insert( plist* list, plistel* pos, char* key, void* src )

**Usage:**

Insert //src// as element to the list //list// __before__ positon //pos//.

If //pos// is NULL, the new element will be attached to the end of the
list. If //key// is not NULL, the element will be additionally engaged
into the lists hash table.
'''
<!-- NEED 11 -->
'''
== plist_key ==[fn_plist_key]

**Definition:**

char* plist_key( plistel* e )

**Usage:**

Access key-content of the current element //e//.
'''
<!-- NEED 11 -->
'''
== plist_last ==[fn_plist_last]

**Definition:**

plistel* plist_last( plist* l )

**Usage:**

Return last element of list //l//.
'''
<!-- NEED 14 -->
'''
== plist_malloc ==[fn_plist_malloc]

**Definition:**

void* plist_malloc( plist* list )

**Usage:**

Allocates memory for a new element in list //list//, push it to the end and
return the pointer to this.

The function works as a shortcut for [plist_access() #fn_plist_access] in combination with [plist_push() #fn_plist_push].
'''
<!-- NEED 11 -->
'''
== plist_next ==[fn_plist_next]

**Definition:**

plistel* plist_next( plistel* u )

**Usage:**

Access next element of current unit //u//.
'''
<!-- NEED 11 -->
'''
== plist_offset ==[fn_plist_offset]

**Definition:**

int plist_offset( plistel* u )

**Usage:**

Return the offset of the unit //u// within the list it belongs to.
'''
<!-- NEED 17 -->
'''
== plist_pop ==[fn_plist_pop]

**Definition:**

pboolean plist_pop( plist* list, void* dest )

**Usage:**

Pop last element to //dest// off the list //list//.

Like //list// would be a stack, the last element of the list is poppend and
its content is written to //dest//, if provided at the end of the list.

//dest// can be omitted and given as (void*)NULL, so the last element will
be popped off the list and discards.
'''
<!-- NEED 11 -->
'''
== plist_prev ==[fn_plist_prev]

**Definition:**

plistel* plist_prev( plistel* u )

**Usage:**

Access previous element of a current unit //u//.
'''
<!-- NEED 15 -->
'''
== plist_push ==[fn_plist_push]

**Definition:**

plistel* plist_push( plist* list, void* src )

**Usage:**

Push //src// to end of //list//.

Like //list// would be a stack, //src// is pushed at the end of the list.
This function can only be used for linked lists without the hash-table feature
in use.
'''
<!-- NEED 12 -->
'''
== plist_remove ==[fn_plist_remove]

**Definition:**

pboolean plist_remove( plist* list, plistel* e )

**Usage:**

Removes the element //e// from the the //list// and frees it or puts
it into the unused element chain if PLIST_MOD_RECYCLE is flagged.
'''
<!-- NEED 14 -->
'''
== plist_rget ==[fn_plist_rget]

**Definition:**

plistel* plist_rget( plist* list, size_t n )

**Usage:**

Retrieve list element by its index from the end.

The function returns the //n//th element of the list //list//
from the right.
'''
<!-- NEED 14 -->
'''
== plist_rmalloc ==[fn_plist_rmalloc]

**Definition:**

void* plist_rmalloc( plist* list )

**Usage:**

Allocates memory for a new element in list //list//, shift it at the begin
and return the pointer to this.

The function works as a shortcut for [plist_access() #fn_plist_access] in combination with [plist_shift() #fn_plist_shift].
'''
<!-- NEED 11 -->
'''
== plist_set_comparefn ==[fn_plist_set_comparefn]

**Definition:**

pboolean plist_set_comparefn( plist* list, int (*comparefn)( plist*, plistel*, plistel* ) )

**Usage:**

Set compare function
'''
<!-- NEED 11 -->
'''
== plist_set_printfn ==[fn_plist_set_printfn]

**Definition:**

pboolean plist_set_printfn( plist* list, void (*printfn)( plist* ) )

**Usage:**

Set an element dump function.
'''
<!-- NEED 11 -->
'''
== plist_set_sortfn ==[fn_plist_set_sortfn]

**Definition:**

pboolean plist_set_sortfn( plist* list, int (*sortfn)( plist*, plistel*, plistel* ) )

**Usage:**

Set sort function
'''
<!-- NEED 15 -->
'''
== plist_shift ==[fn_plist_shift]

**Definition:**

plistel* plist_shift( plist* list, void* src )

**Usage:**

Shift //src// at begin of //list//.

Like //list// would be a queue, //src// is shifted at the begin of the list.
This function can only be used for linked lists without the hash-table feature
in use.
'''
<!-- NEED 11 -->
'''
== plist_size ==[fn_plist_size]

**Definition:**

int plist_size( plist* l )

**Usage:**

Return element size of list //l//.
'''
<!-- NEED 17 -->
'''
== plist_sort ==[fn_plist_sort]

**Definition:**

pboolean plist_sort( plist* list )

**Usage:**

Sorts //list// according to the sort-function that was set for the list.

To sort only parts of a list, use [plist_subsort() #fn_plist_subsort].

The sort-function can be modified by using [plist_set_sortfn() #fn_plist_set_sortfn].
The default sort function sorts the list by they contents, internally by using
the [memcmp() #fn_memcmp] standard function.
'''
<!-- NEED 18 -->
'''
== plist_subsort ==[fn_plist_subsort]

**Definition:**

pboolean plist_subsort( plist* list, plistel* from, plistel* to )

**Usage:**

Sorts //list// between the elements //from// and //to// according to the
sort-function that was set for the list.

To sort the entire list, use [plist_sort() #fn_plist_sort].

The sort-function can be modified by using [plist_set_sortfn() #fn_plist_set_sortfn].
The default sort function sorts the list by they contents, internally by using
the [memcmp() #fn_memcmp] standard function.
'''
<!-- NEED 13 -->
'''
== plist_swap ==[fn_plist_swap]

**Definition:**

pboolean plist_swap( plistel* a, plistel* b )

**Usage:**

Swaps the positions of the list elemements //a// and //b// with each
other. The elements must be in the same plist object, else the function
returns with FALSE.
'''
<!-- NEED 18 -->
'''
== plist_union ==[fn_plist_union]

**Definition:**

int plist_union( plist* all, plist* from )

**Usage:**

Unions elements from list //from// into list //all//.

An element is only added to //all//, if there exists no other
element with the same size and content.

The function will not run if both lists have different element size settings.

The function returns the number of elements added to //from//.
'''
<!-- NEED 17 -->
'''
== plist_unshift ==[fn_plist_unshift]

**Definition:**

pboolean plist_unshift( plist* list, void* dest )

**Usage:**

Take first element to //dest// from the list //list//.

Like //list// would be a queue, the first element of the list is taken and
its content is written to //dest//.

//dest// can be omitted and given as (void*)NULL, so the first element will
be taken from the list and discards.
'''
<!-- NEED 20 -->
'''
== pmalloc ==[fn_pmalloc]

**Definition:**

void* pmalloc( size_t size )

**Usage:**

Dynamically allocate heap memory.

The function is a wrapper for the system function [malloc() #fn_malloc], but with memory
initialization to zero, and immediatelly stops the program if no more memory
can be allocated.

//size// is the size of memory to be allocated, in bytes.

The function returns the allocated heap memory pointer. The returned memory
address should be freed using [pfree() #fn_pfree] after it is not required anymore.
'''
<!-- NEED 17 -->
'''
== pmemdup ==[fn_pmemdup]

**Definition:**

void* pmemdup( void* ptr, size_t size )

**Usage:**

Duplicates a memory entry onto the heap.

//ptr// is the pointer to the memory to be duplicated.
//size// is the size of pointer's data storage.

Returns the new pointer to the memory copy. This should be casted back to the
type of //ptr// again.
'''
<!-- NEED 12 -->
'''
== pp_ast_get ==[fn_pp_ast_get]

**Definition:**

ppmatch* pp_ast_get( parray* ast, ppmatch* from, size_t offset )

**Usage:**

Retrieves the entry with offset //offset// starting to count from
entry //from//.
'''
<!-- NEED 13 -->
'''
== pp_ast_pendant ==[fn_pp_ast_pendant]

**Definition:**

ppmatch* pp_ast_pendant( parray* ast, ppmatch* match )

**Usage:**

Returns the pendant entry of //match//.

If //match// is a match begin, it returns the corresponding end, and reverse.
'''
<!-- NEED 11 -->
'''
== pp_ast_print ==[fn_pp_ast_print]

**Definition:**

void pp_ast_print( parray* ast )

**Usage:**

Print detailed //ast// to stdout.
'''
<!-- NEED 20 -->
'''
== pp_ast_query ==[fn_pp_ast_query]

**Definition:**

ppmatch* pp_ast_query( parray* ast, ppmatch* start, int count, int emit, int depth )

**Usage:**

Queries for the //count//-th element that matches //emit// within the
boundaries of //start//. If //start// is an end-node of a tree item, the
function searches upwards, else downwards. If //start// is NULL, search
begins at the first element.

//depth// specifies an optional, maximum depth of levels to dive in, so a
//depth// of 1 will only match elements in the first level. A //depth// of 0
ignores the deepness.

The function returns the element found.
'''
<!-- NEED 12 -->
'''
== pp_ast_simplify ==[fn_pp_ast_simplify]

**Definition:**

void pp_ast_simplify( parray* ast )

**Usage:**

Print simplified //ast// to stdout.
Only opening matches are printed.
'''
<!-- NEED 12 -->
'''
== pp_ast_tree2svg ==[fn_pp_ast_tree2svg]

**Definition:**

void pp_ast_tree2svg( parray* ast )

**Usage:**

Print //ast// in notation for the tree2svg tool that generates a
graphical view of the parse tree.
'''
<!-- NEED 11 -->
'''
== pp_create ==[fn_pp_create]

**Definition:**

pparse* pp_create( int flags, char* bnf )

**Usage:**

Creates a new parser object with flags //flags// and the grammar //bnf//.
'''
<!-- NEED 11 -->
'''
== pp_free ==[fn_pp_free]

**Definition:**

pparse* pp_free( pparse* par )

**Usage:**

Free parser //par//.
'''
<!-- NEED 11 -->
'''
== pp_gram_create ==[fn_pp_gram_create]

**Definition:**

ppgram* pp_gram_create( void )

**Usage:**

Creates a new ppgram-object.
'''
<!-- NEED 11 -->
'''
== pp_gram_free ==[fn_pp_gram_free]

**Definition:**

ppgram* pp_gram_free( ppgram* g )

**Usage:**

Frees grammar //g// and all its related memory.
'''
<!-- NEED 14 -->
'''
== pp_gram_from_bnf ==[fn_pp_gram_from_bnf]

**Definition:**

pboolean pp_gram_from_bnf( ppgram* g, char* bnf )

**Usage:**

Compiles a grammar definition into a grammar.

//g// is the grammar that receives the result of the parse.
//bnf// is the BNF definition string that defines the grammar.
'''
<!-- NEED 19 -->
'''
== pp_gram_prepare ==[fn_pp_gram_prepare]

**Definition:**

pboolean pp_gram_prepare( ppgram* g )

**Usage:**

Prepares the grammar //g// by computing all necessary stuff required for
runtime and parser generator.

The preparation process includes:
- Symbol and productions IDs
- FIRST-set computation
- Mark left-recursions
- Lexem flag pull-trough
-
'''
<!-- NEED 11 -->
'''
== pp_gram_print ==[fn_pp_gram_print]

**Definition:**

void pp_gram_print( ppgram* g )

**Usage:**

Dumps the grammar //g// to stdout.
'''
<!-- NEED 18 -->
'''
== pp_ll_parse ==[fn_pp_ll_parse]

**Definition:**

pboolean pp_ll_parse( parray** ast, ppgram* grm, char* start, char** end )

**Usage:**

Parses the string //str// using the grammar //grm// using a LL(1) parser.
Parsing stops at least when reading the zero terminator of //str//.

//ast// receives an allocated parray-object with items of //ppmatch//
that describe the prooduced abstract syntax tree.

//end// receives the position of the last character matched.
The function returns TRUE if no parse error orccured.
'''
<!-- NEED 18 -->
'''
== pp_lr_parse ==[fn_pp_lr_parse]

**Definition:**

pboolean pp_lr_parse( parray** ast, ppgram* grm, char* start, char** end )

**Usage:**

Parses the string //str// using the grammar //grm// with a LALR(1) parser.
Parsing stops at least when reading the zero terminator of //str//.

//ast// receives an allocated parray-object with items of //ppmatch// elements
that describe the produced abstract syntax tree.

//end// receives the position of the last character matched.
The function returns TRUE if no parse error occured.
'''
<!-- NEED 16 -->
'''
== pp_parse_to_ast ==[fn_pp_parse_to_ast]

**Definition:**

pboolean pp_parse_to_ast( parray** ast, pparse* par, char* start, char** end )

**Usage:**

Run parser //par// with input //start//.

The function uses the parsing method defined when then parser was created.
//end// receives a pointer to the position where the parser stopped.

It returns a parse-tree to //ast// on success.
'''
<!-- NEED 11 -->
'''
== pp_prod_append ==[fn_pp_prod_append]

**Definition:**

pboolean pp_prod_append( ppprod* p, ppsym* sym )

**Usage:**

Appends the symbol //sym// to the right-hand-side of production //p//.
'''
<!-- NEED 12 -->
'''
== pp_prod_create ==[fn_pp_prod_create]

**Definition:**

ppprod* pp_prod_create( ppgram* g, ppsym* lhs, ... )

**Usage:**

Creates a new production on left-hand-side //lhs//
within the grammar //g//.
'''
<!-- NEED 12 -->
'''
== pp_prod_get ==[fn_pp_prod_get]

**Definition:**

ppprod* pp_prod_get( ppgram* g, int n )

**Usage:**

Get the //n//th production from grammar //g//.
Returns (ppprod*)NULL if no symbol was found.
'''
<!-- NEED 13 -->
'''
== pp_prod_getfromrhs ==[fn_pp_prod_getfromrhs]

**Definition:**

ppsym* pp_prod_getfromrhs( ppprod* p, int off )

**Usage:**

Returns the //off//s element from the right-hand-side of
production //p//. Returns (ppsym*)NULL if the requested element does
not exist.
'''
<!-- NEED 14 -->
'''
== pp_prod_to_str ==[fn_pp_prod_to_str]

**Definition:**

char* pp_prod_to_str( ppprod* p )

**Usage:**

Returns the string representation of production //p//.

The returned pointer is part of //p// and can be referenced multiple times.
It may not be freed by the caller.
'''
<!-- NEED 16 -->
'''
== pp_sym_create ==[fn_pp_sym_create]

**Definition:**

ppsym* pp_sym_create( ppgram* g, ppsymtype type, char* name, char* def )

**Usage:**

Creates a new symbol of the type //type// in the grammar //g//.

//name// is the name for nonterminal symbols, for terminal symbols it
can be left empty.
//def// contains the definition of the symbol in case of a terminal type.
It will be ignored else.
'''
<!-- NEED 12 -->
'''
== pp_sym_get ==[fn_pp_sym_get]

**Definition:**

ppsym* pp_sym_get( ppgram* g, int n )

**Usage:**

Get the //n//th symbol from grammar //g//.
Returns (ppsym*)NULL if no symbol was found.
'''
<!-- NEED 11 -->
'''
== pp_sym_get_by_name ==[fn_pp_sym_get_by_name]

**Definition:**

ppsym* pp_sym_get_by_name( ppgram* g, char* name )

**Usage:**

Get a symbol from grammar //g// by its //name//.
'''
<!-- NEED 11 -->
'''
== pp_sym_get_nameless_term_by_def ==[fn_pp_sym_get_nameless_term_by_def]

**Definition:**

ppsym* pp_sym_get_nameless_term_by_def( ppgram* g, char* name )

**Usage:**

Find a nameless terminal symbol by its pattern.
'''
<!-- NEED 15 -->
'''
== pp_sym_to_str ==[fn_pp_sym_to_str]

**Definition:**

char* pp_sym_to_str( ppsym* sym )

**Usage:**

Returns the string representation of symbol //p//.

Nonterminals are not expanded, they are just returned as their name.
The returned pointer is part of //sym// and can be referenced multiple
times. It may not be freed by the caller.
'''
<!-- NEED 22 -->
'''
== prealloc ==[fn_prealloc]

**Definition:**

void* prealloc( void* oldptr, size_t size )

**Usage:**

Dynamically (re)allocate memory on the heap.

The function is a wrapper to the system-function [realloc() #fn_realloc], but always
accepts a NULL-pointer and immediatelly stops the program if no more memory
can be allocated.

//oldptr// is the pointer to be reallocated. If this is (void*)NULL, [prealloc() #fn_prealloc] works like a normal call to [pmalloc() #fn_pmalloc].

//size// is the size of memory to be reallocated, in bytes.

The function returns the allocated heap memory pointer. The returned memory
address should be freed using [pfree() #fn_pfree] after it is not required anymore.
'''
<!-- NEED 32 -->
'''
== pregex_create ==[fn_pregex_create]

**Definition:**

pregex* pregex_create( char* pat, int flags )

**Usage:**

Constructor function to create a new pregex object.

//pat// is a string providing a regular expression pattern.
//flags// can be a combination of compile- and runtime-flags.

|| Flag | Usage |
| PREGEX_COMP_WCHAR | The regular expression //pat// is provided as wchar_t. |
| PREGEX_COMP_NOANCHORS | Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile regex to be forced nongreedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expression as case insensitive. |
| PREGEX_COMP_STATIC | The regular expression passed should be converted 1:1 asit where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped. |
| PREGEX_RUN_WCHAR | Run regular expression with wchar_t as input. |
| PREGEX_RUN_NOANCHORS | Ignore anchors while processing the regex. |
| PREGEX_RUN_NOREF | Don't create references. |
| PREGEX_RUN_NONGREEDY | Force run regular expression nongreedy. |
| PREGEX_RUN_DEBUG | Debug mode; output some debug to stderr. |


On success, the function returns the allocated pointer to a pregex-object.
This must be freed later using [pregex_free() #fn_pregex_free].
'''
<!-- NEED 21 -->
'''
== pregex_find ==[fn_pregex_find]

**Definition:**

char* pregex_find( pregex* regex, char* start, char** end )

**Usage:**

Find a match for the regular expression //regex// from begin of pointer
//start//.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).

If the expression can be matched, the function returns the pointer to the
position where the match begins. //end// receives the end pointer of the match,
when provided.

The function returns (char*)NULL in case that there is no match.
'''
<!-- NEED 18 -->
'''
== pregex_findall ==[fn_pregex_findall]

**Definition:**

int pregex_findall( pregex* regex, char* start, parray** matches )

**Usage:**

Find all matches for the regular expression //regex// from begin of pointer
//start//, and optionally return matches as an array.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).

The function fills the array //matches//, if provided, with items of size
prange. It returns the total number of matches.
'''
<!-- NEED 15 -->
'''
== pregex_free ==[fn_pregex_free]

**Definition:**

pregex* pregex_free( pregex* regex )

**Usage:**

Destructor function for a pregex-object.

//regex// is the pointer to a pregex-structure that will be released.

Returns always (pregex*)NULL.
'''
<!-- NEED 14 -->
'''
== pregex_match ==[fn_pregex_match]

**Definition:**

pboolean pregex_match( pregex* regex, char* start, char** end )

**Usage:**

Tries to match the regular expression //regex// at pointer //start//.

If the expression can be matched, the function returns TRUE and //end// receives
the pointer to the last matched character.
'''
<!-- NEED 27 -->
'''
== pregex_qmatch ==[fn_pregex_qmatch]

**Definition:**

int pregex_qmatch( char* regex, char* str, int flags, parray** matches )

**Usage:**

Performs a regular expression match on a string, and returns an array of
matches via prange-structures, which hold pointers to the begin- and
end-addresses of all matches.

//regex// is the regular expression pattern to be processed.

//str// is the string on which the pattern will be executed on.

//flags// are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).

//matches// is the array of results to the matched substrings within //str//,
provided as parray-object existing of one prange-object for every match.
It is optional. //matches// must be released with [parray_free() #fn_parray_free] after its usage.

Returns the number of matches, which is the amount of result entries in the
returned array //matches//. If the value is negative, an error occured.
'''
<!-- NEED 27 -->
'''
== pregex_qreplace ==[fn_pregex_qreplace]

**Definition:**

char* pregex_qreplace( char* regex, char* str, char* replace, int flags )

**Usage:**

Replaces all matches of a regular expression pattern within a string with
the replacement. Backreferences can be used with ``$x`` for each opening bracket
within the regular expression.

//regex// is the regular expression pattern to be processed.

//str// is the string on which the pattern will be executed on.

//replace// is the string that will be inserted as replacement for each pattern
match. ``$x`` back-references can be used.

//flags// are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).

Returns an allocated pointer to the generated string with the replacements.
This string must be released after its existence is no longer required by the
caller using [pfree() #fn_pfree].
'''
<!-- NEED 26 -->
'''
== pregex_qsplit ==[fn_pregex_qsplit]

**Definition:**

int pregex_qsplit( char* regex, char* str, int flags, parray** matches )

**Usage:**

Performs a regular expression search on a string and uses the expression as
separator; All strings that where split are returned as //matches//-array.

//regex// is the regular expression pattern to be processed.

//str// is the string on which the pattern will be executed on.

//flags// are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).

//matches// is the array of results to the matched substrings within //str//,
provided as parray-object existing of one prange-object for every match.
It is optional. //matches// must be released with [parray_free() #fn_parray_free] after its usage.

Returns the number of split substrings, which is the amount of result entries in
the returned array //matches//. If the value is negative, an error occured.
'''
<!-- NEED 23 -->
'''
== pregex_replace ==[fn_pregex_replace]

**Definition:**

char* pregex_replace( pregex* regex, char* str, char* replacement )

**Usage:**

Replaces all matches of a regular expression object within a string //str//
with //replacement//. Backreferences in //replacement// can be used with //$x//
for each opening bracket within the regular expression.

//regex// is the pregex-object used for pattern matching.
//str// is the string on which //regex// will be executed.
//replacement// is the string that will be inserted as the replacement for each
match of a pattern described in //regex//. The notation //$x// can be used for
backreferences, where x is the offset of opening brackets in the pattern,
beginning at 1.

The function returns the string with the replaced elements, or (char*)NULL
in error case.
'''
<!-- NEED 24 -->
'''
== pregex_split ==[fn_pregex_split]

**Definition:**

char* pregex_split( pregex* regex, char* start, char** end, char** next )

**Usage:**

Returns the range between string //start// and the next match of //regex//.

This function can be seen as a "negative match", so the substrings that are
not part of the match will be returned.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).
//end// receives the last position of the string before the regex.
//next// receives the pointer of the next split element behind the matched
substring, so //next// should become the next //start// when [pregex_split() #fn_pregex_split] is
called in a loop.

The function returns (char*)NULL in case that there is no more string to split,
else it returns //start//.
'''
<!-- NEED 19 -->
'''
== pregex_splitall ==[fn_pregex_splitall]

**Definition:**

int pregex_splitall( pregex* regex, char* start, parray** matches )

**Usage:**

Split a string at all matches of the regular expression //regex// from
begin of pointer //start//, and optionally return the splitted matches as an
array.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).

The function fills the array //matches//, if provided, with items of size
prange. It returns the total number of matches.
'''
<!-- NEED 24 -->
'''
== pstr_to_wcs ==[fn_pstr_to_wcs]

**Definition:**

wchar_t* pstr_to_wcs( char* str, pboolean freestr )

**Usage:**

This functions converts an UTF-8-multi-byte string into an Unicode
wide-character string.

The string conversion is performed into dynamically allocated memory.
The function wraps [mbstowcs() #fn_mbstowcs], so [set_locale() #fn_set_locale] must be done before this
function works properly.

//str// is the zero-terminated multi-byte-character string to be converted
into a wide-character string.
//freestr// defines if the input-string shall be freed after successfull
conversion, if set to TRUE.

Returns the wide-character pendant of //str// as pointer to dynamically
allocated memory.
'''
<!-- NEED 17 -->
'''
== pstrcasecmp ==[fn_pstrcasecmp]

**Definition:**

int pstrcasecmp( char* s1, char* s2 )

**Usage:**

Compare a string by ignoring case-order.

//s1// is the string to compare with //s2//.
//s2// is the string to compare with //s1//.

Returns 0 if both strings are equal. Returns a value <0 if //s1// is lower than
//s2// or a value >0 if //s1// is greater than //s2//.
'''
<!-- NEED 19 -->
'''
== pstrcatchar ==[fn_pstrcatchar]

**Definition:**

char* pstrcatchar( char* str, char chr )

**Usage:**

Dynamically appends a character to a string.

//str// is the pointer to a string to be appended. If this is (char*)NULL,
the string will be newly allocated. //chr// is the the character to be appended
to str.

Returns a char*-pointer to the (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated. This pointer must
be released with [pfree() #fn_pfree] when its existence is no longer required.
'''
<!-- NEED 24 -->
'''
== pstrcatstr ==[fn_pstrcatstr]

**Definition:**

char* pstrcatstr( char* dest, char* src, pboolean freesrc )

**Usage:**

Dynamically appends a zero-terminated string to a dynamic string.

//str// is the pointer to a zero-terminated string to be appended.
If this is (char*)NULL, the string is newly allocated.

//append// is the string to be appended at the end of //str//.

//release_append// frees the pointer provided as //append// automatically by
this function, if set to TRUE. This parameter has only a comfort-function.

Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL. If //dest// is NULL and //freesrc// is FALSE, the function
automatically returns the pointer //src//. This pointer must be released with [pfree() #fn_pfree] when its existence is no longer required.
'''
<!-- NEED 17 -->
'''
== pstrdup ==[fn_pstrdup]

**Definition:**

char* pstrdup( char* str )

**Usage:**

Duplicate a string in memory.

//str// is the string to be copied in memory. If //str// is provided as NULL,
the function will also return NULL.

Returns a char*-pointer to the newly allocated copy of //str//. This pointer
must be released with [pfree() #fn_pfree] when its existence is no longer required.
'''
<!-- NEED 14 -->
'''
== pstrget ==[fn_pstrget]

**Definition:**

char* pstrget( char* str )

**Usage:**

Savely reads a string.

//str// is the string pointer to be savely read. If //str// is NULL, the
function returns a pointer to a static address holding an empty string.
'''
<!-- NEED 17 -->
'''
== pstrlen ==[fn_pstrlen]

**Definition:**

size_t pstrlen( char* str )

**Usage:**

Return length of a string.

//str// is the parameter string to be evaluated. If (char*)NULL, the function
returns 0. [pstrlen() #fn_pstrlen] is much more saver than [strlen() #fn_strlen] because it returns 0 when
a NULL-pointer is provided.

Returns the length of the string //str//.
'''
<!-- NEED 15 -->
'''
== pstrltrim ==[fn_pstrltrim]

**Definition:**

char* pstrltrim( char* s )

**Usage:**

Removes whitespace on the left of a string.

//s// is the string to be left-trimmed.

Returns //s//.
'''
<!-- NEED 15 -->
'''
== pstrlwr ==[fn_pstrlwr]

**Definition:**

char* pstrlwr( char* s )

**Usage:**

Convert a string to lower-case order.

//s// is the acts both as input and output-string.

Returns //s//.
'''
<!-- NEED 18 -->
'''
== pstrncasecmp ==[fn_pstrncasecmp]

**Definition:**

int pstrncasecmp( char* s1, char* s2, int n )

**Usage:**

Compare a string by ignoring case-order about a maximum of //n// bytes.

//s1// is the string to compare with //s2//.
//s2// is the string to compare with //s1//.
//n// is the number of bytes to compare.

Returns 0 if both strings are equal. Returns a value <0 if //s1// is lower than
//s2// or a value >0 if //s1// is greater than //s2//.
'''
<!-- NEED 24 -->
'''
== pstrncatstr ==[fn_pstrncatstr]

**Definition:**

char* pstrncatstr( char* str, char* append, size_t n )

**Usage:**

Dynamicaly appends a number of n-characters from one string to another
string.

The function works similar to [pstrcatstr() #fn_pstrcatstr], but allows to copy only a maximum
of //n// characters from //append//.

//str// is the pointer to a string to be appended. If this is (char*)NULL,
the string is newly allocated. //append// is the begin of character sequence to
be appended. //n// is the number of characters to be appended to //str//.

Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL. This pointer must be released with [pfree() #fn_pfree] when its existence
is no longer required.
'''
<!-- NEED 24 -->
'''
== pstrndup ==[fn_pstrndup]

**Definition:**

char* pstrndup( char* str, size_t len )

**Usage:**

Duplicate //n// characters from a string in memory.

The function mixes the functionalities of [strdup() #fn_strdup] and [strncpy() #fn_strncpy].
The resulting string will be zero-terminated.

//str// is the parameter string to be duplicated. If this is provided as
(char*)NULL, the function will also return (char*)NULL.
//n// is the the number of characters to be copied and duplicated from //str//.
If //n// is greater than the length of //str//, copying will stop at the zero
terminator.

Returns a char*-pointer to the allocated memory holding the zero-terminated
string duplicate. This pointer must be released with [pfree() #fn_pfree] when its existence
is no longer required.
'''
<!-- NEED 23 -->
'''
== pstrput ==[fn_pstrput]

**Definition:**

char* pstrput( char** str, char* val )

**Usage:**

Assign a string into a dynamically allocated pointer.
 [pstrput() #fn_pstrput] manages the assignment of an dynamically allocated string.

//str// is a pointer receiving the target pointer to be (re)allocated. If
//str// already references a string, this pointer will be freed and reassigned
to a copy of //val//.

//val// is the the string to be assigned to //str// (as a independent copy).

Returns a pointer to the allocated heap memory on success, (char*)NULL else.
This is the same pointer as returned like calling ``*str``. The returned pointer
must be released with [pfree() #fn_pfree] or another call of [pstrput() #fn_pstrput]. Calling [pstrput() #fn_pstrput]
as ``pstrput( &p, (char*)NULL );`` is equivalent to ``p = pfree( &p )``.
'''
<!-- NEED 29 -->
'''
== pstrrender ==[fn_pstrrender]

**Definition:**

char* pstrrender( char* tpl, ... )

**Usage:**

String rendering function.

Inserts multiple values dynamically into the according wildcards positions of
a template string. The function can be compared to the function of [pstrreplace() #fn_pstrreplace], but allows to replace multiple substrings by multiple replacement
strings.

//tpl// is the template string to be rendered with values.
//...// are the set of values to be inserted into the desired position;

These consist of three values each:

- //char* name// as a wildcard-name
- //char* value// as the replacement value for the wildcard
- //pboolean freeflag// defines if //value// shall be freed after processing
-

Returns an allocated string which is the resulting source. This string must be
release by [pfree() #fn_pfree] or another function releasing heap memory when its existence
is no longer required.
'''
<!-- NEED 19 -->
'''
== pstrreplace ==[fn_pstrreplace]

**Definition:**

char* pstrreplace( char* str, char* find, char* replace )

**Usage:**

Replace a substring sequence within a string.

//str// is the string to be replaced in. //find// is the substring to be
matched. //replace// is the the string to be inserted for each match of the
substring //find//.

Returns a pointer to char* containing the allocated string which is the
resulting source. This pointer must be released with [pfree() #fn_pfree] when its existence
is no longer required.
'''
<!-- NEED 15 -->
'''
== pstrrtrim ==[fn_pstrrtrim]

**Definition:**

char* pstrrtrim( char* s )

**Usage:**

Removes trailing whitespace on the right of a string.

//s// is the string to be right-trimmed.

Returns //s//.
'''
<!-- NEED 21 -->
'''
== pstrsplit ==[fn_pstrsplit]

**Definition:**

int pstrsplit( char*** tokens, char* str, char* sep, int limit )

**Usage:**

Splits a string at a delimiting token and returns an allocated array of
token reference pointers.

//tokens// is the an allocated array of tokenized array values.
Requires a pointer to char**.
//str// is the input string to be tokenized.
//sep// is the token separation substring.
//limit// is the token limit; If set to 0, there is no token limit available, so
that as much as possible tokens are read.

Returns the number of separated tokens, or -1 on error.
'''
<!-- NEED 15 -->
'''
== pstrtrim ==[fn_pstrtrim]

**Definition:**

char* pstrtrim( char* s )

**Usage:**

Removes beginning and trailing whitespace from a string.

//s// is the string to be trimmed.

Returns //s//.
'''
<!-- NEED 15 -->
'''
== pstrupr ==[fn_pstrupr]

**Definition:**

char* pstrupr( char* s )

**Usage:**

Convert a string to upper-case order.

//s// is the acts both as input and output-string.

Returns //s//.
'''
<!-- NEED 16 -->
'''
== pvalue_convert ==[fn_pvalue_convert]

**Definition:**

pboolean pvalue_convert( pvalue* val, pvaluetype type )

**Usage:**

Converts a pvalue-structure to any supported type.

//val// is the pvalue-object to be converted.
//type// is the type define to which //val// should be converted to.

The function returns TRUE on success, FALSE else.
'''
<!-- NEED 13 -->
'''
== pvalue_create ==[fn_pvalue_create]

**Definition:**

pvalue* pvalue_create( void )

**Usage:**

Creates a new pvalue-object.

This object must be released after usage using [pvalue_free() #fn_pvalue_free].
'''
<!-- NEED 13 -->
'''
== pvalue_free ==[fn_pvalue_free]

**Definition:**

pvalue* pvalue_free( pvalue* val )

**Usage:**

Frees an allocated pvalue object and all its used memory.

The function always returns (pvalue*)NULL.
'''
<!-- NEED 19 -->
'''
== pvalue_get_char ==[fn_pvalue_get_char]

**Definition:**

char pvalue_get_char( pvalue* val )

**Usage:**

Returns the char data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as char.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_cstr ==[fn_pvalue_get_cstr]

**Definition:**

char* pvalue_get_cstr( pvalue* val )

**Usage:**

Returns the char* data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as char*.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_cwcs ==[fn_pvalue_get_cwcs]

**Definition:**

wchar_t* pvalue_get_cwcs( pvalue* val )

**Usage:**

Returns the wchar_t* data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as wchar_t*.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_double ==[fn_pvalue_get_double]

**Definition:**

double pvalue_get_double( pvalue* val )

**Usage:**

Returns the double data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as double.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_float ==[fn_pvalue_get_float]

**Definition:**

float pvalue_get_float( pvalue* val )

**Usage:**

Returns the float data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as float.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_int ==[fn_pvalue_get_int]

**Definition:**

int pvalue_get_int( pvalue* val )

**Usage:**

Returns the int data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as int.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_long ==[fn_pvalue_get_long]

**Definition:**

long pvalue_get_long( pvalue* val )

**Usage:**

Returns the long data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as long.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_ptr ==[fn_pvalue_get_ptr]

**Definition:**

void* pvalue_get_ptr( pvalue* val )

**Usage:**

Returns the void* data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as void*.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_str ==[fn_pvalue_get_str]

**Definition:**

char* pvalue_get_str( pvalue* val )

**Usage:**

Returns the char* data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as char*.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_ulong ==[fn_pvalue_get_ulong]

**Definition:**

ulong pvalue_get_ulong( pvalue* val )

**Usage:**

Returns the ulong data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as ulong.
This value could be converted from the original value.
'''
<!-- NEED 19 -->
'''
== pvalue_get_wcs ==[fn_pvalue_get_wcs]

**Definition:**

wchar_t* pvalue_get_wcs( pvalue* val )

**Usage:**

Returns the wchar_t* data value if //val//.

If the pvalue contains another data type, it will be converted,
so use it carefully if data loss is not wanted.

//val// is the pointer to the pvalue structure.

The function returns the value assigned to //val// as wchar_t*.
This value could be converted from the original value.
'''
<!-- NEED 13 -->
'''
== pvalue_init ==[fn_pvalue_init]

**Definition:**

pboolean pvalue_init( pvalue* val )

**Usage:**

Initializes a pvalue-element.

//val// is the pointer to the pvalue-structure to be initialized.
'''
<!-- NEED 16 -->
'''
== pvalue_reset ==[fn_pvalue_reset]

**Definition:**

pboolean pvalue_reset( pvalue* val )

**Usage:**

Frees all memory used by a pvalue-element.

All memory used by the element is freed, and the union's structure is reset
to be of type PVALUETYPE_NULL.

//val// is the pointer to pvalue structure.
'''
<!-- NEED 16 -->
'''
== pvalue_set_char ==[fn_pvalue_set_char]

**Definition:**

char pvalue_set_char( pvalue* val, char c )

**Usage:**

Sets the char data value and type.
//val// is the pvalue-object to be set.

//c// is the char value to be assigned to //val//.

The function always returns the value //c//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_cstr ==[fn_pvalue_set_cstr]

**Definition:**

char* pvalue_set_cstr( pvalue* val, char* s )

**Usage:**

Sets the char* data value and type.
//val// is the pvalue-object to be set.

//s// is the char* value to be assigned to //val//.

The function always returns the value //s//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_cwcs ==[fn_pvalue_set_cwcs]

**Definition:**

wchar_t* pvalue_set_cwcs( pvalue* val, wchar_t* ws )

**Usage:**

Sets the wchar_t* data value and type.
//val// is the pvalue-object to be set.

//ws// is the wchar_t* value to be assigned to //val//.

The function always returns the value //ws//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_double ==[fn_pvalue_set_double]

**Definition:**

double pvalue_set_double( pvalue* val, double d )

**Usage:**

Sets the double data value and type.
//val// is the pvalue-object to be set.

//d// is the double value to be assigned to //val//.

The function always returns the value //d//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_float ==[fn_pvalue_set_float]

**Definition:**

float pvalue_set_float( pvalue* val, float f )

**Usage:**

Sets the float data value and type.
//val// is the pvalue-object to be set.

//f// is the float value to be assigned to //val//.

The function always returns the value //f//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_int ==[fn_pvalue_set_int]

**Definition:**

int pvalue_set_int( pvalue* val, int i )

**Usage:**

Sets the int data value and type.
//val// is the pvalue-object to be set.

//i// is the int value to be assigned to //val//.

The function always returns the value //i//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_long ==[fn_pvalue_set_long]

**Definition:**

long pvalue_set_long( pvalue* val, long l )

**Usage:**

Sets the long data value and type.
//val// is the pvalue-object to be set.

//l// is the long value to be assigned to //val//.

The function always returns the value //l//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_ptr ==[fn_pvalue_set_ptr]

**Definition:**

void* pvalue_set_ptr( pvalue* val, void* ptr )

**Usage:**

Sets the void* data value and type.
//val// is the pvalue-object to be set.

//ptr// is the void* value to be assigned to //val//.

The function always returns the value //ptr//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_str ==[fn_pvalue_set_str]

**Definition:**

char* pvalue_set_str( pvalue* val, char* s )

**Usage:**

Sets the char* data value and type.
//val// is the pvalue-object to be set.

//s// is the char* value to be assigned to //val//.

The function always returns the value //s//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_ulong ==[fn_pvalue_set_ulong]

**Definition:**

ulong pvalue_set_ulong( pvalue* val, ulong ul )

**Usage:**

Sets the ulong data value and type.
//val// is the pvalue-object to be set.

//ul// is the ulong value to be assigned to //val//.

The function always returns the value //ul//.
'''
<!-- NEED 16 -->
'''
== pvalue_set_wcs ==[fn_pvalue_set_wcs]

**Definition:**

wchar_t* pvalue_set_wcs( pvalue* val, wchar_t* ws )

**Usage:**

Sets the wchar_t* data value and type.
//val// is the pvalue-object to be set.

//ws// is the wchar_t* value to be assigned to //val//.

The function always returns the value //ws//.
'''
<!-- NEED 15 -->
'''
== pvalue_to_char ==[fn_pvalue_to_char]

**Definition:**

char pvalue_to_char( pvalue* val )

**Usage:**

Converts the current value of //val// into a char value.

//val// is the pvalue-object to convert from.

The function returns the char-value of //val//.
'''
<!-- NEED 15 -->
'''
== pvalue_to_double ==[fn_pvalue_to_double]

**Definition:**

double pvalue_to_double( pvalue* val )

**Usage:**

Converts the current value of //val// into a double value.

//val// is the pvalue-object to convert from.

The function returns the double-value of //val//.
'''
<!-- NEED 15 -->
'''
== pvalue_to_float ==[fn_pvalue_to_float]

**Definition:**

float pvalue_to_float( pvalue* val )

**Usage:**

Converts the current value of //val// into a float value.

//val// is the pvalue-object to convert from.

The function returns the float-value of //val//.
'''
<!-- NEED 15 -->
'''
== pvalue_to_int ==[fn_pvalue_to_int]

**Definition:**

int pvalue_to_int( pvalue* val )

**Usage:**

Converts the current value of //val// into a int value.

//val// is the pvalue-object to convert from.

The function returns the int-value of //val//.
'''
<!-- NEED 15 -->
'''
== pvalue_to_long ==[fn_pvalue_to_long]

**Definition:**

long pvalue_to_long( pvalue* val )

**Usage:**

Converts the current value of //val// into a long value.

//val// is the pvalue-object to convert from.

The function returns the long-value of //val//.
'''
<!-- NEED 15 -->
'''
== pvalue_to_ptr ==[fn_pvalue_to_ptr]

**Definition:**

void* pvalue_to_ptr( pvalue* val )

**Usage:**

Converts the current value of //val// into a void* value.

//val// is the pvalue-object to convert from.

The function returns the void*-value of //val//.
'''
<!-- NEED 15 -->
'''
== pvalue_to_str ==[fn_pvalue_to_str]

**Definition:**

char* pvalue_to_str( pvalue* val )

**Usage:**

Converts the current value of //val// into a char* value.

//val// is the pvalue-object to convert from.

The function returns the char*-value of //val//.
'''
<!-- NEED 15 -->
'''
== pvalue_to_ulong ==[fn_pvalue_to_ulong]

**Definition:**

ulong pvalue_to_ulong( pvalue* val )

**Usage:**

Converts the current value of //val// into a ulong value.

//val// is the pvalue-object to convert from.

The function returns the ulong-value of //val//.
'''
<!-- NEED 15 -->
'''
== pvalue_to_wcs ==[fn_pvalue_to_wcs]

**Definition:**

wchar_t* pvalue_to_wcs( pvalue* val )

**Usage:**

Converts the current value of //val// into a wchar_t* value.

//val// is the pvalue-object to convert from.

The function returns the wchar_t*-value of //val//.
'''
<!-- NEED 17 -->
'''
== pvasprintf ==[fn_pvasprintf]

**Definition:**

int pvasprintf( char** str, char* fmt, va_list ap )

**Usage:**

Implementation and replacement for vasprintf.

//str// is the pointer receiving the resultung, allocated string pointer.
//fmt// is the the format string.
//...// are the parameters according to the placeholders set in //fmt//.

Returns the number of characters written, or -1 in error case.
'''
<!-- NEED 22 -->
'''
== pwcs_to_str ==[fn_pwcs_to_str]

**Definition:**

char* pwcs_to_str( wchar_t* str, pboolean freestr )

**Usage:**

This functions converts a wide-character string into an UTF-8 string.

The string conversion is performed into dynamically allocated memory.
The function wraps the system function [wcstombs() #fn_wcstombs], so [set_locale() #fn_set_locale] must be
called before this function works properly.

//str// is the zero-terminated string to be converted to UTF-8.
//freestr// defines if the input-string shall be freed after successfull
conversion, if set to TRUE.

Returns the UTF-8 character pendant of //str// as pointer to dynamically
allocated memory.
'''
<!-- NEED 18 -->
'''
== pwcscatchar ==[fn_pwcscatchar]

**Definition:**

wchar_t* pwcscatchar( wchar_t* str, wchar_t chr )

**Usage:**

Appends a character to a dynamic wide-character string.

//str// is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated. //chr// is the the character
to be appended to str.

Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated.
'''
<!-- NEED 21 -->
'''
== pwcscatstr ==[fn_pwcscatstr]

**Definition:**

wchar_t* pwcscatstr( wchar_t* dest, wchar_t* src, pboolean freesrc )

**Usage:**

Appends a (possibly dynamic) wide-character string to a dynamic
wide-character string.

//str// is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
//append// is the the string to be appended.
//freesrc// if true, //append// is free'd automatically by this function.

Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL.
'''
<!-- NEED 17 -->
'''
== pwcsdup ==[fn_pwcsdup]

**Definition:**

wchar_t* pwcsdup( wchar_t* str )

**Usage:**

Duplicate a wide-character string in memory.

//str// is the string to be copied in memory. If //str// is provided as NULL,
the function will also return NULL.

Returns a wchar_t*-pointer to the newly allocated copy of //str//. This pointer
must be released with [pfree() #fn_pfree] when its existence is no longer required.
'''
<!-- NEED 14 -->
'''
== pwcslen ==[fn_pwcslen]

**Definition:**

size_t pwcslen( wchar_t* str )

**Usage:**

Saver strlen replacement for wide-character.

//str// is the parameter string to be evaluated. If (wchar_t*)NULL,
the function returns 0.
'''
<!-- NEED 21 -->
'''
== pwcsncatstr ==[fn_pwcsncatstr]

**Definition:**

wchar_t* pwcsncatstr( wchar_t* str, wchar_t* append, size_t n )

**Usage:**

Appends a number of N characters from one wide-character string to a dynamic
string.

//str// is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
//append// is the begin of character sequence to be appended.
//n// is the amount of characters to be appended to str.

Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL.
'''
<!-- NEED 26 -->
'''
== pwcsndup ==[fn_pwcsndup]

**Definition:**

wchar_t* pwcsndup( wchar_t* str, size_t len )

**Usage:**

Duplicate //n// characters from a wide-character string in memory.

The function mixes the functionalities of [wcsdup() #fn_wcsdup] and [wcsncpy() #fn_wcsncpy].
The resulting wide-character string will be zero-terminated.

//str// is the parameter wide-character string to be duplicated.
If this is provided as (wchar_t*)NULL, the function will also return
(wchar_t*)NULL.

//n// is the the number of characters to be copied and duplicated from //str//.
If //n// is greater than the length of //str//, copying will stop at the zero
terminator.

Returns a wchar_t*-pointer to the allocated memory holding the zero-terminated
wide-character string duplicate. This pointer must be released with [pfree() #fn_pfree]
when its existence is no longer required.
'''
<!-- NEED 21 -->
'''
== pwhich ==[fn_pwhich]

**Definition:**

char* pwhich( char* filename, char* directories )

**Usage:**

Figures out a filepath by searching in a PATH definition.

//filename// is the filename to be searched for.

//directories// is a string specifying the directories to search in.
If this is (char*)NULL, the environment variable PATH will be used and
evaluated by using [getenv() #fn_getenv]. The path can be split with multuple pathes
by a character that depends on the current platform (Unix: ":", Windows: ";").

Returns a static pointer to the absolute path that contains the file specifed
as filename, else it will return (char*)NULL.
'''
<!-- NEED 14 -->
'''
== u8_char ==[fn_u8_char]

**Definition:**

wchar_t u8_char( char* str )

**Usage:**

Return single character (as wide-character value) from UTF-8 multi-byte
character string.

//str// is the pointer to character sequence begin.
'''
<!-- NEED 14 -->
'''
== u8_isutf ==[fn_u8_isutf]

**Definition:**

pboolean u8_isutf( unsigned char c )

**Usage:**

Check for UTF-8 character sequence signature.

The function returns TRUE, if the character //c// is the beginning of a UTF-8
character signature, else FALSE.
'''
<!-- NEED 18 -->
'''
== u8_move ==[fn_u8_move]

**Definition:**

char* u8_move( char* str, int count )

**Usage:**

Moves //count// characters ahead in an UTF-8 multi-byte character sequence.

//str// is the pointer to UTF-8 string to begin moving.
//count// is the number of characters to move left.

The function returns the address of the next UTF-8 character sequence after
//count// characters. If the string's end is reached, it will return a
pointer to the zero-terminator.
'''
<!-- NEED 17 -->
'''
== u8_parse_char ==[fn_u8_parse_char]

**Definition:**

wchar_t u8_parse_char( char** ch )

**Usage:**

Read one character from an UTF-8 input sequence.
This character can be escaped, an UTF-8 character or an ordinary ASCII-char.

//chr// is the input- and output-pointer (the pointer is replaced by the pointer
to the next character or escape-sequence within the string.

The function teturns the character code of the parsed character.
'''
<!-- NEED 15 -->
'''
== u8_seqlen ==[fn_u8_seqlen]

**Definition:**

int u8_seqlen(char *s)

**Usage:**

Returns length of next UTF-8 sequence in a multi-byte character string.

//s// is the pointer to begin of UTF-8 sequence.

Returns the number of bytes used for the next character.
