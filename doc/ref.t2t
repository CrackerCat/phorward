


== Macros ==
%NEED:17
%FUNCTION:BEGIN
=== LOG ===[fn_LOG]

**Definition:**

%DEFINITION:BEGIN
LOG( char* format, ... ) - //Macro//
%DEFINITION:END

**Usage:**

Write any logging output to trace.

This function is newer than the previous ones, and allows for a printf-like
format string with variable amount of parameters.

//format// is a [printf() #fn_printf]-like format-string.
//...// parameters in the way they occur in the format-string.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== MSG ===[fn_MSG]

**Definition:**

%DEFINITION:BEGIN
MSG( char* message ) - //Macro//
%DEFINITION:END

**Usage:**

Write a message to trace.

//message// is your message!
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== PARMS ===[fn_PARMS]

**Definition:**

%DEFINITION:BEGIN
PARMS( char* param_name, char* format, param_type parameter ) - //Macro//
%DEFINITION:END

**Usage:**

Write parameter content to trace.

The PARMS-macro is used to write parameter names and values to the program
trace. [PARMS() #fn_PARMS] should - by definition - only be used right behind [PROC() #fn_PROC].
If the logging of variable values is wanted during a function exection to
trace, the [VARS() #fn_VARS]-macro shall be used.

//param_name// is the name of the parameter
//format// is a printf-styled format placeholder.
//parameter// is the parameter itself.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== PPSYM_IS_TERMINAL ===[fn_PPSYM_IS_TERMINAL]

**Definition:**

%DEFINITION:BEGIN
PPSYM_IS_TERMINAL( ppsym* sym ) - //Macro//
%DEFINITION:END

**Usage:**

Check for a symbol type, whether it is configured to be a terminal or a
nonterminal symbol.

Returns TRUE in case //sym// is a terminal symbol, and FALSE otherwise.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== PP_AST_DUMP ===[fn_PP_AST_DUMP]

**Definition:**

%DEFINITION:BEGIN
PP_AST_DUMP( ppast* ast ) - //Macro//
%DEFINITION:END

**Usage:**

Dump AST to trace.

The PP_AST_DUMP-macro is used to dump all relevant contents of a ppast object
into the program trace, for debugging purposes.
 [PP_AST_DUMP() #fn_PP_AST_DUMP] can only be used when the function was trace-enabled by [PROC() #fn_PROC]
before.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== PP_GRAM_DUMP ===[fn_PP_GRAM_DUMP]

**Definition:**

%DEFINITION:BEGIN
PP_GRAM_DUMP( ppgram* g ) - //Macro//
%DEFINITION:END

**Usage:**

Dump grammar to trace.

The PP_GRAM_DUMP-macro is used to dump all relevant contents of a ppgram object
into the program trace, for debugging purposes.
 [PP_GRAM_DUMP() #fn_PP_GRAM_DUMP] can only be used when the function was trace-enabled by [PROC() #fn_PROC]
before.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== PROC ===[fn_PROC]

**Definition:**

%DEFINITION:BEGIN
PROC( char* func_name ) - //Macro//
%DEFINITION:END

**Usage:**

Write function entry to trace.

The PROC-macro introduces a new function level, if compiled with trace.

The PROC-macro must be put behind the last local variable declaration and the
first code line, else it won't compile. A PROC-macro must exists within a
function to allow for other trace-macro usages. If [PROC() #fn_PROC] is used within a
function, the macros [RETURN() #fn_RETURN] or VOIDRET, according to the function return
value, must be used. If PROC is used without RETURN, the trace output will
output a wrong call level depth.

The parameter //func_name// is a static string for the function name.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== RETURN ===[fn_RETURN]

**Definition:**

%DEFINITION:BEGIN
RETURN( function_type return_value ) - //Macro//
%DEFINITION:END

**Usage:**

Write function return to trace.
 [RETURN() #fn_RETURN] can only be used if [PROC() #fn_PROC] is used at the beginning of the function.
For void-functions, use the macro VOIDRET.

//return_value// is return-value of the function.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== VARS ===[fn_VARS]

**Definition:**

%DEFINITION:BEGIN
VARS( char* var_name, char* format, var_type variable ) - //Macro//
%DEFINITION:END

**Usage:**

Write variable content to trace.

The VARS-macro is used to write variable names and values to the program trace.
For parameters taken to functions, the [PARMS() #fn_PARMS]-macro shall be used.

//var_name// is the name of the variable
//format// is a printf-styled format placeholder.
//variable// is the the parameter itself.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== VOIDRET ===[fn_VOIDRET]

**Definition:**

%DEFINITION:BEGIN
VOIDRET - //Macro//
%DEFINITION:END

**Usage:**

Write void function return to trace.

VOIDRET can only be used if [PROC() #fn_PROC] is used at the beginning of the function.
For typed functions, use the macro [RETURN() #fn_RETURN].
%FUNCTION:END
%NEED:32
%FUNCTION:BEGIN
=== parray_for ===[fn_parray_for]

**Definition:**

%DEFINITION:BEGIN
parray_for( parray* array, void* ptr ) - //Macro//
%DEFINITION:END

**Usage:**

Macro that expands into a for-loop iterating a parray-object //array// using
and pointer variable //ptr// as walker.

This macro expands into a for-loop in the format

``` for( ptr = parray_first( array ); ptr; ptr = parray_next( array, ptr ) )

where //ptr// is a walker variable of the same type size of the array's size
for each element.

**Example:**

```
usertype* 	t;
parray		a;

parray_init( &a, sizeof( usertype ), 0 );

parray_for( a, t )
{
	/* Do something with t *}
```
%FUNCTION:END
%NEED:31
%FUNCTION:BEGIN
=== plist_for ===[fn_plist_for]

**Definition:**

%DEFINITION:BEGIN
plist_for( plist* l, plistel* e ) - //Macro//
%DEFINITION:END

**Usage:**

Macro that expands into a for-loop iterating a plist-object //l// using
the element variable //e// as walker.

This macro expands into a for-loop of the format

``` for( e = plist_first( l ); e; e = plist_next( e ) )

where //e// is a walker variable for each element.

**Example:**

```
plist*		my_list;
plistel*	e;

plist_for( my_list, e )
{
	/* Access current element data part *	ptr = (cast*)plist_access( e );
	...
}
```
%FUNCTION:END
== Functions ==
%NEED:16
%FUNCTION:BEGIN
=== p_ccl_add ===[fn_p_ccl_add]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_add( pccl* ccl, wchar_t ch )
%DEFINITION:END

**Usage:**

Integrates a single character into a character-class.

//ccl// is the pointer to the character-class to be affected.
//ch// is the character to be integrated.

The function is a shortcut for [p_ccl_addrange() #fn_p_ccl_addrange].
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== p_ccl_addrange ===[fn_p_ccl_addrange]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_addrange( pccl* ccl, wchar_t begin, wchar_t end )
%DEFINITION:END

**Usage:**

Integrates a character range into a character-class.

//ccl// is the pointer to the character-class to be affected. If //ccl// is
provided as (pccl*)NULL, it will be created by the function.

//begin// is the begin of character range to be integrated.
//end// is the end of character range to be integrated.

If //begin// is greater than //end//, the values will be swapped.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== p_ccl_compare ===[fn_p_ccl_compare]

**Definition:**

%DEFINITION:BEGIN
int p_ccl_compare( pccl* left, pccl* right )
%DEFINITION:END

**Usage:**

Checks for differences in two character-classes.

//left// is the pointer to the first character-class.
//right// is the pointer to the second character-class.

Returns a value < 0 if //left// is lower than //right//, 0 if //left// is
equal to //right// or a value > 0 if //left// is greater than //right//.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== p_ccl_compat ===[fn_p_ccl_compat]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_compat( pccl* l, pccl* r )
%DEFINITION:END

**Usage:**

Checks if the character-classes //l// and //r// are in the same
character universe and compatible for operations.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== p_ccl_count ===[fn_p_ccl_count]

**Definition:**

%DEFINITION:BEGIN
int p_ccl_count( pccl* ccl )
%DEFINITION:END

**Usage:**

Returns the number of characters within a character-class.

//ccl// is a pointer to the character-class to be processed.

Returns the total number of characters the class is holding.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== p_ccl_create ===[fn_p_ccl_create]

**Definition:**

%DEFINITION:BEGIN
pccl* p_ccl_create( int min, int max, char* ccldef )
%DEFINITION:END

**Usage:**

Constructor function to create a new character-class.


Returns a pointer to the newly created character-class. This pointer should be
released with [p_ccl_free() #fn_p_ccl_free] when its existence is no longer required.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== p_ccl_del ===[fn_p_ccl_del]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_del( pccl* ccl, wchar_t ch )
%DEFINITION:END

**Usage:**

Removes a character from a character-class.

//ccl// is the pointer to the character-class to be affected.
//ch// is the character to be removed from //ccl//.

The function is a shortcut for [p_ccl_delrange() #fn_p_ccl_delrange].
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== p_ccl_delrange ===[fn_p_ccl_delrange]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_delrange( pccl* ccl, wchar_t begin, wchar_t end )
%DEFINITION:END

**Usage:**

Removes a character range from a character-class.

//ccl// is the pointer to the character-class to be affected.
//begin// is the begin of character range to be removed.
//end// is the end of character range to be removed.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== p_ccl_diff ===[fn_p_ccl_diff]

**Definition:**

%DEFINITION:BEGIN
pccl* p_ccl_diff( pccl* ccl, pccl* rem )
%DEFINITION:END

**Usage:**

Returns the difference quantity of two character-classes.
All elements from //rem// will be removed from //ccl//, and put into a
new character-class.

//ccl// is the pointer to the first character-class.
//rem// is the pointer to the second character-class.

Returns a new pointer to a copy of //ccl//, without the ranges contained in
//rem//. Returns (pccl*)NULL in case of memory allocation or parameter
error.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== p_ccl_dup ===[fn_p_ccl_dup]

**Definition:**

%DEFINITION:BEGIN
pccl* p_ccl_dup( pccl* ccl )
%DEFINITION:END

**Usage:**

Duplicates a character-class into a new one.

//ccl// is the pointer to the character-class to be duplicated.

Returns a pointer to the duplicate of //ccl//, or (pcrange)NULL
in error case.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== p_ccl_erase ===[fn_p_ccl_erase]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_erase( pccl* ccl )
%DEFINITION:END

**Usage:**

Erases a character-class //ccl//.

The function sets a character-class to zero, as it continas no character range
definitions. The object //ccl// will be still alive. To delete the entire
object, use [p_ccl_free() #fn_p_ccl_free].
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== p_ccl_free ===[fn_p_ccl_free]

**Definition:**

%DEFINITION:BEGIN
pccl* p_ccl_free( pccl* ccl )
%DEFINITION:END

**Usage:**

Frees a character-class //ccl// and all its used memory.

The function always returns (pccl*)NULL.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== p_ccl_get ===[fn_p_ccl_get]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_get( wchar_t* from, wchar_t* to, pccl* ccl, int offset )
%DEFINITION:END

**Usage:**

Return a character or a character-range by its offset.

If the function is called only with pointer //from// provided, and //to// as
(wchar_t*)NULL, it writes the character in //offset//th position of the
character-class into from.

If the function is called both with pointer //from// and //to// provided,
it writes the //begin// and //end// character of the character-range in the
//offset//th position of the character-class into //from// and //to//.

If no character or range with the given offset was found, the function
returns FALSE, meaning that the end of the characters is reached.
On success, the function will always return TRUE.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== p_ccl_instest ===[fn_p_ccl_instest]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_instest( pccl* ccl, wchar_t ch )
%DEFINITION:END

**Usage:**

Tests for a character in case-insensitive-mode if it matches
a character-class.

//ccl// is the pointer to character-class to be tested.
//ch// is the character to be tested.

The function is a shortcut for [p_ccl_testrange() #fn_p_ccl_testrange].

It returns TRUE, if the character matches the class, and FALSE if not.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== p_ccl_intersect ===[fn_p_ccl_intersect]

**Definition:**

%DEFINITION:BEGIN
pccl* p_ccl_intersect( pccl* ccl, pccl* within )
%DEFINITION:END

**Usage:**

Returns a new character-class with all characters that exist in both
provided character-classes.

//ccl// is the pointer to the first character-class.
//within// is the pointer to the second character-class.

Returns a new character-class containing the insersections from //ccl//
and //within//. If there is no intersection between both character-classes,
the function returns (pccl*)NULL.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== p_ccl_negate ===[fn_p_ccl_negate]

**Definition:**

%DEFINITION:BEGIN
pccl* p_ccl_negate( pccl* ccl )
%DEFINITION:END

**Usage:**

Negates all ranges in a character-class.

//ccl// is the pointer to the character-class to be negated.

Returns a pointer to //ccl//.
%FUNCTION:END
%NEED:25
%FUNCTION:BEGIN
=== p_ccl_parse ===[fn_p_ccl_parse]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_parse( pccl* ccl, char* ccldef, pboolean extend )
%DEFINITION:END

**Usage:**

Parses the character-class definition provided in //ccldef// and assigns
this definition to the character-class //ccl//. //ccldef// may contain
UTF-8 formatted input. Escape-sequences will be interpretered to their correct
character representations.

A typical character-class definition simply exists of single characters and
range definitions. For example, "$A-Z#0-9" defines a character-class that
consists of the characters "$#0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".

The parameter //extend// specifies, if the provided character-class overwrites
(//extend// = FALSE) or extends (//extend// = TRUE) the provided
character-class. This means that definitions that already exist in the
character-class, should be erased first or not.

The function returns TRUE on success, and FALSE on an error.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== p_ccl_parsechar ===[fn_p_ccl_parsechar]

**Definition:**

%DEFINITION:BEGIN
size_t p_ccl_parsechar( wchar_t* retc, char *str, pboolean escapeseq )
%DEFINITION:END

**Usage:**

Reads a character from a string. The character may exist of one single
character or it may be made up of an escape sequence or UTF-8 character.
The function returns the number of bytes read.

//retc// is the return pointer for the character code of the escaped string.
//str// is the begin pointer of the string at which character parsing begins.
If //escapeseq// is TRUE, the function regards escape sequences, else it ignores
them.

Returns the number of bytes that had been read for the character.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== p_ccl_parseshorthand ===[fn_p_ccl_parseshorthand]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_parseshorthand( pccl* ccl, char **str )
%DEFINITION:END

**Usage:**

Tries to parse a shorthand sequence from a string. This matches the
shorthands \w, \W, \d, \D, \s and \S. If it matches, all characters are
added to //ccl//.

The function returns TRUE in case a shorthand has been parsed. If so,
the pointer //str// is moved the characters consumed.

If no shorthand sequence could be found, it returns FALSE, remaining //ccl//
untouched.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== p_ccl_print ===[fn_p_ccl_print]

**Definition:**

%DEFINITION:BEGIN
void p_ccl_print( FILE* stream, pccl* ccl, int break_after )
%DEFINITION:END

**Usage:**

Print character-class to output stream.
This function is provided for debug-purposes only.

//stream// is the output stream to dump the character-class to; This can be
left (FILE*)NULL, so //stderr// will be used.
//ccl// is the pointer to character-class

//break_after// defines:
- if < 0 print with pointer info
- if 0 print all into one line
- if > 0 print linewise
-
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== p_ccl_size ===[fn_p_ccl_size]

**Definition:**

%DEFINITION:BEGIN
int p_ccl_size( pccl* ccl )
%DEFINITION:END

**Usage:**

Returns the number of range pairs within a character-class.

//ccl// is a pointer to the character-class to be processed.

To retrieve the number of characters in a character-class, use [p_ccl_count() #fn_p_ccl_count] instead.

Returns the number of pairs the charclass holds.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== p_ccl_test ===[fn_p_ccl_test]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_test( pccl* ccl, wchar_t ch )
%DEFINITION:END

**Usage:**

Tests a character-class if it cointains a character.

//ccl// is the pointer to character-class to be tested.
//ch// is the character to be tested.

The function is a shortcut for [p_ccl_testrange() #fn_p_ccl_testrange].

It returns TRUE, if the character matches the class, and FALSE if not.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== p_ccl_testrange ===[fn_p_ccl_testrange]

**Definition:**

%DEFINITION:BEGIN
pboolean p_ccl_testrange( pccl* ccl, wchar_t begin, wchar_t end )
%DEFINITION:END

**Usage:**

Tests a character-class to match a character range.

//ccl// is a pointer to the character-class to be tested.
//begin// is the begin of character-range to be tested.
//end// is the end of character-range to be tested.

Returns TRUE if the entire character range matches the class, and FALSE if not.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== p_ccl_to_str ===[fn_p_ccl_to_str]

**Definition:**

%DEFINITION:BEGIN
char* p_ccl_to_str( pccl* ccl, pboolean escape )
%DEFINITION:END

**Usage:**

Converts a character-class back to a string representation of the
character-class definition, which in turn can be converted back into a
character-class using [p_ccl_create() #fn_p_ccl_create].

//ccl// is the pointer to character-class to be converted.
//escape//, if TRUE, escapes "unprintable" characters in their hexadecimal
representation. If FALSE, it prints all characters, except the zero, which will
be returned as "\0"

Returns a pointer to the generated string that represents the charclass.
The returned pointer belongs to the //ccl// and is managed by the
character-class handling functions, so it should not be freed manually.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== p_ccl_union ===[fn_p_ccl_union]

**Definition:**

%DEFINITION:BEGIN
pccl* p_ccl_union( pccl* ccl, pccl* add )
%DEFINITION:END

**Usage:**

Unions two character-classes into a new, normalized one.

//ccl// is the pointer to the character-class that will be extended to all
ranges contained in //add//.
//add// is character-class that will be unioned with //ccl//.

The function creates and returns a new character-class that is the union
if //ccl// and //add//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_convert ===[fn_pany_convert]

**Definition:**

%DEFINITION:BEGIN
pboolean pany_convert( pany* val, panytype type )
%DEFINITION:END

**Usage:**

Converts a pany-structure to any supported type.

//val// is the pany-object to be converted.
//type// is the type define to which //val// should be converted to.

The function returns TRUE on success, FALSE else.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== pany_copy ===[fn_pany_copy]

**Definition:**

%DEFINITION:BEGIN
pboolean pany_copy( pany* dest, pany* src )
%DEFINITION:END

**Usage:**

Copy any value from //src// into //dest//.

//dest// will be reset and stand on its own after copying.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_create ===[fn_pany_create]

**Definition:**

%DEFINITION:BEGIN
pany* pany_create( char* str )
%DEFINITION:END

**Usage:**

Creates a new pany-object.

It allows for parsing a value from //str//.

This object must be released after usage using [pany_free() #fn_pany_free].
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pany_dup ===[fn_pany_dup]

**Definition:**

%DEFINITION:BEGIN
pany* pany_dup( pany* src )
%DEFINITION:END

**Usage:**

Duplicate the object //src// into a new object that stands on its own.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_fprint ===[fn_pany_fprint]

**Definition:**

%DEFINITION:BEGIN
void pany_fprint( FILE* stream, pany* val )
%DEFINITION:END

**Usage:**

Print the type and value of //val// to //stream//
without any conversion. This function shall be used for debug only.

//stream// is the stream to write to.
//val// is the pany-object to be printed.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== pany_free ===[fn_pany_free]

**Definition:**

%DEFINITION:BEGIN
pany* pany_free( pany* val )
%DEFINITION:END

**Usage:**

Frees an allocated pany object and all its used memory.

The function always returns (pany*)NULL.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_bool ===[fn_pany_get_bool]

**Definition:**

%DEFINITION:BEGIN
pboolean pany_get_bool( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``pboolean``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as pboolean.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_char ===[fn_pany_get_char]

**Definition:**

%DEFINITION:BEGIN
char pany_get_char( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``char``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as char.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_cstr ===[fn_pany_get_cstr]

**Definition:**

%DEFINITION:BEGIN
char* pany_get_cstr( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``char*``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as char*.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_cwcs ===[fn_pany_get_cwcs]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pany_get_cwcs( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``wchar_t*``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as wchar_t*.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_double ===[fn_pany_get_double]

**Definition:**

%DEFINITION:BEGIN
double pany_get_double( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``double``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as double.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_float ===[fn_pany_get_float]

**Definition:**

%DEFINITION:BEGIN
float pany_get_float( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``float``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as float.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_int ===[fn_pany_get_int]

**Definition:**

%DEFINITION:BEGIN
int pany_get_int( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``int``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as int.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_long ===[fn_pany_get_long]

**Definition:**

%DEFINITION:BEGIN
long pany_get_long( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``long``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as long.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_ptr ===[fn_pany_get_ptr]

**Definition:**

%DEFINITION:BEGIN
void* pany_get_ptr( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``void*``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as void*.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_str ===[fn_pany_get_str]

**Definition:**

%DEFINITION:BEGIN
char* pany_get_str( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``char*``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as char*.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_ulong ===[fn_pany_get_ulong]

**Definition:**

%DEFINITION:BEGIN
unsigned long pany_get_ulong( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``unsigned long``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as unsigned long.
This value could be converted from the original value.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pany_get_wcs ===[fn_pany_get_wcs]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pany_get_wcs( pany* val )
%DEFINITION:END

**Usage:**

Returns the ``wchar_t*``-value of //val//.

//val// is the pointer to the pany-object.

If the pany-object exists in another data type, it will be converted.
The function returns the value assigned to //val// as wchar_t*.
This value could be converted from the original value.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== pany_init ===[fn_pany_init]

**Definition:**

%DEFINITION:BEGIN
pboolean pany_init( pany* val )
%DEFINITION:END

**Usage:**

Initializes a pany-element.

//val// is the pointer to the pany-structure to be initialized.
%FUNCTION:END
%NEED:24
%FUNCTION:BEGIN
=== pany_parse ===[fn_pany_parse]

**Definition:**

%DEFINITION:BEGIN
pboolean pany_parse( pany* val, char* str, panytype enforce )
%DEFINITION:END

**Usage:**

Parse any value from a string.

The function will check and ignore for leading and following whitespace, and
matches long integer, double values and strings.

If a string is encapsulated between C-styled string or character tokens (", '),
the content between the delimiters will be taken as a string and ran through an
escaping function.

Any other content is taken as string. If the parameter //enforce// is set to
an desired PANY_-type, this type will be enforced, and no special recognition
is done.

This function tries to detect
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_reset ===[fn_pany_reset]

**Definition:**

%DEFINITION:BEGIN
pboolean pany_reset( pany* val )
%DEFINITION:END

**Usage:**

Frees all memory used by a pany-element.

All memory used by the element is freed, and the union's structure is reset
to be of type PANYTYPE_NULL.

//val// is the pointer to pany structure.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_bool ===[fn_pany_set_bool]

**Definition:**

%DEFINITION:BEGIN
pboolean pany_set_bool( pany* val, pboolean b )
%DEFINITION:END

**Usage:**

Sets the ``pboolean``-value and type of //va//.

//val// is the pany-object to be set.
//b// is the ``pboolean``-value to be assigned to //val//.

The function always returns the value //b//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_char ===[fn_pany_set_char]

**Definition:**

%DEFINITION:BEGIN
char pany_set_char( pany* val, char c )
%DEFINITION:END

**Usage:**

Sets the ``char``-value and type of //va//.

//val// is the pany-object to be set.
//c// is the ``char``-value to be assigned to //val//.

The function always returns the value //c//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_cstr ===[fn_pany_set_cstr]

**Definition:**

%DEFINITION:BEGIN
char* pany_set_cstr( pany* val, char* s )
%DEFINITION:END

**Usage:**

Sets the ``char*``-value and type of //va//.

//val// is the pany-object to be set.
//s// is the ``char*``-value to be assigned to //val//.

The function always returns the value //s//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_cwcs ===[fn_pany_set_cwcs]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pany_set_cwcs( pany* val, wchar_t* ws )
%DEFINITION:END

**Usage:**

Sets the ``wchar_t*``-value and type of //va//.

//val// is the pany-object to be set.
//ws// is the ``wchar_t*``-value to be assigned to //val//.

The function always returns the value //ws//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_double ===[fn_pany_set_double]

**Definition:**

%DEFINITION:BEGIN
double pany_set_double( pany* val, double d )
%DEFINITION:END

**Usage:**

Sets the ``double``-value and type of //va//.

//val// is the pany-object to be set.
//d// is the ``double``-value to be assigned to //val//.

The function always returns the value //d//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_float ===[fn_pany_set_float]

**Definition:**

%DEFINITION:BEGIN
float pany_set_float( pany* val, float f )
%DEFINITION:END

**Usage:**

Sets the ``float``-value and type of //va//.

//val// is the pany-object to be set.
//f// is the ``float``-value to be assigned to //val//.

The function always returns the value //f//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_int ===[fn_pany_set_int]

**Definition:**

%DEFINITION:BEGIN
int pany_set_int( pany* val, int i )
%DEFINITION:END

**Usage:**

Sets the ``int``-value and type of //va//.

//val// is the pany-object to be set.
//i// is the ``int``-value to be assigned to //val//.

The function always returns the value //i//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_long ===[fn_pany_set_long]

**Definition:**

%DEFINITION:BEGIN
long pany_set_long( pany* val, long l )
%DEFINITION:END

**Usage:**

Sets the ``long``-value and type of //va//.

//val// is the pany-object to be set.
//l// is the ``long``-value to be assigned to //val//.

The function always returns the value //l//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_ptr ===[fn_pany_set_ptr]

**Definition:**

%DEFINITION:BEGIN
void* pany_set_ptr( pany* val, void* ptr )
%DEFINITION:END

**Usage:**

Sets the ``void*``-value and type of //va//.

//val// is the pany-object to be set.
//ptr// is the ``void*``-value to be assigned to //val//.

The function always returns the value //ptr//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_str ===[fn_pany_set_str]

**Definition:**

%DEFINITION:BEGIN
char* pany_set_str( pany* val, char* s )
%DEFINITION:END

**Usage:**

Sets the ``char*``-value and type of //va//.

//val// is the pany-object to be set.
//s// is the ``char*``-value to be assigned to //val//.

The function always returns the value //s//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_ulong ===[fn_pany_set_ulong]

**Definition:**

%DEFINITION:BEGIN
unsigned long pany_set_ulong( pany* val, unsigned long ul )
%DEFINITION:END

**Usage:**

Sets the ``unsigned long``-value and type of //va//.

//val// is the pany-object to be set.
//ul// is the ``unsigned long``-value to be assigned to //val//.

The function always returns the value //ul//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pany_set_wcs ===[fn_pany_set_wcs]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pany_set_wcs( pany* val, wchar_t* ws )
%DEFINITION:END

**Usage:**

Sets the ``wchar_t*``-value and type of //va//.

//val// is the pany-object to be set.
//ws// is the ``wchar_t*``-value to be assigned to //val//.

The function always returns the value //ws//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_bool ===[fn_pany_to_bool]

**Definition:**

%DEFINITION:BEGIN
pboolean pany_to_bool( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a pboolean value.

//val// is the pany-object to convert from.

The function returns the pboolean-value of //val//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_char ===[fn_pany_to_char]

**Definition:**

%DEFINITION:BEGIN
char pany_to_char( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a char value.

//val// is the pany-object to convert from.

The function returns the char-value of //val//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_double ===[fn_pany_to_double]

**Definition:**

%DEFINITION:BEGIN
double pany_to_double( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a double value.

//val// is the pany-object to convert from.

The function returns the double-value of //val//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_float ===[fn_pany_to_float]

**Definition:**

%DEFINITION:BEGIN
float pany_to_float( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a float value.

//val// is the pany-object to convert from.

The function returns the float-value of //val//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_int ===[fn_pany_to_int]

**Definition:**

%DEFINITION:BEGIN
int pany_to_int( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a int value.

//val// is the pany-object to convert from.

The function returns the int-value of //val//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_long ===[fn_pany_to_long]

**Definition:**

%DEFINITION:BEGIN
long pany_to_long( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a long value.

//val// is the pany-object to convert from.

The function returns the long-value of //val//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_ptr ===[fn_pany_to_ptr]

**Definition:**

%DEFINITION:BEGIN
void* pany_to_ptr( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a void* value.

//val// is the pany-object to convert from.

The function returns the void*-value of //val//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_str ===[fn_pany_to_str]

**Definition:**

%DEFINITION:BEGIN
char* pany_to_str( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a char* value.

//val// is the pany-object to convert from.

The function returns the char*-value of //val//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_ulong ===[fn_pany_to_ulong]

**Definition:**

%DEFINITION:BEGIN
unsigned long pany_to_ulong( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a unsigned long value.

//val// is the pany-object to convert from.

The function returns the unsigned long-value of //val//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pany_to_wcs ===[fn_pany_to_wcs]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pany_to_wcs( pany* val )
%DEFINITION:END

**Usage:**

Converts the current value of //val// into a wchar_t* value.

//val// is the pany-object to convert from.

The function returns the wchar_t*-value of //val//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== parray_count ===[fn_parray_count]

**Definition:**

%DEFINITION:BEGIN
size_t parray_count( parray* array )
%DEFINITION:END

**Usage:**

Returns the number of elements in a array.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_create ===[fn_parray_create]

**Definition:**

%DEFINITION:BEGIN
parray* parray_create( size_t size, size_t chunk )
%DEFINITION:END

**Usage:**

Create a new parray as an object with an element allocation size //size//
and a reallocation-chunk-size of //chunk//.

The returned memory must be released with [parray_free() #fn_parray_free].
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== parray_erase ===[fn_parray_erase]

**Definition:**

%DEFINITION:BEGIN
pboolean parray_erase( parray* array )
%DEFINITION:END

**Usage:**

Erase a dynamic array.

The array must not be reinitialized after destruction, using [parray_init() #fn_parray_init].

//array// is the pointer to the array to be erased.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_first ===[fn_parray_first]

**Definition:**

%DEFINITION:BEGIN
void* parray_first( parray* array )
%DEFINITION:END

**Usage:**

Access first element of the array.

Returns the address of the accessed item, and (void*)NULL if nothing is in
the array.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== parray_free ===[fn_parray_free]

**Definition:**

%DEFINITION:BEGIN
parray* parray_free( parray* array )
%DEFINITION:END

**Usage:**

Releases all the memory //array// uses and destroys the array object.

The function always returns (parray*)NULL.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== parray_get ===[fn_parray_get]

**Definition:**

%DEFINITION:BEGIN
void* parray_get( parray* array, size_t offset )
%DEFINITION:END

**Usage:**

Access an element from the array by its offset position from the left.

//array// is the pointer to array where to access the element from.
//offset// is the offset of the element to be accessed from the array's
base address.

Returns the address of the accessed item, and (void*)NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the last of array).

Use [parray_rget() #fn_parray_rget] for access items from the end.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== parray_init ===[fn_parray_init]

**Definition:**

%DEFINITION:BEGIN
pboolean parray_init( parray* array, size_t size, size_t chunk )
%DEFINITION:END

**Usage:**

Performs an array initialization.

//array// is the pointer to the array to be initialized.

//size// defines the size of one array element, in bytes.
This should be evaluated using the [sizeof() #fn_sizeof]-macro.

//chunk// defines the chunk size, where an array-(re)allocation will be performed.
If, e.g. this is set to 128, then, if the 128th item is created within the
array, a realloction is done. Once allocated memory remains until the array is
freed again.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== parray_insert ===[fn_parray_insert]

**Definition:**

%DEFINITION:BEGIN
void* parray_insert( parray* array, size_t offset, void* item )
%DEFINITION:END

**Usage:**

Insert item //item// at //offset// into array //array//.
Items right to //offset// will move up.

Gap space between the offset is filled with zero elements;
Handle with care!
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_iter ===[fn_parray_iter]

**Definition:**

%DEFINITION:BEGIN
void parray_iter( parray* array, parrayfn callback )
%DEFINITION:END

**Usage:**

Iterates over //array//.

Iterates over all items of //array// and calls the function //callback// on
every item.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_last ===[fn_parray_last]

**Definition:**

%DEFINITION:BEGIN
void* parray_last( parray* array )
%DEFINITION:END

**Usage:**

Access last element of the array.

Returns the address of the accessed item, and (void*)NULL if nothing is in
the array.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_malloc ===[fn_parray_malloc]

**Definition:**

%DEFINITION:BEGIN
void* parray_malloc( parray* array )
%DEFINITION:END

**Usage:**

Pushes and "allocates" an empty element on the array.

This function is just a shortcut to ```parray_push( array, (void*)NULL )```,
and the memory of the pushed element is initialized to zero.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_next ===[fn_parray_next]

**Definition:**

%DEFINITION:BEGIN
void* parray_next( parray* array, void* ptr )
%DEFINITION:END

**Usage:**

Access next element from //ptr// in //array//.

Returns the address of the next element, and (void*)NULL if the access gets
out of bounds.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== parray_offset ===[fn_parray_offset]

**Definition:**

%DEFINITION:BEGIN
size_t parray_offset( parray* array, void* ptr )
%DEFINITION:END

**Usage:**

Return offset of element //ptr// in array //array//.
Returns the offset of //ptr// in //array//.
The function returns the size of the array (which is an invalid offset)
if //ptr// is not part of //array//.

To check if a pointer belongs to an array, call [parray_partof() #fn_parray_partof].
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== parray_partof ===[fn_parray_partof]

**Definition:**

%DEFINITION:BEGIN
pboolean parray_partof( parray* array, void* ptr )
%DEFINITION:END

**Usage:**

Returns TRUE, if //ptr// is an element of array //array//.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== parray_pop ===[fn_parray_pop]

**Definition:**

%DEFINITION:BEGIN
void* parray_pop( parray* array )
%DEFINITION:END

**Usage:**

Removes an element from the end of an array.

The function returns the pointer of the popped item. Because dynamic arrays only
grow and no memory is freed, the returned data pointer is still valid, and will
only be overidden with the next push operation.

//array// is the pointer to array where to pop an item off.

The function returns the address of the popped item, and (void*)NULL if the
item could not be popped (e.g. array is empty).
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_prev ===[fn_parray_prev]

**Definition:**

%DEFINITION:BEGIN
void* parray_prev( parray* array, void* ptr )
%DEFINITION:END

**Usage:**

Access previous element from //ptr// in //array//.

Returns the address of the previous element, and (void*)NULL if the access gets
out of bounds.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== parray_push ===[fn_parray_push]

**Definition:**

%DEFINITION:BEGIN
void* parray_push( parray* array, void* item )
%DEFINITION:END

**Usage:**

Appends an element to the end of the array.

The element's memory is copied during the push. The item must be of the same
memory size as used at array initialization.

//array// is the pointer to array where to push an item on.

//item// is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left (void*)NULL, so no memory will be copied.

The function returns the address of the newly pushed item, and (void*)NULL if
the item could not be pushed.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== parray_put ===[fn_parray_put]

**Definition:**

%DEFINITION:BEGIN
void* parray_put( parray* array, size_t offset, void* item )
%DEFINITION:END

**Usage:**

Put an element //item// at position //offset// of array //array//.

//array// is the pointer to array where to put the element to.
//offset// is the offset of the element to be set.
//item// is a pointer to the memory that will be copied into the
position at //offset//. If this is NULL, the position at //offset// will be
set to zero.

Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== parray_remove ===[fn_parray_remove]

**Definition:**

%DEFINITION:BEGIN
void* parray_remove( parray* array, size_t offset, void** item )
%DEFINITION:END

**Usage:**

Remove item on //offset// from array //array//.

The removed item will be copied into //item//, if //item// is not NULL.
The function returns the memory of the removed item (it will contain the
moved up data part or invalid memory, if on the end).
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_reserve ===[fn_parray_reserve]

**Definition:**

%DEFINITION:BEGIN
pboolean parray_reserve( parray* array, size_t n )
%DEFINITION:END

**Usage:**

Reserves memory for //n// items in //array//.

This function is only used to assume that no memory reallocation is done when
the next //n// items are inserted/malloced.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== parray_rget ===[fn_parray_rget]

**Definition:**

%DEFINITION:BEGIN
void* parray_rget( parray* array, size_t offset )
%DEFINITION:END

**Usage:**

Access an element from the array by its offset position from the right.

//array// is the pointer to array where to access the element from.
//offset// is the offset of the element to be accessed from the array's
base address.

Returns the address of the accessed item, and (void*)NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the bottom of
the array).

Use [parray_get() #fn_parray_get] for access items from the begin.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_riter ===[fn_parray_riter]

**Definition:**

%DEFINITION:BEGIN
void parray_riter( parray* array, parrayfn callback )
%DEFINITION:END

**Usage:**

Iterates backwards over //array//.

Backwardly iterates over all items of //array// and calls the function
//callback// on every item.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_rmalloc ===[fn_parray_rmalloc]

**Definition:**

%DEFINITION:BEGIN
void* parray_rmalloc( parray* array )
%DEFINITION:END

**Usage:**

Unshifts and "allocates" an empty element on the array.

This function is just a shortcut to ```parray_unshift( array, (void*)NULL )```,
and the memory of the unshifted element is initialized to zero.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== parray_rput ===[fn_parray_rput]

**Definition:**

%DEFINITION:BEGIN
void* parray_rput( parray* array, size_t offset, void* item )
%DEFINITION:END

**Usage:**

Put an element //item// at position //offset// from the right of
array //array//.

//array// is the pointer to array where to put the element to.
//offset// is the offset of the element to be set.
//item// is a pointer to the memory that will be copied into the
position at //offset//. If this is NULL, the position at //offset// will be
set to zero.

Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== parray_shift ===[fn_parray_shift]

**Definition:**

%DEFINITION:BEGIN
void* parray_shift( parray* array )
%DEFINITION:END

**Usage:**

Removes an element from the begin of an array.

The function returns the pointer of the shifted item.
Because dynamic arrays only grow and no memory is freed, the returned data
pointer is still valid, and will only be overidden with the next unshift
operation.

//array// is the pointer to array where to pop an item off.

The function returns the address of the shifted item, and (void*)NULL if the
item could not be popped (e.g. array is empty).
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== parray_swap ===[fn_parray_swap]

**Definition:**

%DEFINITION:BEGIN
void* parray_swap( parray* array, size_t pos1, size_t pos2 )
%DEFINITION:END

**Usage:**

Swap two elements of an array.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== parray_unshift ===[fn_parray_unshift]

**Definition:**

%DEFINITION:BEGIN
void* parray_unshift( parray* array, void* item )
%DEFINITION:END

**Usage:**

Appends an element to the begin of the array.

The elements memory is copied during the unshift. The item must be of the same
memory size as used at array initialization.

//array// is the pointer to array where to push an item to the beginning.

//item// is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left (void*)NULL, so no memory will be copied.

The function returns the address of the newly unhshifted item, and (void*)NULL
if the item could not be unshifted.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pasprintf ===[fn_pasprintf]

**Definition:**

%DEFINITION:BEGIN
char* pasprintf( char* fmt, ... )
%DEFINITION:END

**Usage:**

Implementation and replacement for asprintf. [pasprintf() #fn_pasprintf] takes only the
format-string and various arguments. It outputs an allocated string to be freed
later on.

//fmt// is the format string.
//...// are the parameters according to the placeholders set in //fmt//.

Returns a char* Returns the allocated string which cointains the format string
with inserted values.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pbasename ===[fn_pbasename]

**Definition:**

%DEFINITION:BEGIN
char* pbasename( char* path )
%DEFINITION:END

**Usage:**

Returns the basename of a file.

//path// is the file path pointer.

Returns a pointer to the basename, which is a part of //path//.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pdbl_to_str ===[fn_pdbl_to_str]

**Definition:**

%DEFINITION:BEGIN
char* pdbl_to_str( double d )
%DEFINITION:END

**Usage:**

Converts a double-value into an allocated string buffer.

//d// is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become "1.65" in its
string representation.

Returns a pointer to the newly allocated string, which contains the
string-representation of the double value. This pointer must be released
by the caller.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pdbl_to_wcs ===[fn_pdbl_to_wcs]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pdbl_to_wcs( double d )
%DEFINITION:END

**Usage:**

Converts a double-value into an allocated wide-character string buffer.

//d// is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become L"1.65" in its
wide-character string representation.

Returns a pointer to the newly allocated wide-character string, which contains
the string-representation of the double value. This pointer must be released
by the caller.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pfileexists ===[fn_pfileexists]

**Definition:**

%DEFINITION:BEGIN
pboolean pfileexists( char* filename )
%DEFINITION:END

**Usage:**

Checks for file existence.

//filename// is the path to a file that will be checked.

Returns TRUE on success, FALSE if not.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pfiletostr ===[fn_pfiletostr]

**Definition:**

%DEFINITION:BEGIN
pboolean pfiletostr( char** cont, char* filename )
%DEFINITION:END

**Usage:**

Maps the content of an entire file into memory.

//cont// is the file content return pointer.
//filename// is the path to file to be mapped

The function returns TRUE on success.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pfree ===[fn_pfree]

**Definition:**

%DEFINITION:BEGIN
void* pfree( void* ptr )
%DEFINITION:END

**Usage:**

Free allocated memory.

The function is a wrapper for the system-function [free() #fn_free], but accepts
NULL-pointers and returns a (void*)NULL pointer for direct pointer memory reset.

It could be used this way to immedatelly reset a pointer to NULL:

``` ptr = pfree( ptr );

//ptr// is the pointer to be freed.

Returns always (void*)NULL.
%FUNCTION:END
%NEED:37
%FUNCTION:BEGIN
=== pgetopt ===[fn_pgetopt]

**Definition:**

%DEFINITION:BEGIN
int pgetopt( char* opt, char** param, int* next, int argc, char** argv, char* optstr, char* loptstr, int idx )
%DEFINITION:END

**Usage:**

Implementation of a command-line option interpreter.

This function works similar to the [getopt() #fn_getopt] functions of the GNU Standard
Library, but uses a different style of parameter submit.

It supports both short- and long- option-style parameters.
This function is currently under recent development relating to the issues it
is used for. It can't be seen as compatible or feature-proven, and does not
follow a clear concept right now.

- //opt// is a pointer to a buffer with enough space to store the requested parameter to. For short parameters, this is only one char, for long-parameters the full name. The string will be zero-terminated.
- //param// is a pointer to store a possible parameter value to, if the detected option allows for parameters.
- //next// receives the index in argv of the next evaluated option. It can be left (int*)NULL. It points to the next valid index in argv[] after all parameters have been evaluated. Check it for < argc, to point to valid data.
- //argc// is the argument count as taken from the [main() #fn_main] function.
- //argv// are the argument values as taken from the [main() #fn_main] function.
- //optstr// contains the possible short-options. This is a string where each character defines an option. If an option takes a parameter, a colon (:) is submitted. E.g. "abc:def:g". The Options "-c" and "-f" will take a parameter that is
returned to param. This parameter can be (char*)NULL.
- //loptstr// contains the possible long-options. This is a string containing all long option names, each separated by a blank. Long options taking parameters have an attached colon (:) to the name.  E.g. "hello world: next" defines three long options, where option 'world' takes one parameter that is returned to param. This parameter can be (char*)NULL.
- //idx// is the index of the requested option, 0 for the first option behind argv[0].
-

The function returns 0, if the parameter with the given index was
successfully evaluated. It returns 1, if there are still command-line
parameters, but not as part of options. The parameter //param// will receive
the given pointer. It returns -1 if no more options could be read, or if an
option could not be evaluated (unknown option). In such case, //param// will
hold a string to the option that is unknown to [pgetopt() #fn_pgetopt].
%FUNCTION:END
%NEED:32
%FUNCTION:BEGIN
=== plex_create ===[fn_plex_create]

**Definition:**

%DEFINITION:BEGIN
plex* plex_create( int flags )
%DEFINITION:END

**Usage:**

Constructor function to create a new plex object.

//flags// can be a combination of compile- and runtime-flags and are merged
with special compile-time flags provided for each pattern.

|| Flag | Usage |
| PREGEX_COMP_WCHAR | The regular expressions are provided as wchar_t. |
| PREGEX_COMP_NOANCHORS | Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile all patterns to be forced nongreedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expressions as case insensitive. |
| PREGEX_COMP_STATIC | The regular expressions passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped. |
| PREGEX_RUN_WCHAR | Run regular expressions with wchar_t as input. |
| PREGEX_RUN_NOANCHORS | Ignore anchors while processing the lexer. |
| PREGEX_RUN_NOREF | Don't create references. |
| PREGEX_RUN_NONGREEDY | Force run lexer nongreedy. |
| PREGEX_RUN_DEBUG | Debug mode; output some debug to stderr. |


On success, the function returns the allocated pointer to a plex-object.
This must be freed later using [plex_free() #fn_plex_free].
%FUNCTION:END
%NEED:36
%FUNCTION:BEGIN
=== plex_define ===[fn_plex_define]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* plex_define( plex* lex, char* pat, int match_id, int flags )
%DEFINITION:END

**Usage:**

Defines and parses a regular expression pattern into the plex-object.

//pat// is the regular expression string, or a pointer to a pregex_ptn*
structure in case PREGEX_COMP_PTN is flagged.

//match_id// must be a token match ID, a value > 0. The lower the match ID is,
the higher precedence takes the appended expression when there are multiple
matches.

//flags// may ONLY contain compile-time flags, and is combined with the
compile-time flags of the plex-object provided at [plex_create() #fn_plex_create].

|| Flag | Usage |
| PREGEX_COMP_WCHAR | The regular expressions are provided as wchar_t. |
| PREGEX_COMP_NOANCHORS | Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile all patterns to be forced nongreedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expressions as case insensitive. |
| PREGEX_COMP_STATIC | The regular expressions passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped. |
| PREGEX_COMP_PTN | The regular expression passed already is a pattern, and shall be integrated. |


Returns a pointer to the pattern object that just has been added. This allows
for changing e.g. the accept flag later on. In case of an error, the value
returned is NULL.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plex_free ===[fn_plex_free]

**Definition:**

%DEFINITION:BEGIN
plex* plex_free( plex* lex )
%DEFINITION:END

**Usage:**

Destructor function for a plex-object.

//lex// is the pointer to a plex-structure that will be released.

Returns always (plex*)NULL.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== plex_lex ===[fn_plex_lex]

**Definition:**

%DEFINITION:BEGIN
int plex_lex( plex* lex, char* start, char** end )
%DEFINITION:END

**Usage:**

Performs a lexical analysis using the object //lex// on pointer //start//.

If a token can be matched, the function returns the related id of the matching
pattern, and //end// receives the pointer to the last matched character.

The function returns 0 in case that there was no direct match.
The function [plex_next() #fn_plex_next] ignores unrecognized symbols and directly moves to the
next matching pattern.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== plex_next ===[fn_plex_next]

**Definition:**

%DEFINITION:BEGIN
char* plex_next( plex* lex, char* start, unsigned int* id, char** end )
%DEFINITION:END

**Usage:**

Performs lexical analysis using //lex// from begin of pointer //start//, to
the next matching token.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the plex-object).

If a token can be matched, the function returns the pointer to the position
where the match starts at. //id// receives the id of the matching patternn,
//end// receives the end pointer of the match, when provided. //id// and //end//
can be omitted by providing NULL-pointers.

The function returns (char*)NULL in case that there is no match.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plex_prepare ===[fn_plex_prepare]

**Definition:**

%DEFINITION:BEGIN
pboolean plex_prepare( plex* lex )
%DEFINITION:END

**Usage:**

Prepares the DFA state machine of a plex-object //lex// for execution.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plex_reset ===[fn_plex_reset]

**Definition:**

%DEFINITION:BEGIN
pboolean plex_reset( plex* lex )
%DEFINITION:END

**Usage:**

Resets the DFA state machine of a plex-object //lex//.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== plex_tokenize ===[fn_plex_tokenize]

**Definition:**

%DEFINITION:BEGIN
size_t plex_tokenize( plex* lex, char* start, parray** matches )
%DEFINITION:END

**Usage:**

Tokenizes the string beginning at //start// using the lexical analyzer
//lex//.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the plex-object).

The function initializes and fills the array //matches//, if provided, with
items of size prange. It returns the total number of matches.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_access ===[fn_plist_access]

**Definition:**

%DEFINITION:BEGIN
void* plist_access( plistel* e )
%DEFINITION:END

**Usage:**

Access data-content of the current element //e//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_clear ===[fn_plist_clear]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_clear( plist* list )
%DEFINITION:END

**Usage:**

Clear content of the list //list//.

The function has nearly the same purpose as [plist_erase() #fn_plist_erase], except that
the entire list is only cleared, but if the list was initialized with
PLIST_MOD_RECYCLE, existing pointers are hold for later usage.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_concat ===[fn_plist_concat]

**Definition:**

%DEFINITION:BEGIN
int plist_concat( plist* dest, plist* src )
%DEFINITION:END

**Usage:**

Concats the elements of list //src// to the elements of list //dest//.

The function will not run if both lists have different element size settings.

The function returns the number of elements added to //dest//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_count ===[fn_plist_count]

**Definition:**

%DEFINITION:BEGIN
int plist_count( plist* l )
%DEFINITION:END

**Usage:**

Return element count of list //l//.
%FUNCTION:END
%NEED:29
%FUNCTION:BEGIN
=== plist_create ===[fn_plist_create]

**Definition:**

%DEFINITION:BEGIN
plist* plist_create( size_t size, int flags )
%DEFINITION:END

**Usage:**

Create a new plist as an object with an element allocation size //size//.
Providing a //size// of 0 causes automatic configuration of PLIST_MOD_PTR.

//flags// defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage. The flags can be merged together using
bitwise or (|).

Possible flags are:
- **PLIST_MOD_NONE** for no special flagging.
- **PLIST_MOD_PTR** to use the plist-object in pointer-mode: Each plistel-element cointains only a pointer to an object in the memory and returnsthis, instead of copying from or into pointers.
- **PLIST_MOD_RECYCLE** to configure that elements that are removed during listusage will be reused later.
- **PLIST_MOD_AUTOSORT** to automatically sort elements on insert operations.
- **PLIST_MOD_EXTKEYS** to configure that string pointers to hash-table keyvalues are stored elsewhere, so the plist-module only uses the originalpointers instead of copying them.
- **PLIST_MOD_PTRKEYS** disables string keys and uses the pointer/valueprovided as key directly.
- **PLIST_MOD_UNIQUE** to disallow hash-table-key collisions, so elements witha key that already exist in the object will be rejected.
- **PLIST_MOD_WCHAR** to let all key values handle as wide-character strings.
-

Use [plist_free() #fn_plist_free] to erase and release the returned list object.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== plist_diff ===[fn_plist_diff]

**Definition:**

%DEFINITION:BEGIN
int plist_diff( plist* left, plist* right )
%DEFINITION:END

**Usage:**

Tests the contents (data parts) of the list //left// and the list //right//
for equal elements.

The function returns a value < 0 if //left// is lower //right//, a value > 0
if //left// is greater //right// and a value == 0 if //left// is equal to
//right//.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_dup ===[fn_plist_dup]

**Definition:**

%DEFINITION:BEGIN
plist* plist_dup( plist* list )
%DEFINITION:END

**Usage:**

Creates an independent copy of //list// and returns it.

All elements of //list// are duplicated and stand-alone.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_erase ===[fn_plist_erase]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_erase( plist* list )
%DEFINITION:END

**Usage:**

Erase all allocated content of the list //list//.

The object //list// will be still alive, but must be re-configured
using [plist_init() #fn_plist_init].
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_first ===[fn_plist_first]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_first( plist* l )
%DEFINITION:END

**Usage:**

Return first element of list //l//.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_free ===[fn_plist_free]

**Definition:**

%DEFINITION:BEGIN
plist* plist_free( plist* list )
%DEFINITION:END

**Usage:**

Releases all the memory //list// uses and destroys the list object.

The function always returns (plist*)NULL.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_get ===[fn_plist_get]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_get( plist* list, size_t n )
%DEFINITION:END

**Usage:**

Retrieve list element by its index from the begin.

The function returns the //n//th element of the list //list//.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_get_by_key ===[fn_plist_get_by_key]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_get_by_key( plist* list, char* key )
%DEFINITION:END

**Usage:**

Retrieve list element by hash-table key.

This function tries to fetch a list entry plistel from list //list//
with the key //key//.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_get_by_ptr ===[fn_plist_get_by_ptr]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_get_by_ptr( plist* list, void* ptr )
%DEFINITION:END

**Usage:**

Retrieve list element by pointer.

This function returns the list element of the unit within the list //list//
that is the pointer //ptr//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_hashnext ===[fn_plist_hashnext]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_hashnext( plistel* u )
%DEFINITION:END

**Usage:**

Access next element with same hash value of current unit //u//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_hashprev ===[fn_plist_hashprev]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_hashprev( plistel* u )
%DEFINITION:END

**Usage:**

Access previous element with same hash value of a current unit //u//.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_init ===[fn_plist_init]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_init( plist* list, size_t size, int flags )
%DEFINITION:END

**Usage:**

Initialize the list //list// with an element allocation size //size//.
//flags// defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== plist_insert ===[fn_plist_insert]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_insert( plist* list, plistel* pos, char* key, void* src )
%DEFINITION:END

**Usage:**

Insert //src// as element to the list //list// __before__ position //pos//.

If //pos// is NULL, the new element will be attached to the end of the
list.

If //key// is not NULL, the element will be additionally engaged
into the lists hash table.

If //src// is NULL, a zero-initialized element is inserted into the list for
further processing.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_iter ===[fn_plist_iter]

**Definition:**

%DEFINITION:BEGIN
void plist_iter( plist* list, plistelfn callback )
%DEFINITION:END

**Usage:**

Iterates over //list//.

Iterates over all items of //list// and calls the function //callback// on
every item. The callback function receives the plistel-element pointer of
the list element.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_iter_access ===[fn_plist_iter_access]

**Definition:**

%DEFINITION:BEGIN
void plist_iter_access( plist* list, plistfn callback )
%DEFINITION:END

**Usage:**

Iterates over //list// and accesses every item.

Iterates over all items of //list// and calls the function //callback// on
every item's access. The callback function receives a pointer to the accessed
element.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_key ===[fn_plist_key]

**Definition:**

%DEFINITION:BEGIN
char* plist_key( plistel* e )
%DEFINITION:END

**Usage:**

Access key-content of the current element //e//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_last ===[fn_plist_last]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_last( plist* l )
%DEFINITION:END

**Usage:**

Return last element of list //l//.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_malloc ===[fn_plist_malloc]

**Definition:**

%DEFINITION:BEGIN
void* plist_malloc( plist* list )
%DEFINITION:END

**Usage:**

Allocates memory for a new element in list //list//, push it to the end and
return the pointer to this.

The function works as a shortcut for [plist_access() #fn_plist_access] in combination with [plist_push() #fn_plist_push].
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_next ===[fn_plist_next]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_next( plistel* u )
%DEFINITION:END

**Usage:**

Access next element of current unit //u//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_offset ===[fn_plist_offset]

**Definition:**

%DEFINITION:BEGIN
int plist_offset( plistel* u )
%DEFINITION:END

**Usage:**

Return the offset of the unit //u// within the list it belongs to.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== plist_pop ===[fn_plist_pop]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_pop( plist* list, void* dest )
%DEFINITION:END

**Usage:**

Pop last element to //dest// off the list //list//.

Like //list// would be a stack, the last element of the list is poppend and
its content is written to //dest//, if provided at the end of the list.

//dest// can be omitted and given as (void*)NULL, so the last element will
be popped off the list and discards.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_prev ===[fn_plist_prev]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_prev( plistel* u )
%DEFINITION:END

**Usage:**

Access previous element of a current unit //u//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_push ===[fn_plist_push]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_push( plist* list, void* src )
%DEFINITION:END

**Usage:**

Push //src// to end of //list//.

Like //list// would be a stack, //src// is pushed at the end of the list.
This function can only be used for linked lists without the hash-table feature
in use.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== plist_remove ===[fn_plist_remove]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_remove( plist* list, plistel* e )
%DEFINITION:END

**Usage:**

Removes the element //e// from the the //list// and frees it or puts
it into the unused element chain if PLIST_MOD_RECYCLE is flagged.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_rget ===[fn_plist_rget]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_rget( plist* list, size_t n )
%DEFINITION:END

**Usage:**

Retrieve list element by its index from the end.

The function returns the //n//th element of the list //list//
from the right.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_riter ===[fn_plist_riter]

**Definition:**

%DEFINITION:BEGIN
void plist_riter( plist* list, plistelfn callback )
%DEFINITION:END

**Usage:**

Iterates backwards over //list//.

Backwardly iterates over all items of //list// and calls the function
//callback// on every item. The callback function receives the plistel-element
pointer of the list element.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_riter_access ===[fn_plist_riter_access]

**Definition:**

%DEFINITION:BEGIN
void plist_riter_access( plist* list, plistfn callback )
%DEFINITION:END

**Usage:**

Iterates backwards over //list//.

Backwardly iterates over all items of //list// and calls the function
//callback// on every  item's access. The callback function receives a pointer
to the accessed element.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_rmalloc ===[fn_plist_rmalloc]

**Definition:**

%DEFINITION:BEGIN
void* plist_rmalloc( plist* list )
%DEFINITION:END

**Usage:**

Allocates memory for a new element in list //list//, shift it at the begin
and return the pointer to this.

The function works as a shortcut for [plist_access() #fn_plist_access] in combination with [plist_shift() #fn_plist_shift].
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_set_comparefn ===[fn_plist_set_comparefn]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_set_comparefn( plist* list, int (*comparefn)( plist*, plistel*, plistel* ) )
%DEFINITION:END

**Usage:**

Set compare function
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_set_printfn ===[fn_plist_set_printfn]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_set_printfn( plist* list, void (*printfn)( plist* ) )
%DEFINITION:END

**Usage:**

Set an element dump function.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_set_sortfn ===[fn_plist_set_sortfn]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_set_sortfn( plist* list, int (*sortfn)( plist*, plistel*, plistel* ) )
%DEFINITION:END

**Usage:**

Set sort function
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_shift ===[fn_plist_shift]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_shift( plist* list, void* src )
%DEFINITION:END

**Usage:**

Shift //src// at begin of //list//.

Like //list// would be a queue, //src// is shifted at the begin of the list.
This function can only be used for linked lists without the hash-table feature
in use.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_size ===[fn_plist_size]

**Definition:**

%DEFINITION:BEGIN
int plist_size( plist* l )
%DEFINITION:END

**Usage:**

Return element size of list //l//.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== plist_sort ===[fn_plist_sort]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_sort( plist* list )
%DEFINITION:END

**Usage:**

Sorts //list// according to the sort-function that was set for the list.

To sort only parts of a list, use [plist_subsort() #fn_plist_subsort].

The sort-function can be modified by using [plist_set_sortfn() #fn_plist_set_sortfn].
The default sort function sorts the list by they contents, internally by using
the [memcmp() #fn_memcmp] standard function.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== plist_subsort ===[fn_plist_subsort]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_subsort( plist* list, plistel* from, plistel* to )
%DEFINITION:END

**Usage:**

Sorts //list// between the elements //from// and //to// according to the
sort-function that was set for the list.

To sort the entire list, use [plist_sort() #fn_plist_sort].

The sort-function can be modified by using [plist_set_sortfn() #fn_plist_set_sortfn].
The default sort function sorts the list by they contents, internally by using
the [memcmp() #fn_memcmp] standard function.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_swap ===[fn_plist_swap]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_swap( plistel* a, plistel* b )
%DEFINITION:END

**Usage:**

Swaps the positions of the list elemements //a// and //b// with each
other. The elements must be in the same plist object, else the function
returns with FALSE.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== plist_union ===[fn_plist_union]

**Definition:**

%DEFINITION:BEGIN
int plist_union( plist* all, plist* from )
%DEFINITION:END

**Usage:**

Unions elements from list //from// into list //all//.

An element is only added to //all//, if there exists no other
element with the same size and content.

The function will not run if both lists have different element size settings.

The function returns the number of elements added to //from//.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== plist_unshift ===[fn_plist_unshift]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_unshift( plist* list, void* dest )
%DEFINITION:END

**Usage:**

Take first element to //dest// from the list //list//.

Like //list// would be a queue, the first element of the list is taken and
its content is written to //dest//.

//dest// can be omitted and given as (void*)NULL, so the first element will
be taken from the list and discards.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== pmalloc ===[fn_pmalloc]

**Definition:**

%DEFINITION:BEGIN
void* pmalloc( size_t size )
%DEFINITION:END

**Usage:**

Dynamically allocate heap memory.

The function is a wrapper for the system function [malloc() #fn_malloc], but with memory
initialization to zero, and immediatelly stops the program if no more memory
can be allocated.

//size// is the size of memory to be allocated, in bytes.

The function returns the allocated heap memory pointer. The returned memory
address should be freed using [pfree() #fn_pfree] after it is not required anymore.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pmemdup ===[fn_pmemdup]

**Definition:**

%DEFINITION:BEGIN
void* pmemdup( void* ptr, size_t size )
%DEFINITION:END

**Usage:**

Duplicates a memory entry onto the heap.

//ptr// is the pointer to the memory to be duplicated.
//size// is the size of pointer's data storage.

Returns the new pointer to the memory copy. This should be casted back to the
type of //ptr// again.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_ast_dump ===[fn_pp_ast_dump]

**Definition:**

%DEFINITION:BEGIN
void pp_ast_dump( FILE* stream, ppast* ast )
%DEFINITION:END

**Usage:**

Dump detailed //ast// to //stream//.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== pp_ast_dump_json ===[fn_pp_ast_dump_json]

**Definition:**

%DEFINITION:BEGIN
void pp_ast_dump_json( FILE* stream, ppast* ast )
%DEFINITION:END

**Usage:**

Dump //ast// to //stream// as JSON-formatted string.

Only opening matches are printed.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_ast_dump_pvm ===[fn_pp_ast_dump_pvm]

**Definition:**

%DEFINITION:BEGIN
void pp_ast_dump_pvm( pvmprog* prog, ppast* ast )
%DEFINITION:END

**Usage:**

Dump //ast// into pvm program
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== pp_ast_dump_short ===[fn_pp_ast_dump_short]

**Definition:**

%DEFINITION:BEGIN
void pp_ast_dump_short( FILE* stream, ppast* ast )
%DEFINITION:END

**Usage:**

Dump simplified //ast// to //stream//.

Only opening matches are printed.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== pp_ast_dump_tree2svg ===[fn_pp_ast_dump_tree2svg]

**Definition:**

%DEFINITION:BEGIN
void pp_ast_dump_tree2svg( FILE* stream, ppast* ast )
%DEFINITION:END

**Usage:**

Dump //ast// in notation for the tree2svg tool that generates a
graphical view of the parse tree.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pp_ast_eval ===[fn_pp_ast_eval]

**Definition:**

%DEFINITION:BEGIN
void pp_ast_eval( ppast* ast, pastevalfn func )
%DEFINITION:END

**Usage:**

Evaluate //ast// using evaluation function //func//.

The evaluation function has the prototype

``` void (*pastevalfn)( ppasteval type, ppast* node )

and retrieves a //type// regarding the position where the evaluation currently
is positioned, and the node pointer.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== pp_ast_free ===[fn_pp_ast_free]

**Definition:**

%DEFINITION:BEGIN
ppast* pp_ast_free( ppast* node )
%DEFINITION:END

**Usage:**

Frees entire //ast// structure and subsequent links.

Always returns (ppast*)NULL.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_ast_get ===[fn_pp_ast_get]

**Definition:**

%DEFINITION:BEGIN
ppast* pp_ast_get( ppast* node, int n )
%DEFINITION:END

**Usage:**

Returns the //n//th element of //node//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_ast_len ===[fn_pp_ast_len]

**Definition:**

%DEFINITION:BEGIN
int pp_ast_len( ppast* node )
%DEFINITION:END

**Usage:**

Returns length of //node// chain.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_ast_select ===[fn_pp_ast_select]

**Definition:**

%DEFINITION:BEGIN
ppast* pp_ast_select( ppast* node, char* emit, int n )
%DEFINITION:END

**Usage:**

Returns the //n//th element matching emit //emit// starting at //node//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_gram_create ===[fn_pp_gram_create]

**Definition:**

%DEFINITION:BEGIN
ppgram* pp_gram_create( void )
%DEFINITION:END

**Usage:**

Creates a new ppgram-object.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_gram_free ===[fn_pp_gram_free]

**Definition:**

%DEFINITION:BEGIN
ppgram* pp_gram_free( ppgram* g )
%DEFINITION:END

**Usage:**

Frees grammar //g// and all its related memory.
%FUNCTION:END
%NEED:32
%FUNCTION:BEGIN
=== pp_gram_from_bnf ===[fn_pp_gram_from_bnf]

**Definition:**

%DEFINITION:BEGIN
pboolean pp_gram_from_bnf( ppgram* g, char* src )
%DEFINITION:END

**Usage:**

Compiles a Backus-Naur-Format definition into a grammar.

//g// is the grammar that receives the result of the parse.
This grammar is extended to new definitions when it already contains symbols.

//src// is the BNF definition string that defines the grammar.

The function returns TRUE in case the grammar could be compiled,
FALSE otherwise.

**Grammar:**
```
symbol : Terminal | Nonterminal ;
sequence : sequence symbol | symbol ;
production : sequence | ;
alternation : alternation '|' production | production ;

nonterm : Nonterminal ':' alternation ';';
defs : defs nonterm | nonterm ;

grammar$ : defs ;
```
%FUNCTION:END
%NEED:33
%FUNCTION:BEGIN
=== pp_gram_from_ebnf ===[fn_pp_gram_from_ebnf]

**Definition:**

%DEFINITION:BEGIN
pboolean pp_gram_from_ebnf( ppgram* g, char* src )
%DEFINITION:END

**Usage:**

Compiles an Extended Backus-Naur-Format definition into a grammar.

//g// is the grammar that receives the result of the parse.
This grammar is extended to new definitions when it already contains symbols.

//src// is the EBNF definition string that defines the grammar.

The function returns TRUE in case the grammar could be compiled,
FALSE otherwise.

**Grammar:**
```
symbol : '(' alternation ')' | Terminal | Nonterminal ;
modifier : symbol | symbol '*' | symbol '+' | symbol '?' ;
sequence : sequence modifier | modifier ;
production : sequence | ;
alternation : alternation '|' production | production ;

nonterm : Nonterminal ':' alternation ';';
defs : defs nonterm | nonterm ;

grammar$ : defs ;
```
%FUNCTION:END
%NEED:84
%FUNCTION:BEGIN
=== pp_gram_from_pbnf ===[fn_pp_gram_from_pbnf]

**Definition:**

%DEFINITION:BEGIN
pboolean pp_gram_from_pbnf( ppgram* g, char* src )
%DEFINITION:END

**Usage:**

Compiles an Phorward Backus-Naur-Format definition into a parser.

//p// is the parser that receives the result of the parse.

In difference to [pp_gram_from_bnf() #fn_pp_gram_from_bnf] and [pp_gram_from_ebnf() #fn_pp_gram_from_ebnf], [pp_par_from_pbnf() #fn_pp_par_from_pbnf] allows for a full-fledged parser definition with
lexical analyzer-specific definitions, grammar and AST construction features.


**Grammar:**
```
// Whitespace ------------------------------------------------------------------

%skip			/[ \t\r\n]+/ ;
%skip			/\/\/[^\n]*/n/ ;
%skip			/\//*([^*]|/*[^\/])*/*/// ;

// Terminals -------------------------------------------------------------------

Terminal		:= /[A-Z][A-Za-z0-9_]*/ ;
Nonterminal		:= /[a-z_][A-Za-z0-9_]*/ ;

CCL 			:= /\[(\\.|[^\\\]])*/]/ ;
String 			:= /'[^']*'/ ;
Token			:= /"[^"]*"/ ;
Regex 			:= /\/(\\.|[^\\\/])*/// ;

Int				:= /[0-9]+/ ;
Function		:= /[A-Za-z_][A-Za-z0-9_]*/(\)/ ;

Flag_emit		:= '@([A-Za-z0-9_]+)?' ;
Flag_goal		:= '$' ;
Flag_lexem		:= '!' ;
Flag_ignore		:= /%(ignore|skip)/ ;

// Nonterminals ----------------------------------------------------------------

inline			:= Flag_emit '(' alternation ')'
				|  '(' alternation ')'
				;

terminal		: CCL | String | Token | Regex | Function ;

symbol 			:= Terminal | Nonterminal | terminal | inline  ;

modifier		: symbol '*' = kle
				| symbol '+' = pos
				| symbol '?' = opt
				| symbol
				;

sequence		: sequence modifier | modifier ;

production	 	:= sequence | ;

alternation		: alternation '|' production | production ;

nontermdef		:= Nonterminal ':' alternation ';'
				;

termdef			:= Terminal ':' terminal ';'
				;

assocdef		:= '<<' terminal+ ';'	= assoc_left
				| '>>' terminal+ ';'	= assoc_right
				| '^^' terminal+ ';'	= assoc_none
				;

definition		: nontermdef
				| termdef
				| assocdef
				;

grammar	$		: definition+ ;
```
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pp_gram_prepare ===[fn_pp_gram_prepare]

**Definition:**

%DEFINITION:BEGIN
pboolean pp_gram_prepare( ppgram* g )
%DEFINITION:END

**Usage:**

Prepares the grammar //g// by computing all necessary stuff required for
runtime and parser generator.

The preparation process includes:
- Setting up final symbol and productions IDs
- Nonterminals FIRST-set computation
- Marking of left-recursions
- The 'lexem'-flag pull-through the grammar.
-

This function is only run internally.
Don't call it if you're unsure ;)...
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_gram_to_str ===[fn_pp_gram_to_str]

**Definition:**

%DEFINITION:BEGIN
char* pp_gram_to_str( ppgram* grm )
%DEFINITION:END

**Usage:**

Get grammar string representation
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_lr_build ===[fn_pp_lr_build]

**Definition:**

%DEFINITION:BEGIN
pboolean pp_lr_build( unsigned int* cnt, unsigned int*** dfa, ppgram* grm )
%DEFINITION:END

**Usage:**

Build parse tables
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== pp_par_autolex ===[fn_pp_par_autolex]

**Definition:**

%DEFINITION:BEGIN
int pp_par_autolex( pppar* p )
%DEFINITION:END

**Usage:**

Automatically generate lexical analysis for terminal symbols which
have not been defined with [pp_par_lex() #fn_pp_par_lex].

Returns the number of inserted tokens on success.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pp_par_create ===[fn_pp_par_create]

**Definition:**

%DEFINITION:BEGIN
pppar* pp_par_create( ppgram* g )
%DEFINITION:END

**Usage:**

Creates a new parser object with the underlying grammar //g//.

The grammar must either be parsed first via one of the BNF parsers
 [pp_gram_from_pbnf() #fn_pp_gram_from_pbnf], [pp_gram_from_ebnf() #fn_pp_gram_from_ebnf], [pp_gram_from_bnf() #fn_pp_gram_from_bnf]) or it
must be hand-crafted.

The provided grammar gets "frozen" when a parser is created from it.
Modifications on the grammar with a parser based on an older grammar state may
cause memory corruption and crashes.

The function returns a valid parser object on success, or (pppar*)NULL in case
the grammar is invalid.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_par_free ===[fn_pp_par_free]

**Definition:**

%DEFINITION:BEGIN
pppar* pp_par_free( pppar* p )
%DEFINITION:END

**Usage:**

Frees the parser object //par//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pp_par_lex ===[fn_pp_par_lex]

**Definition:**

%DEFINITION:BEGIN
pboolean pp_par_lex( pppar* p, ppsym* sym, char* pat, int flags )
%DEFINITION:END

**Usage:**

Defines a lexical matcher for //sym// in parser //p// from a
regular expression. //sym// must be a terminal symbol.

Returns TRUE on success, FALSE if the symbol already was defined as a lexing
token.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pp_par_parse ===[fn_pp_par_parse]

**Definition:**

%DEFINITION:BEGIN
pboolean pp_par_parse( ppast** root, pppar* par, char* start )
%DEFINITION:END

**Usage:**

Run parser //p// with input //start//.

Currently, the used parsing method is only LALR(1).

It returns an abstract syntax tree to //root// on success.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_prod_append ===[fn_pp_prod_append]

**Definition:**

%DEFINITION:BEGIN
pboolean pp_prod_append( ppprod* p, ppsym* sym )
%DEFINITION:END

**Usage:**

Appends the symbol //sym// to the right-hand-side of production //p//.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== pp_prod_create ===[fn_pp_prod_create]

**Definition:**

%DEFINITION:BEGIN
ppprod* pp_prod_create( ppgram* g, ppsym* lhs, ... )
%DEFINITION:END

**Usage:**

Creates a new production on left-hand-side //lhs//
within the grammar //g//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_prod_free ===[fn_pp_prod_free]

**Definition:**

%DEFINITION:BEGIN
ppprod* pp_prod_free( ppprod* p )
%DEFINITION:END

**Usage:**

Frees the production object //p// and releases any used memory.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== pp_prod_get ===[fn_pp_prod_get]

**Definition:**

%DEFINITION:BEGIN
ppprod* pp_prod_get( ppgram* g, int n )
%DEFINITION:END

**Usage:**

Get the //n//th production from grammar //g//.
Returns (ppprod*)NULL if no symbol was found.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== pp_prod_getfromrhs ===[fn_pp_prod_getfromrhs]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_prod_getfromrhs( ppprod* p, int off )
%DEFINITION:END

**Usage:**

Returns the //off//s element from the right-hand-side of
production //p//. Returns (ppsym*)NULL if the requested element does
not exist.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== pp_prod_remove ===[fn_pp_prod_remove]

**Definition:**

%DEFINITION:BEGIN
int pp_prod_remove( ppprod* p, ppsym* sym )
%DEFINITION:END

**Usage:**

Removes all occurences of symbol //sym// from the right-hand-side of
production //p//.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== pp_prod_to_str ===[fn_pp_prod_to_str]

**Definition:**

%DEFINITION:BEGIN
char* pp_prod_to_str( ppprod* p )
%DEFINITION:END

**Usage:**

Returns the string representation of production //p//.

The returned pointer is part of //p// and can be referenced multiple times.
It may not be freed by the caller.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pp_sym_create ===[fn_pp_sym_create]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_sym_create( ppgram* g, char* name, unsigned int flags )
%DEFINITION:END

**Usage:**

Creates a new symbol in the grammar //g//.

//name// is the unique name for the symbol. It can be left empty,
configuring the symbol as an unnamed symbol.

//flags// can be a combination of PPFLAG_-flags related to the symbol's
configuration.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_sym_drop ===[fn_pp_sym_drop]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_sym_drop( ppsym* sym )
%DEFINITION:END

**Usage:**

Removes a symbol from its grammar.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_sym_free ===[fn_pp_sym_free]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_sym_free( ppsym* sym )
%DEFINITION:END

**Usage:**

Frees a symbol.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== pp_sym_get ===[fn_pp_sym_get]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_sym_get( ppgram* g, unsigned int n )
%DEFINITION:END

**Usage:**

Get the //n//th symbol from grammar //g//.
Returns (ppsym*)NULL if no symbol was found.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_sym_get_by_name ===[fn_pp_sym_get_by_name]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_sym_get_by_name( ppgram* g, char* name )
%DEFINITION:END

**Usage:**

Get a symbol from grammar //g// by its //name//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pp_sym_get_nameless_term_by_def ===[fn_pp_sym_get_nameless_term_by_def]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_sym_get_nameless_term_by_def( ppgram* g, char* name )
%DEFINITION:END

**Usage:**

Find a nameless terminal symbol by its pattern.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pp_sym_getprod ===[fn_pp_sym_getprod]

**Definition:**

%DEFINITION:BEGIN
ppprod* pp_sym_getprod( ppsym* sym, unsigned int n )
%DEFINITION:END

**Usage:**

Get the //n//th production from symbol //sym//.
//sym// must be a nonterminal.

Returns (ppprod*)NULL if the production is not found or the symbol is
configured differently.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pp_sym_mod_kleene ===[fn_pp_sym_mod_kleene]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_sym_mod_kleene( ppsym* sym )
%DEFINITION:END

**Usage:**

Constructs an optional positive ("kleene") closure from //sym//.

This helper function constructs the productions and symbol
```
pos_sym: sym pos_sym | sym ;
opt_sym: pos_sym | ;
```
from //sym//, and returns the symbol //opt_sym//. If any of the given symbols
already exists, they are directly used. The function is a shortcut for a call
```
pp_sym_mod_optional( pp_sym_mod_positive( sym ) )
```
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pp_sym_mod_optional ===[fn_pp_sym_mod_optional]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_sym_mod_optional( ppsym* sym )
%DEFINITION:END

**Usage:**

Constructs an optional closure from //sym//.

This helper function constructs the productions and symbol
```
opt_sym: sym | ;
```
from //sym//, and returns the symbol //pos_sym//. If //opt_sym// already exists,
the symbol will be returned without any creation.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pp_sym_mod_positive ===[fn_pp_sym_mod_positive]

**Definition:**

%DEFINITION:BEGIN
ppsym* pp_sym_mod_positive( ppsym* sym )
%DEFINITION:END

**Usage:**

Constructs a positive closure from //sym//.

This helper function constructs the productions and symbol
```
pos_sym: sym pos_sym | sym ;
```
from //sym//, and returns the symbol //pos_sym//. If //pos_sym// already exists,
the symbol will be returned without any creation.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pp_sym_to_str ===[fn_pp_sym_to_str]

**Definition:**

%DEFINITION:BEGIN
char* pp_sym_to_str( ppsym* sym )
%DEFINITION:END

**Usage:**

Returns the string representation of symbol //sym//.

Nonterminals are not expanded, they are just returned as their name.
The returned pointer is part of //sym// and can be referenced multiple
times. It may not be freed by the caller.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== prealloc ===[fn_prealloc]

**Definition:**

%DEFINITION:BEGIN
void* prealloc( void* oldptr, size_t size )
%DEFINITION:END

**Usage:**

Dynamically (re)allocate memory on the heap.

The function is a wrapper to the system-function [realloc() #fn_realloc], but always
accepts a NULL-pointer and immediatelly stops the program if no more memory
can be allocated.

//oldptr// is the pointer to be reallocated. If this is (void*)NULL, [prealloc() #fn_prealloc] works like a normal call to [pmalloc() #fn_pmalloc].

//size// is the size of memory to be reallocated, in bytes.

The function returns the allocated heap memory pointer. The returned memory
address should be freed using [pfree() #fn_pfree] after it is not required anymore.
%FUNCTION:END
%NEED:32
%FUNCTION:BEGIN
=== pregex_create ===[fn_pregex_create]

**Definition:**

%DEFINITION:BEGIN
pregex* pregex_create( char* pat, int flags )
%DEFINITION:END

**Usage:**

Constructor function to create a new pregex object.

//pat// is a string providing a regular expression pattern.
//flags// can be a combination of compile- and runtime-flags.

|| Flag | Usage |
| PREGEX_COMP_WCHAR | The regular expression //pat// is provided as wchar_t. |
| PREGEX_COMP_NOANCHORS | Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile regex to be forced non-greedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expression as case insensitive. |
| PREGEX_COMP_STATIC | The regular expression passed should be converted 1:1 asit where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped. |
| PREGEX_RUN_WCHAR | Run regular expression with wchar_t as input. |
| PREGEX_RUN_NOANCHORS | Ignore anchors while processing the regex. |
| PREGEX_RUN_NOREF | Don't create references. |
| PREGEX_RUN_NONGREEDY | Force run regular expression non-greedy. |
| PREGEX_RUN_DEBUG | Debug mode; output some debug to stderr. |


On success, the function returns the allocated pointer to a pregex-object.
This must be freed later using [pregex_free() #fn_pregex_free].
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pregex_find ===[fn_pregex_find]

**Definition:**

%DEFINITION:BEGIN
char* pregex_find( pregex* regex, char* start, char** end )
%DEFINITION:END

**Usage:**

Find a match for the regular expression //regex// from begin of pointer
//start//.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).

If the expression can be matched, the function returns the pointer to the
position where the match begins. //end// receives the end pointer of the match,
when provided.

The function returns (char*)NULL in case that there is no match.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pregex_findall ===[fn_pregex_findall]

**Definition:**

%DEFINITION:BEGIN
int pregex_findall( pregex* regex, char* start, parray** matches )
%DEFINITION:END

**Usage:**

Find all matches for the regular expression //regex// from begin of pointer
//start//, and optionally return matches as an array.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).

The function fills the array //matches//, if provided, with items of size
prange. It returns the total number of matches.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pregex_free ===[fn_pregex_free]

**Definition:**

%DEFINITION:BEGIN
pregex* pregex_free( pregex* regex )
%DEFINITION:END

**Usage:**

Destructor function for a pregex-object.

//regex// is the pointer to a pregex-structure that will be released.

Returns always (pregex*)NULL.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== pregex_match ===[fn_pregex_match]

**Definition:**

%DEFINITION:BEGIN
pboolean pregex_match( pregex* regex, char* start, char** end )
%DEFINITION:END

**Usage:**

Tries to match the regular expression //regex// at pointer //start//.

If the expression can be matched, the function returns TRUE and //end// receives
the pointer to the last matched character.
%FUNCTION:END
%NEED:27
%FUNCTION:BEGIN
=== pregex_qmatch ===[fn_pregex_qmatch]

**Definition:**

%DEFINITION:BEGIN
int pregex_qmatch( char* regex, char* str, int flags, parray** matches )
%DEFINITION:END

**Usage:**

Performs a regular expression match on a string, and returns an array of
matches via prange-structures, which hold pointers to the begin- and
end-addresses of all matches.

//regex// is the regular expression pattern to be processed.

//str// is the string on which the pattern will be executed on.

//flags// are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).

//matches// is the array of results to the matched substrings within //str//,
provided as parray-object existing of one prange-object for every match.
It is optional. //matches// must be released with [parray_free() #fn_parray_free] after its usage.

Returns the number of matches, which is the amount of result entries in the
returned array //matches//. If the value is negative, an error occured.
%FUNCTION:END
%NEED:27
%FUNCTION:BEGIN
=== pregex_qreplace ===[fn_pregex_qreplace]

**Definition:**

%DEFINITION:BEGIN
char* pregex_qreplace( char* regex, char* str, char* replace, int flags )
%DEFINITION:END

**Usage:**

Replaces all matches of a regular expression pattern within a string with
the replacement. Backreferences can be used with ``$x`` for each opening bracket
within the regular expression.

//regex// is the regular expression pattern to be processed.

//str// is the string on which the pattern will be executed on.

//replace// is the string that will be inserted as replacement for each pattern
match. ``$x`` back-references can be used.

//flags// are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).

Returns an allocated pointer to the generated string with the replacements.
This string must be released after its existence is no longer required by the
caller using [pfree() #fn_pfree].
%FUNCTION:END
%NEED:26
%FUNCTION:BEGIN
=== pregex_qsplit ===[fn_pregex_qsplit]

**Definition:**

%DEFINITION:BEGIN
int pregex_qsplit( char* regex, char* str, int flags, parray** matches )
%DEFINITION:END

**Usage:**

Performs a regular expression search on a string and uses the expression as
separator; All strings that where split are returned as //matches//-array.

//regex// is the regular expression pattern to be processed.

//str// is the string on which the pattern will be executed on.

//flags// are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).

//matches// is the array of results to the matched substrings within //str//,
provided as parray-object existing of one prange-object for every match.
It is optional. //matches// must be released with [parray_free() #fn_parray_free] after its usage.

Returns the number of split substrings, which is the amount of result entries in
the returned array //matches//. If the value is negative, an error occured.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== pregex_replace ===[fn_pregex_replace]

**Definition:**

%DEFINITION:BEGIN
char* pregex_replace( pregex* regex, char* str, char* replacement )
%DEFINITION:END

**Usage:**

Replaces all matches of a regular expression object within a string //str//
with //replacement//. Backreferences in //replacement// can be used with //$x//
for each opening bracket within the regular expression.

//regex// is the pregex-object used for pattern matching.
//str// is the string on which //regex// will be executed.
//replacement// is the string that will be inserted as the replacement for each
match of a pattern described in //regex//. The notation //$x// can be used for
backreferences, where x is the offset of opening brackets in the pattern,
beginning at 1.

The function returns the string with the replaced elements, or (char*)NULL
in error case.
%FUNCTION:END
%NEED:24
%FUNCTION:BEGIN
=== pregex_split ===[fn_pregex_split]

**Definition:**

%DEFINITION:BEGIN
char* pregex_split( pregex* regex, char* start, char** end, char** next )
%DEFINITION:END

**Usage:**

Returns the range between string //start// and the next match of //regex//.

This function can be seen as a "negative match", so the substrings that are
not part of the match will be returned.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).
//end// receives the last position of the string before the regex.
//next// receives the pointer of the next split element behind the matched
substring, so //next// should become the next //start// when [pregex_split() #fn_pregex_split] is
called in a loop.

The function returns (char*)NULL in case that there is no more string to split,
else it returns //start//.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pregex_splitall ===[fn_pregex_splitall]

**Definition:**

%DEFINITION:BEGIN
int pregex_splitall( pregex* regex, char* start, parray** matches )
%DEFINITION:END

**Usage:**

Split a string at all matches of the regular expression //regex// from
begin of pointer //start//, and optionally return the splitted matches as an
array.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).

The function fills the array //matches//, if provided, with items of size
prange. It returns the total number of matches.
%FUNCTION:END
%NEED:24
%FUNCTION:BEGIN
=== pstr_to_wcs ===[fn_pstr_to_wcs]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pstr_to_wcs( char* str, pboolean freestr )
%DEFINITION:END

**Usage:**

This functions converts an UTF-8-multi-byte string into an Unicode
wide-character string.

The string conversion is performed into dynamically allocated memory.
The function wraps [mbstowcs() #fn_mbstowcs], so [set_locale() #fn_set_locale] must be done before this
function works properly.

//str// is the zero-terminated multi-byte-character string to be converted
into a wide-character string.
//freestr// defines if the input-string shall be freed after successfull
conversion, if set to TRUE.

Returns the wide-character pendant of //str// as pointer to dynamically
allocated memory.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pstrcasecmp ===[fn_pstrcasecmp]

**Definition:**

%DEFINITION:BEGIN
int pstrcasecmp( char* s1, char* s2 )
%DEFINITION:END

**Usage:**

Compare a string by ignoring case-order.

//s1// is the string to compare with //s2//.
//s2// is the string to compare with //s1//.

Returns 0 if both strings are equal. Returns a value <0 if //s1// is lower than
//s2// or a value >0 if //s1// is greater than //s2//.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pstrcatchar ===[fn_pstrcatchar]

**Definition:**

%DEFINITION:BEGIN
char* pstrcatchar( char* str, char chr )
%DEFINITION:END

**Usage:**

Dynamically appends a character to a string.

//str// is the pointer to a string to be appended. If this is (char*)NULL,
the string will be newly allocated. //chr// is the the character to be appended
to str.

Returns a char*-pointer to the (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated. This pointer must
be released with [pfree() #fn_pfree] when its existence is no longer required.
%FUNCTION:END
%NEED:24
%FUNCTION:BEGIN
=== pstrcatstr ===[fn_pstrcatstr]

**Definition:**

%DEFINITION:BEGIN
char* pstrcatstr( char* dest, char* src, pboolean freesrc )
%DEFINITION:END

**Usage:**

Dynamically appends a zero-terminated string to a dynamic string.

//str// is the pointer to a zero-terminated string to be appended.
If this is (char*)NULL, the string is newly allocated.

//append// is the string to be appended at the end of //str//.

//freesrc// frees the pointer provided as //append// automatically by
this function, if set to TRUE. This parameter has only a comfort-function.

Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL. If //dest// is NULL and //freesrc// is FALSE, the function
automatically returns the pointer //src//. This pointer must be released with [pfree() #fn_pfree] when its existence is no longer required.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pstrdup ===[fn_pstrdup]

**Definition:**

%DEFINITION:BEGIN
char* pstrdup( char* str )
%DEFINITION:END

**Usage:**

Duplicate a string in memory.

//str// is the string to be copied in memory. If //str// is provided as NULL,
the function will also return NULL.

Returns a char*-pointer to the newly allocated copy of //str//. This pointer
must be released with [pfree() #fn_pfree] when its existence is no longer required.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== pstrget ===[fn_pstrget]

**Definition:**

%DEFINITION:BEGIN
char* pstrget( char* str )
%DEFINITION:END

**Usage:**

Savely reads a string.

//str// is the string pointer to be savely read. If //str// is NULL, the
function returns a pointer to a static address holding an empty string.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pstrlen ===[fn_pstrlen]

**Definition:**

%DEFINITION:BEGIN
size_t pstrlen( char* str )
%DEFINITION:END

**Usage:**

Return length of a string.

//str// is the parameter string to be evaluated. If (char*)NULL, the function
returns 0. [pstrlen() #fn_pstrlen] is much more saver than [strlen() #fn_strlen] because it returns 0 when
a NULL-pointer is provided.

Returns the length of the string //str//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrltrim ===[fn_pstrltrim]

**Definition:**

%DEFINITION:BEGIN
char* pstrltrim( char* s )
%DEFINITION:END

**Usage:**

Removes whitespace on the left of a string.

//s// is the string to be left-trimmed.

Returns //s//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrlwr ===[fn_pstrlwr]

**Definition:**

%DEFINITION:BEGIN
char* pstrlwr( char* s )
%DEFINITION:END

**Usage:**

Convert a string to lower-case order.

//s// is the acts both as input and output-string.

Returns //s//.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pstrncasecmp ===[fn_pstrncasecmp]

**Definition:**

%DEFINITION:BEGIN
int pstrncasecmp( char* s1, char* s2, size_t n )
%DEFINITION:END

**Usage:**

Compare a string by ignoring case-order about a maximum of //n// bytes.

//s1// is the string to compare with //s2//.
//s2// is the string to compare with //s1//.
//n// is the number of bytes to compare.

Returns 0 if both strings are equal. Returns a value <0 if //s1// is lower than
//s2// or a value >0 if //s1// is greater than //s2//.
%FUNCTION:END
%NEED:24
%FUNCTION:BEGIN
=== pstrncatstr ===[fn_pstrncatstr]

**Definition:**

%DEFINITION:BEGIN
char* pstrncatstr( char* str, char* append, size_t n )
%DEFINITION:END

**Usage:**

Dynamicaly appends a number of n-characters from one string to another
string.

The function works similar to [pstrcatstr() #fn_pstrcatstr], but allows to copy only a maximum
of //n// characters from //append//.

//str// is the pointer to a string to be appended. If this is (char*)NULL,
the string is newly allocated. //append// is the begin of character sequence to
be appended. //n// is the number of characters to be appended to //str//.

Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL. This pointer must be released with [pfree() #fn_pfree] when its existence
is no longer required.
%FUNCTION:END
%NEED:24
%FUNCTION:BEGIN
=== pstrndup ===[fn_pstrndup]

**Definition:**

%DEFINITION:BEGIN
char* pstrndup( char* str, size_t len )
%DEFINITION:END

**Usage:**

Duplicate //n// characters from a string in memory.

The function mixes the functionalities of [strdup() #fn_strdup] and [strncpy() #fn_strncpy].
The resulting string will be zero-terminated.

//str// is the parameter string to be duplicated. If this is provided as
(char*)NULL, the function will also return (char*)NULL.
//n// is the the number of characters to be copied and duplicated from //str//.
If //n// is greater than the length of //str//, copying will stop at the zero
terminator.

Returns a char*-pointer to the allocated memory holding the zero-terminated
string duplicate. This pointer must be released with [pfree() #fn_pfree] when its existence
is no longer required.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== pstrput ===[fn_pstrput]

**Definition:**

%DEFINITION:BEGIN
char* pstrput( char** str, char* val )
%DEFINITION:END

**Usage:**

Assign a string into a dynamically allocated pointer.
 [pstrput() #fn_pstrput] manages the assignment of an dynamically allocated string.

//str// is a pointer receiving the target pointer to be (re)allocated. If
//str// already references a string, this pointer will be freed and reassigned
to a copy of //val//.

//val// is the the string to be assigned to //str// (as a independent copy).

Returns a pointer to the allocated heap memory on success, (char*)NULL else.
This is the same pointer as returned like calling ``*str``. The returned pointer
must be released with [pfree() #fn_pfree] or another call of [pstrput() #fn_pstrput]. Calling [pstrput() #fn_pstrput]
as ``pstrput( &p, (char*)NULL );`` is equivalent to ``p = pfree( &p )``.
%FUNCTION:END
%NEED:29
%FUNCTION:BEGIN
=== pstrrender ===[fn_pstrrender]

**Definition:**

%DEFINITION:BEGIN
char* pstrrender( char* tpl, ... )
%DEFINITION:END

**Usage:**

String rendering function.

Inserts multiple values dynamically into the according wildcards positions of
a template string. The function can be compared to the function of [pstrreplace() #fn_pstrreplace], but allows to replace multiple substrings by multiple replacement
strings.

//tpl// is the template string to be rendered with values.
//...// are the set of values to be inserted into the desired position;

These consist of three values each:

- //char* name// as a wildcard-name
- //char* value// as the replacement value for the wildcard
- //pboolean freeflag// defines if //value// shall be freed after processing
-

Returns an allocated string which is the resulting source. This string must be
release by [pfree() #fn_pfree] or another function releasing heap memory when its existence
is no longer required.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pstrreplace ===[fn_pstrreplace]

**Definition:**

%DEFINITION:BEGIN
char* pstrreplace( char* str, char* find, char* replace )
%DEFINITION:END

**Usage:**

Replace a substring sequence within a string.

//str// is the string to be replaced in. //find// is the substring to be
matched. //replace// is the the string to be inserted for each match of the
substring //find//.

Returns a pointer to char* containing the allocated string which is the
resulting source. This pointer must be released with [pfree() #fn_pfree] when its existence
is no longer required.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrrtrim ===[fn_pstrrtrim]

**Definition:**

%DEFINITION:BEGIN
char* pstrrtrim( char* s )
%DEFINITION:END

**Usage:**

Removes trailing whitespace on the right of a string.

//s// is the string to be right-trimmed.

Returns //s//.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pstrsplit ===[fn_pstrsplit]

**Definition:**

%DEFINITION:BEGIN
int pstrsplit( char*** tokens, char* str, char* sep, int limit )
%DEFINITION:END

**Usage:**

Splits a string at a delimiting token and returns an allocated array of
token reference pointers.

//tokens// is the an allocated array of tokenized array values.
Requires a pointer to char**.
//str// is the input string to be tokenized.
//sep// is the token separation substring.
//limit// is the token limit; If set to 0, there is no token limit available, so
that as much as possible tokens are read.

Returns the number of separated tokens, or -1 on error.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrtrim ===[fn_pstrtrim]

**Definition:**

%DEFINITION:BEGIN
char* pstrtrim( char* s )
%DEFINITION:END

**Usage:**

Removes beginning and trailing whitespace from a string.

//s// is the string to be trimmed.

Returns //s//.
%FUNCTION:END
%NEED:40
%FUNCTION:BEGIN
=== pstrunescape ===[fn_pstrunescape]

**Definition:**

%DEFINITION:BEGIN
char* pstrunescape( char* str )
%DEFINITION:END

**Usage:**

Converts a string with included escape-sequences back into its natural form.

The following table shows escape sequences which are converted.

|| Sequence | is replaced by |
| \n | newline |
| \t | tabulator |
| \r | carriage-return |
| \b | backspace |
| \f | form feed |
| \a | bell / alert |
| \' | single-quote |
| \" | double-quote |


The replacement is done within the memory bounds of //str// itself, because the
unescaped version of the character requires lesser space that its previous
escape sequence.

The function always returns its input pointer.

**Example:**
```
char* s = (char*)NULL;

psetstr( &s, "\\tHello\\nWorld!" );
printf( ">%s<\n", pstrunescape( s ) );

s = pfree( s );
```
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrupr ===[fn_pstrupr]

**Definition:**

%DEFINITION:BEGIN
char* pstrupr( char* s )
%DEFINITION:END

**Usage:**

Convert a string to upper-case order.

//s// is the acts both as input and output-string.

Returns //s//.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pvasprintf ===[fn_pvasprintf]

**Definition:**

%DEFINITION:BEGIN
int pvasprintf( char** str, char* fmt, va_list ap )
%DEFINITION:END

**Usage:**

Implementation and replacement for vasprintf.

//str// is the pointer receiving the resultung, allocated string pointer.
//fmt// is the the format string.
//...// are the parameters according to the placeholders set in //fmt//.

Returns the number of characters written, or -1 in error case.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pvm_create ===[fn_pvm_create]

**Definition:**

%DEFINITION:BEGIN
pvm* pvm_create( void )
%DEFINITION:END

**Usage:**

Creates a new virtual machine.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== pvm_define ===[fn_pvm_define]

**Definition:**

%DEFINITION:BEGIN
int pvm_define( pvm* vm, char* mn, pvmop op )
%DEFINITION:END

**Usage:**

Implements mnemonic //mn// with operational function //op// into //vm//.

Returns the operation's opcode, or a value < 0 on error.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pvm_free ===[fn_pvm_free]

**Definition:**

%DEFINITION:BEGIN
pvm* pvm_free( pvm* vm )
%DEFINITION:END

**Usage:**

Frees a virtual machine.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pvm_init ===[fn_pvm_init]

**Definition:**

%DEFINITION:BEGIN
pvm* pvm_init( pvm* vm )
%DEFINITION:END

**Usage:**

Initializes the virtual machine //vm//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pvm_prog_run ===[fn_pvm_prog_run]

**Definition:**

%DEFINITION:BEGIN
void pvm_prog_run( pany** ret, pvmprog* prog )
%DEFINITION:END

**Usage:**

Run vm
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pvm_reset ===[fn_pvm_reset]

**Definition:**

%DEFINITION:BEGIN
pvm* pvm_reset( pvm* vm )
%DEFINITION:END

**Usage:**

Resets a virtual machine //vm//.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pwcs_to_str ===[fn_pwcs_to_str]

**Definition:**

%DEFINITION:BEGIN
char* pwcs_to_str( wchar_t* str, pboolean freestr )
%DEFINITION:END

**Usage:**

This functions converts a wide-character string into an UTF-8 string.

The string conversion is performed into dynamically allocated memory.
The function wraps the system function [wcstombs() #fn_wcstombs], so [set_locale() #fn_set_locale] must be
called before this function works properly.

//str// is the zero-terminated string to be converted to UTF-8.
//freestr// defines if the input-string shall be freed after successfull
conversion, if set to TRUE.

Returns the UTF-8 character pendant of //str// as pointer to dynamically
allocated memory.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pwcscatchar ===[fn_pwcscatchar]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcscatchar( wchar_t* str, wchar_t chr )
%DEFINITION:END

**Usage:**

Appends a character to a dynamic wide-character string.

//str// is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated. //chr// is the the character
to be appended to str.

Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pwcscatstr ===[fn_pwcscatstr]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcscatstr( wchar_t* dest, wchar_t* src, pboolean freesrc )
%DEFINITION:END

**Usage:**

Appends a (possibly dynamic) wide-character string to a dynamic
wide-character string.

//str// is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
//append// is the the string to be appended.
//freesrc// if true, //append// is free'd automatically by this function.

Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pwcsdup ===[fn_pwcsdup]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsdup( wchar_t* str )
%DEFINITION:END

**Usage:**

Duplicate a wide-character string in memory.

//str// is the string to be copied in memory. If //str// is provided as NULL,
the function will also return NULL.

Returns a wchar_t*-pointer to the newly allocated copy of //str//. This pointer
must be released with [pfree() #fn_pfree] when its existence is no longer required.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== pwcsget ===[fn_pwcsget]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsget( wchar_t* str )
%DEFINITION:END

**Usage:**

Savely reads a wide-character string.

//str// is the string pointer to be savely read. If //str// is NULL, the
function returns a pointer to a static address holding an empty string.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== pwcslen ===[fn_pwcslen]

**Definition:**

%DEFINITION:BEGIN
size_t pwcslen( wchar_t* str )
%DEFINITION:END

**Usage:**

Saver strlen replacement for wide-character.

//str// is the parameter string to be evaluated. If (wchar_t*)NULL,
the function returns 0.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pwcsncatstr ===[fn_pwcsncatstr]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsncatstr( wchar_t* str, wchar_t* append, size_t n )
%DEFINITION:END

**Usage:**

Appends a number of N characters from one wide-character string to a dynamic
string.

//str// is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
//append// is the begin of character sequence to be appended.
//n// is the amount of characters to be appended to str.

Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
where NULL.
%FUNCTION:END
%NEED:26
%FUNCTION:BEGIN
=== pwcsndup ===[fn_pwcsndup]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsndup( wchar_t* str, size_t len )
%DEFINITION:END

**Usage:**

Duplicate //n// characters from a wide-character string in memory.

The function mixes the functionalities of [wcsdup() #fn_wcsdup] and [wcsncpy() #fn_wcsncpy].
The resulting wide-character string will be zero-terminated.

//str// is the parameter wide-character string to be duplicated.
If this is provided as (wchar_t*)NULL, the function will also return
(wchar_t*)NULL.

//n// is the the number of characters to be copied and duplicated from //str//.
If //n// is greater than the length of //str//, copying will stop at the zero
terminator.

Returns a wchar_t*-pointer to the allocated memory holding the zero-terminated
wide-character string duplicate. This pointer must be released with [pfree() #fn_pfree]
when its existence is no longer required.
%FUNCTION:END
%NEED:25
%FUNCTION:BEGIN
=== pwcsput ===[fn_pwcsput]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsput( wchar_t** str, wchar_t* val )
%DEFINITION:END

**Usage:**

Assign a wide-character string into a dynamically allocated pointer.
 [pwcsput() #fn_pwcsput] manages the assignment of an dynamically allocated  wide-chararacter
string.

//str// is a pointer receiving the target pointer to be (re)allocated. If
//str// already references a wide-character string, this pointer will be freed
and reassigned to a copy of //val//.

//val// is the the wide-character string to be assigned to //str//
(as a independent copy).

Returns a pointer to the allocated heap memory on success, (char_t*)NULL else.
This is the same pointer as returned like calling ``*str``. The returned pointer
must be released with [pfree() #fn_pfree] or another call of [pwcsput() #fn_pwcsput]. Calling [pwcsput() #fn_pwcsput]
as ``pwcsput( &p, (char*)NULL );`` is equivalent to ``p = pfree( &p )``.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pwhich ===[fn_pwhich]

**Definition:**

%DEFINITION:BEGIN
char* pwhich( char* filename, char* directories )
%DEFINITION:END

**Usage:**

Figures out a filepath by searching in a PATH definition.

//filename// is the filename to be searched for.

//directories// is a string specifying the directories to search in.
If this is (char*)NULL, the environment variable PATH will be used and
evaluated by using [getenv() #fn_getenv]. The path can be split with multiple pathes
by a character that depends on the current platform (Unix: ":", Windows: ";").

Returns a static pointer to the absolute path that contains the file specified
as filename, else it will return (char*)NULL.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== u8_char ===[fn_u8_char]

**Definition:**

%DEFINITION:BEGIN
wchar_t u8_char( char* str )
%DEFINITION:END

**Usage:**

Return single character (as wide-character value) from UTF-8 multi-byte
character string.

//str// is the pointer to character sequence begin.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== u8_isutf ===[fn_u8_isutf]

**Definition:**

%DEFINITION:BEGIN
pboolean u8_isutf( unsigned char c )
%DEFINITION:END

**Usage:**

Check for UTF-8 character sequence signature.

The function returns TRUE, if the character //c// is the beginning of a UTF-8
character signature, else FALSE.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== u8_move ===[fn_u8_move]

**Definition:**

%DEFINITION:BEGIN
char* u8_move( char* str, int count )
%DEFINITION:END

**Usage:**

Moves //count// characters ahead in an UTF-8 multi-byte character sequence.

//str// is the pointer to UTF-8 string to begin moving.
//count// is the number of characters to move left.

The function returns the address of the next UTF-8 character sequence after
//count// characters. If the string's end is reached, it will return a
pointer to the zero-terminator.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== u8_parse_char ===[fn_u8_parse_char]

**Definition:**

%DEFINITION:BEGIN
wchar_t u8_parse_char( char** ch )
%DEFINITION:END

**Usage:**

Read one character from an UTF-8 input sequence.
This character can be escaped, an UTF-8 character or an ordinary ASCII-char.

//chr// is the input- and output-pointer (the pointer is replaced by the pointer
to the next character or escape-sequence within the string.

The function teturns the character code of the parsed character.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== u8_seqlen ===[fn_u8_seqlen]

**Definition:**

%DEFINITION:BEGIN
int u8_seqlen(char *s)
%DEFINITION:END

**Usage:**

Returns length of next UTF-8 sequence in a multi-byte character string.

//s// is the pointer to begin of UTF-8 sequence.

Returns the number of bytes used for the next character.
%FUNCTION:END
